---
title: "Transports Overview"
description: "Understand the different protocols Contract supports and choose the right one for your project"
---

# Transports Overview

When you build an API with Contract, you write your business logic once. But different clients need to talk to your API in different ways. That's what transports are for - they let the same code speak multiple languages.

## What Is a Transport?

Think of a transport like a translator at the United Nations. The speaker (your service) gives the same message, but each translator converts it into a language their audience understands.

In Contract terms:
- **Your service** is the speaker - it has the business logic
- **Transports** are the translators - they convert requests/responses
- **Clients** are the audience - browsers, apps, AI assistants, etc.

```
┌──────────────────────────────────────────────────────────────────┐
│                        Your Service                               │
│                   (Written once, in Go)                           │
└──────────────────────────────────────────────────────────────────┘
                              │
        ┌─────────────────────┼─────────────────────┐
        ▼                     ▼                     ▼
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│     REST     │      │   JSON-RPC   │      │     MCP      │
│  (Familiar)  │      │  (Powerful)  │      │ (AI-Ready)   │
└──────────────┘      └──────────────┘      └──────────────┘
        │                     │                     │
        ▼                     ▼                     ▼
   Web Browsers          Backend Services        AI Assistants
   Mobile Apps           Microservices           Claude Desktop
```

## Available Transports

Contract supports five transports. Here's a quick overview:

| Transport | What It Is | Best For |
|-----------|------------|----------|
| **REST** | Traditional HTTP API | Web apps, mobile apps, curl |
| **JSON-RPC** | Remote procedure calls over HTTP | Batch operations, microservices |
| **MCP** | Model Context Protocol | AI assistants like Claude |
| **tRPC** | TypeScript-friendly RPC | TypeScript frontends |
| **OpenAPI** | API documentation standard | Docs, code generation |

## Decision Guide: Which Transport Should I Use?

Use this flowchart to pick the right transport for your use case:

```
Start Here
    │
    ▼
Who is calling your API?
    │
    ├─► Web browsers, mobile apps, or curl
    │   → Use REST (most familiar)
    │
    ├─► Other backend services
    │   → Use JSON-RPC (supports batching)
    │
    ├─► TypeScript frontend with type safety
    │   → Use tRPC (generates types)
    │
    ├─► AI assistants (Claude, etc.)
    │   → Use MCP (designed for AI)
    │
    └─► Need API documentation
        → Add OpenAPI (generates docs)
```

**Pro tip**: You can (and should!) use multiple transports at once. They don't conflict.

## Detailed Comparison

### Feature Comparison

| Feature | REST | JSON-RPC | MCP | tRPC |
|---------|------|----------|-----|------|
| **HTTP Methods** | GET/POST/PUT/DELETE | POST only | POST only | POST only |
| **Batch Requests** | No | Yes | No | No |
| **Cacheable** | Yes (GET requests) | No | No | No |
| **Self-Documenting** | Via OpenAPI | No | Via tools/list | Via .meta |
| **Error Format** | HTTP status codes | JSON-RPC errors | isError flag | tRPC envelope |

### REST - The Classic Choice

REST is the most widely known API style. It uses HTTP methods to represent actions:

```bash
# Create a todo (POST = create new resource)
curl -X POST http://localhost:8080/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Buy milk"}'

# List all todos (GET = retrieve data)
curl http://localhost:8080/todos

# Get one todo (GET with ID)
curl http://localhost:8080/todos/123

# Update a todo (PUT = replace resource)
curl -X PUT http://localhost:8080/todos/123 \
  -d '{"title": "Buy milk", "completed": true}'

# Delete a todo (DELETE = remove resource)
curl -X DELETE http://localhost:8080/todos/123
```

**When to use REST**:
- Your clients are web browsers or mobile apps
- You want caching (browsers cache GET requests)
- Your team is familiar with REST APIs
- You're building a public API

**Pros**: Familiar, cacheable, works everywhere
**Cons**: No batching, multiple round trips for complex operations

### JSON-RPC - The Power User's Choice

JSON-RPC is a simple protocol where you explicitly name the method to call. All requests use POST.

```bash
# Call a method
curl -X POST http://localhost:8080/rpc \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "Create",
    "params": {"title": "Buy milk"}
  }'

# Response
{"jsonrpc": "2.0", "id": 1, "result": {"id": "1", "title": "Buy milk"}}
```

The killer feature is **batching** - send multiple operations in one request:

```bash
curl -X POST http://localhost:8080/rpc \
  -H "Content-Type: application/json" \
  -d '[
    {"jsonrpc": "2.0", "id": 1, "method": "Create", "params": {"title": "First"}},
    {"jsonrpc": "2.0", "id": 2, "method": "Create", "params": {"title": "Second"}},
    {"jsonrpc": "2.0", "id": 3, "method": "List"}
  ]'

# All three operations execute, returns array of results
```

**When to use JSON-RPC**:
- Service-to-service communication
- You need to batch multiple operations
- Network latency is a concern
- Your operations don't map cleanly to REST verbs

**Pros**: Batching, explicit method names, standard protocol
**Cons**: POST only, less familiar to web developers

### MCP - The AI-Native Choice

MCP (Model Context Protocol) is designed for AI assistants. It lets AI models discover and use your API as "tools".

```bash
# Step 1: Initialize the connection
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc": "2.0", "id": 1, "method": "initialize", "params": {"protocolVersion": "2025-06-18"}}'

# Step 2: Discover available tools
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc": "2.0", "id": 2, "method": "tools/list"}'

# Response shows what the AI can do:
{
  "result": {
    "tools": [
      {
        "name": "todo.Create",
        "description": "Create a new todo",
        "inputSchema": {...}
      }
    ]
  }
}

# Step 3: Call a tool
curl -X POST http://localhost:8080/mcp \
  -d '{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "todo.Create",
      "arguments": {"title": "Buy milk"}
    }
  }'
```

**When to use MCP**:
- You want Claude or other AI assistants to use your API
- You're building AI-powered applications
- You want automatic tool discovery

**Pros**: AI assistants understand it natively, self-documenting
**Cons**: Specialized use case, more complex protocol

### tRPC - The TypeScript Developer's Choice

tRPC uses simple URL paths with JSON bodies. It includes a metadata endpoint for generating TypeScript types.

```bash
# Call a procedure
curl -X POST http://localhost:8080/trpc/Create \
  -H "Content-Type: application/json" \
  -d '{"title": "Buy milk"}'

# Response with typed envelope
{
  "result": {
    "data": {"id": "1", "title": "Buy milk"}
  }
}

# Get metadata for type generation
curl http://localhost:8080/trpc.meta
```

**When to use tRPC**:
- Your frontend is TypeScript
- You want end-to-end type safety
- You're generating client code

**Pros**: Clean URLs, type generation, familiar to tRPC users
**Cons**: POST only, no batching

### OpenAPI - The Documentation Choice

OpenAPI isn't really a transport - it generates documentation from your service. Use it alongside other transports.

```bash
# Get the OpenAPI specification
curl http://localhost:8080/openapi.json
```

The spec can be used with:
- **Swagger UI**: Interactive API documentation
- **Code generators**: Generate client SDKs in any language
- **API testing tools**: Import into Postman, Insomnia, etc.

## Using All Transports Together

Here's how to serve your API via all protocols at once:

```go
package main

import (
    "net/http"

    "github.com/go-mizu/mizu/contract"
    "github.com/go-mizu/mizu/contract/transport/mcp"
    "github.com/go-mizu/mizu/contract/transport/trpc"
)

func main() {
    // Create and register your service
    svc, _ := contract.Register("todo", &TodoService{})

    mux := http.NewServeMux()

    // REST: Traditional HTTP API
    // Endpoints: POST/GET /todos, GET/DELETE /todos/{id}
    contract.MountREST(mux, svc)

    // JSON-RPC: RPC-style with batching
    // Endpoint: POST /rpc
    contract.MountJSONRPC(mux, "/rpc", svc)

    // tRPC: TypeScript-friendly
    // Endpoints: POST /trpc/{method}, GET /trpc.meta
    trpc.Mount(mux, "/trpc", svc)

    // MCP: AI assistant integration
    // Endpoint: POST /mcp
    mcp.Mount(mux, "/mcp", svc)

    // OpenAPI: API documentation
    // Endpoint: GET /openapi.json
    contract.ServeOpenAPI(mux, "/openapi.json", svc)

    http.ListenAndServe(":8080", mux)
}
```

Now the same service is accessible via:
- `http://localhost:8080/todos` (REST)
- `http://localhost:8080/rpc` (JSON-RPC)
- `http://localhost:8080/trpc/Create` (tRPC)
- `http://localhost:8080/mcp` (MCP)
- `http://localhost:8080/openapi.json` (OpenAPI spec)

## How Errors Work Across Transports

One of Contract's best features is consistent error handling. When you return an error:

```go
return nil, contract.ErrNotFound("todo not found")
```

Each transport formats it appropriately:

| Transport | Error Response |
|-----------|----------------|
| REST | HTTP 404 status, body: `"todo not found"` |
| JSON-RPC | `{"error": {"code": -32601, "message": "todo not found"}}` |
| tRPC | `{"error": {"code": "NOT_FOUND", "message": "todo not found"}}` |
| MCP | `{"isError": true, "content": [{"text": "todo not found"}]}` |

You don't need to handle each protocol separately.

## Practical Recommendations

### Starting a New Project

Start with REST + OpenAPI:
```go
contract.MountREST(mux, svc)
contract.ServeOpenAPI(mux, "/openapi.json", svc)
```

Add more transports as needed.

### Building a Web Application

REST for browsers, optionally add tRPC for TypeScript:
```go
contract.MountREST(mux, svc)
trpc.Mount(mux, "/trpc", svc)  // If using TypeScript
```

### Building Microservices

JSON-RPC for service-to-service (batching is valuable):
```go
contract.MountJSONRPC(mux, "/rpc", svc)
```

### Building AI-Powered Apps

MCP for AI assistants, plus REST for human debugging:
```go
mcp.Mount(mux, "/mcp", svc)
contract.MountREST(mux, svc)  // For testing with curl
```

### Building for Everything

Use all of them! There's no conflict:
```go
contract.MountREST(mux, svc)
contract.MountJSONRPC(mux, "/rpc", svc)
trpc.Mount(mux, "/trpc", svc)
mcp.Mount(mux, "/mcp", svc)
contract.ServeOpenAPI(mux, "/openapi.json", svc)
```

## Common Questions

### Can I use multiple transports at once?

Yes! Each transport uses different paths, so they don't conflict. This is actually recommended.

### Which transport is fastest?

They're all similar in performance. The overhead is minimal compared to your actual business logic.

### Do I need to write different code for each transport?

No! That's the whole point of Contract. Write your service once, expose it via any transport.

### Can I customize how a transport works?

Yes, each transport has options for customization. See the individual transport pages for details.

## Learn More

Each transport has its own detailed documentation:

- **[REST Transport](/contract/rest)** - HTTP verbs, path patterns, customization
- **[JSON-RPC Transport](/contract/jsonrpc)** - Batching, notifications, error codes
- **[MCP Transport](/contract/mcp)** - AI integration, Claude Desktop setup
- **[tRPC Transport](/contract/trpc)** - TypeScript types, metadata endpoint
- **[OpenAPI](/contract/openapi)** - Documentation, Swagger UI, code generation
