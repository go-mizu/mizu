---
title: "Contract Overview"
description: "Learn what the Contract package is and how it helps you build APIs in Go with compile-time safety"
---

## What is Contract?

Contract is a Go package that lets you define your API as a Go interface, then automatically expose it through multiple protocols (REST, JSON-RPC, MCP) without duplicating code. Write your business logic once, serve it everywhere.

The key insight is simple: **your API is a contract between you and your clients**. Contract takes this literally by using Go interfaces to define that contract, giving you compile-time safety and clear API boundaries.

## The Problem Contract Solves

Imagine you're building a todo list application. You want to:
- Let web browsers call your API via REST
- Let other services call via JSON-RPC for batching
- Let AI assistants (like Claude) use your API via MCP
- Generate TypeScript types for your frontend

Without Contract, you'd write repetitive code for each protocol:

```go
// REST handler - one version
func handleRESTCreateTodo(w http.ResponseWriter, r *http.Request) {
    var input CreateInput
    json.NewDecoder(r.Body).Decode(&input)
    todo, err := createTodo(input)
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    json.NewEncoder(w).Encode(todo)
}

// JSON-RPC handler - another version
func handleJSONRPCCreateTodo(req JSONRPCRequest) JSONRPCResponse {
    var input CreateInput
    json.Unmarshal(req.Params, &input)
    todo, err := createTodo(input)
    if err != nil {
        return JSONRPCResponse{Error: ...}
    }
    return JSONRPCResponse{Result: todo}
}

// MCP handler - yet another version...
```

That's a lot of repetitive code! And if you add a new field to `CreateInput`, you need to update every handler.

## The Contract Solution

With Contract, you define your API as a Go interface:

```go
// Define the contract - what your API can do
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
    Get(ctx context.Context, in *GetInput) (*Todo, error)
    Delete(ctx context.Context, in *DeleteInput) error
}
```

Then implement it with your business logic:

```go
// Implement the contract
type todoService struct {
    db Database
}

func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    return &Todo{ID: generateID(), Title: in.Title}, nil
}
// ... other methods
```

Finally, register and serve:

```go
import (
    contract "github.com/go-mizu/mizu/contract/v2"
    "github.com/go-mizu/mizu/contract/v2/transport/rest"
    "github.com/go-mizu/mizu/contract/v2/transport/jsonrpc"
    "github.com/go-mizu/mizu/contract/v2/transport/mcp"
)

// Register your implementation against the interface
svc := contract.Register[TodoAPI](&todoService{},
    contract.WithDefaultResource("todos"),
)

// Mount on all transports
rest.Mount(app.Router, svc)              // REST: POST /todos, GET /todos, etc.
jsonrpc.Mount(app.Router, "/rpc", svc)   // JSON-RPC: todos.create, todos.list
mcp.Mount(app.Router, "/mcp", svc)       // MCP tools for AI assistants
```

**One implementation, all protocols.** Change your interface, and all transports update automatically.

## Why Interface-First?

Contract uses Go interfaces to define your API. This is called "interface-first" or "contract-first" design, and it has several benefits:

### Compile-Time Safety

If your implementation doesn't match the interface, Go's compiler catches it:

```go
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
}

type brokenService struct{}

// Compiler error: brokenService does not implement TodoAPI
// (missing method Create)
```

### Clear API Boundaries

The interface is your API documentation. Anyone can read it and understand exactly what your service does:

```go
// This interface IS your API contract
type UserAPI interface {
    // Create a new user account
    Create(ctx context.Context, in *CreateUserInput) (*User, error)

    // Get user by ID
    Get(ctx context.Context, in *GetUserInput) (*User, error)

    // List all users with pagination
    List(ctx context.Context, in *ListUsersInput) (*ListUsersOutput, error)

    // Delete a user account
    Delete(ctx context.Context, in *DeleteUserInput) error
}
```

### Easy Testing

You can mock the interface for testing:

```go
// In your tests
type mockUserAPI struct{}

func (m *mockUserAPI) Create(ctx context.Context, in *CreateUserInput) (*User, error) {
    return &User{ID: "test-123", Name: in.Name}, nil
}

// Use the mock in tests
```

### Separation of Concerns

The interface separates "what your API does" from "how it's implemented":

```go
// The contract (what)
type StorageAPI interface {
    Save(ctx context.Context, in *SaveInput) error
    Load(ctx context.Context, in *LoadInput) (*Data, error)
}

// Implementation 1: File system (how)
type fileStorage struct { basePath string }

// Implementation 2: S3 (how)
type s3Storage struct { bucket string }

// Implementation 3: In-memory for tests (how)
type memoryStorage struct { data map[string][]byte }

// All implement the same interface!
```

## How Contract Works

Here's what happens when you use Contract:

```
                    Your Go Interface
                          │
                          ▼
            contract.Register[TodoAPI](impl)
                          │
                          │  Inspects interface methods
                          │  Extracts input/output types
                          │  Generates JSON schemas
                          ▼
                   ┌─────────────┐
                   │   Service   │
                   │  Descriptor │
                   │  - Methods  │
                   │  - Types    │
                   │  - HTTP     │
                   └─────────────┘
                          │
         ┌────────────────┼────────────────┐
         ▼                ▼                ▼
    ┌─────────┐     ┌──────────┐     ┌─────────┐
    │  REST   │     │ JSON-RPC │     │   MCP   │
    │ Handler │     │ Handler  │     │ Handler │
    └─────────┘     └──────────┘     └─────────┘
         │                │                │
         ▼                ▼                ▼
    Web Browsers    Other Services    AI Assistants
```

1. **You define** an interface with your API methods
2. **You implement** the interface with your business logic
3. **Contract inspects** your interface at startup (using reflection)
4. **Contract creates** type-safe invokers and JSON schemas
5. **Transport handlers** convert protocol-specific requests into method calls
6. **Your method runs** and returns results or errors
7. **Transport handlers** convert the response back to the protocol format

## Key Concepts

### Interface (The Contract)

An interface defines what operations your API supports. Every method in the interface becomes an API endpoint:

```go
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
    Get(ctx context.Context, in *GetInput) (*Todo, error)
    Delete(ctx context.Context, in *DeleteInput) error
}
```

### Implementation

A struct that implements the interface with your actual business logic:

```go
type todoService struct {
    db Database  // Your dependencies
}

func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    // Your business logic here
}
```

### Resource

A resource is a namespace for related methods. Methods are grouped into resources for organization:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithDefaultResource("todos"),  // All methods go to "todos" resource
)
```

This makes your API endpoints:
- REST: `/todos` (POST, GET), `/todos/{id}` (GET, DELETE)
- JSON-RPC: `todos.create`, `todos.list`, `todos.get`, `todos.delete`

### Transport

A transport is a protocol handler that converts HTTP requests into method calls. Contract provides:

| Transport | Protocol | Best For |
|-----------|----------|----------|
| REST | HTTP REST | Web browsers, curl, general HTTP |
| JSON-RPC | JSON-RPC 2.0 | Batch operations, RPC clients |
| MCP | Model Context Protocol | AI assistants (Claude, etc.) |

### Type Registry

Contract automatically creates JSON schemas from your Go types. These schemas are used for:
- Input validation
- API documentation (OpenAPI)
- Client code generation
- AI tool definitions (MCP)

## What You'll Learn

This documentation will teach you:

1. **[Quick Start](/contract/quick-start)** - Build your first API in 5 minutes
2. **[Defining Services](/contract/service)** - How to write interfaces and implementations
3. **[Registration](/contract/register)** - How Contract processes your service
4. **[Type System](/contract/types)** - Understanding types and JSON schemas
5. **[Error Handling](/contract/errors)** - How to return errors that work across protocols
6. **[Transports](/contract/transports-overview)** - Choosing and using different protocols
7. **[Testing](/contract/testing)** - How to test your services
8. **[Architecture](/contract/architecture)** - Deep dive into how it all works

## Quick Example

Here's a complete, working example:

```go
package main

import (
    "context"
    "fmt"

    "github.com/go-mizu/mizu"
    contract "github.com/go-mizu/mizu/contract/v2"
    "github.com/go-mizu/mizu/contract/v2/transport/rest"
    "github.com/go-mizu/mizu/contract/v2/transport/jsonrpc"
)

// Step 1: Define your types
type GreetInput struct {
    Name string `json:"name"`
}

type GreetOutput struct {
    Message string `json:"message"`
}

// Step 2: Define your interface (the contract)
type GreetingAPI interface {
    Greet(ctx context.Context, in *GreetInput) (*GreetOutput, error)
}

// Step 3: Implement the interface
type greetingService struct{}

func (s *greetingService) Greet(ctx context.Context, in *GreetInput) (*GreetOutput, error) {
    return &GreetOutput{
        Message: fmt.Sprintf("Hello, %s!", in.Name),
    }, nil
}

func main() {
    // Step 4: Register your service
    svc := contract.Register[GreetingAPI](&greetingService{},
        contract.WithDefaultResource("greetings"),
    )

    // Step 5: Create app and mount transports
    app := mizu.New()
    rest.Mount(app.Router, svc)
    jsonrpc.Mount(app.Router, "/rpc", svc)

    // Step 6: Start the server
    fmt.Println("Server running on http://localhost:8080")
    app.Listen(":8080")
}
```

Test it:

```bash
# REST
curl -X POST http://localhost:8080/greetings \
  -H "Content-Type: application/json" \
  -d '{"name": "World"}'
# Output: {"message":"Hello, World!"}

# JSON-RPC
curl -X POST http://localhost:8080/rpc \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"greetings.greet","params":{"name":"World"}}'
# Output: {"jsonrpc":"2.0","id":1,"result":{"message":"Hello, World!"}}
```

## Common Questions

### Do I need to learn all the transports?

No! Start with REST - it's the most familiar. You can add other transports later as needed. Your business logic stays exactly the same.

### Is Contract only for new projects?

Contract works great for new projects, but you can also gradually adopt it in existing codebases. Start by converting one service and see how it fits.

### How does Contract handle authentication?

Contract doesn't dictate how you handle auth. Use standard mizu middleware to authenticate requests before they reach your methods. Context values let you pass user information to your service methods.

### Why use interfaces instead of structs?

Interfaces give you compile-time safety. If your implementation doesn't match the interface, the compiler catches it. With struct-based approaches, you only find out at runtime if a method signature is wrong.

## Next Steps

Ready to build your first API? Start with the **[Quick Start Guide](/contract/quick-start)** - you'll have a working API in 5 minutes.

If you prefer understanding the concepts first, read about **[Defining Services](/contract/service)** to learn how to structure your interfaces and implementations.
