---
title: "Invokers"
description: "Understand how Contract calls your methods efficiently at runtime"
---

# Invokers

Invokers are the engine that makes Contract fast. They're pre-compiled method callers that let Contract call your service methods without the overhead of reflection on every request.

## What Is an Invoker?

When you register a service, Contract analyzes your methods using Go's reflection system. This analysis happens once at startup, and the results are stored as "invokers" - optimized callers that know exactly how to call each method.

```
Registration time (once):
Service → Reflection → Invoker created

Runtime (every request):
Request → Invoker.Call() → Your Method
           ↓
    No reflection needed!
```

## Why Invokers Matter

Without invokers, calling a method by name would require reflection on every request:

```go
// Slow way: Reflection on every call
method := reflect.ValueOf(service).MethodByName("Create")
args := []reflect.Value{reflect.ValueOf(ctx), reflect.ValueOf(input)}
result := method.Call(args)  // Expensive!
```

With invokers, the reflection cost is paid once at startup:

```go
// Fast way: Pre-compiled invoker
result, err := method.Invoker.Call(ctx, input)  // Just a function call
```

## Basic Usage

Most of the time, you don't interact with invokers directly - transports use them automatically. But here's how they work:

### Getting a Method and Its Invoker

```go
svc, _ := contract.Register("todo", &TodoService{})

// Get a specific method
method := svc.Resolve("Create")

// method.Invoker is ready to use
```

### Calling a Method

```go
// Create input
input := &CreateInput{Title: "Buy milk"}

// Call the method using its invoker
result, err := method.Invoker.Call(ctx, input)
if err != nil {
    log.Fatal(err)
}

// Type assert the result
todo := result.(*Todo)
fmt.Println(todo.ID, todo.Title)
```

## The Invoker Interface

Invokers implement a simple interface:

```go
type Invoker interface {
    Call(ctx context.Context, in any) (any, error)
}
```

| Parameter | Type | Description |
|-----------|------|-------------|
| `ctx` | `context.Context` | Request context (timeouts, cancellation, values) |
| `in` | `any` | Input value (nil for methods without input) |

| Return | Type | Description |
|--------|------|-------------|
| result | `any` | Output value (nil for methods without output) |
| err | `error` | Any error returned by your method |

## Calling Different Method Types

### Method With Input and Output

```go
// Service method:
func (s *Service) Create(ctx context.Context, in *CreateInput) (*Todo, error)

// Calling with invoker:
method := svc.Resolve("Create")
input := &CreateInput{Title: "Test"}
result, err := method.Invoker.Call(ctx, input)
todo := result.(*Todo)
```

### Method With Output Only (No Input)

```go
// Service method:
func (s *Service) List(ctx context.Context) (*ListOutput, error)

// Calling with invoker:
method := svc.Resolve("List")
result, err := method.Invoker.Call(ctx, nil)  // Pass nil for input
list := result.(*ListOutput)
```

### Method With Input Only (No Output)

```go
// Service method:
func (s *Service) Delete(ctx context.Context, in *DeleteInput) error

// Calling with invoker:
method := svc.Resolve("Delete")
input := &DeleteInput{ID: "123"}
_, err := method.Invoker.Call(ctx, input)  // Result is nil
```

### Method With Neither Input Nor Output

```go
// Service method:
func (s *Service) Health(ctx context.Context) error

// Calling with invoker:
method := svc.Resolve("Health")
_, err := method.Invoker.Call(ctx, nil)  // Both input and result are nil
```

## Creating Input Instances

Use `NewInput()` to create a new input instance for a method:

```go
method := svc.Resolve("Create")

// Check if method has input
if method.Input != nil {
    // Create a new input instance
    input := method.NewInput()

    // Type assert and populate
    createInput := input.(*CreateInput)
    createInput.Title = "Test"

    // Call the method
    result, err := method.Invoker.Call(ctx, createInput)
}
```

This is useful when you don't know the input type at compile time (like in transports).

## How Transports Use Invokers

Here's simplified code showing how a transport uses invokers:

```go
func handleRequest(svc *contract.Service, methodName string, body []byte) (any, error) {
    // 1. Find the method
    method := svc.Resolve(methodName)
    if method == nil {
        return nil, errors.New("method not found")
    }

    // 2. Parse input if method has one
    var input any
    if method.Input != nil {
        input = method.NewInput()
        if err := json.Unmarshal(body, input); err != nil {
            return nil, errors.New("invalid input")
        }
    }

    // 3. Call the method
    result, err := method.Invoker.Call(context.Background(), input)
    if err != nil {
        return nil, err
    }

    // 4. Return result
    return result, nil
}
```

## Transport Invoker

For transports, there's a higher-level interface called `TransportInvoker`:

```go
type TransportInvoker interface {
    Invoke(ctx context.Context, method *Method, input []byte) (any, error)
}
```

The difference from `Invoker`:
- Takes raw bytes instead of parsed input
- Handles JSON unmarshaling internally
- Used by middleware for wrapping

### Default Transport Invoker

Get the default transport invoker for a service:

```go
invoker := contract.DefaultInvoker(svc)

// Now you can call methods with raw JSON
result, err := invoker.Invoke(ctx, method, []byte(`{"title":"Test"}`))
```

### Custom Transport Invoker

Create custom invokers for middleware:

```go
type LoggingInvoker struct {
    inner contract.TransportInvoker
}

func (l *LoggingInvoker) Invoke(ctx context.Context, method *contract.Method, input []byte) (any, error) {
    log.Printf("Calling: %s", method.Name)
    start := time.Now()

    result, err := l.inner.Invoke(ctx, method, input)

    log.Printf("Finished: %s (took %v)", method.Name, time.Since(start))
    return result, err
}

// Use it
loggingInvoker := &LoggingInvoker{inner: contract.DefaultInvoker(svc)}
mcp.Mount(mux, "/mcp", svc, mcp.WithInvoker(loggingInvoker))
```

## Error Handling

Errors from your method are returned directly:

```go
// Your method returns an error
func (s *Service) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    if in.ID == "" {
        return nil, contract.ErrInvalidArgument("id is required")
    }
    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, contract.ErrNotFound("todo not found")
    }
    return todo, nil
}

// Caller receives the error
result, err := method.Invoker.Call(ctx, &GetInput{ID: ""})
if err != nil {
    // err is the ErrInvalidArgument error
    fmt.Println(err.Error())  // "id is required"
}
```

## Context Handling

The context is passed directly to your method:

```go
// With timeout
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

result, err := method.Invoker.Call(ctx, input)
if errors.Is(err, context.DeadlineExceeded) {
    // Handle timeout
}

// With values
ctx = context.WithValue(ctx, userKey, currentUser)
result, err := method.Invoker.Call(ctx, input)
// Your method can access ctx.Value(userKey)
```

## Type Safety

Always use type assertions when working with results:

```go
result, err := method.Invoker.Call(ctx, input)
if err != nil {
    return err
}

// Safe type assertion with check
todo, ok := result.(*Todo)
if !ok {
    return fmt.Errorf("unexpected type: %T", result)
}
```

For methods you know the types of:

```go
// When you know it returns *Todo
result, _ := method.Invoker.Call(ctx, input)
todo := result.(*Todo)  // Direct assertion (panics if wrong)
```

## Building a Custom Transport

Here's a complete example of using invokers to build a custom transport:

```go
package customtransport

import (
    "encoding/json"
    "net/http"

    "github.com/go-mizu/mizu/contract"
)

func Mount(mux *http.ServeMux, path string, svc *contract.Service) {
    invoker := contract.DefaultInvoker(svc)

    mux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
        // Get method name from query string
        methodName := r.URL.Query().Get("method")
        if methodName == "" {
            http.Error(w, "method required", http.StatusBadRequest)
            return
        }

        // Find the method
        method := svc.Resolve(methodName)
        if method == nil {
            http.Error(w, "method not found", http.StatusNotFound)
            return
        }

        // Read request body
        var body []byte
        if r.Body != nil {
            body, _ = io.ReadAll(r.Body)
        }

        // Call the method
        result, err := invoker.Invoke(r.Context(), method, body)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        // Write response
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(result)
    })
}
```

Usage:
```go
svc, _ := contract.Register("todo", &TodoService{})
customtransport.Mount(mux, "/api", svc)
// Call: GET /api?method=Create with JSON body
```

## Performance Characteristics

| Operation | When | Cost |
|-----------|------|------|
| Reflection analysis | Registration (startup) | Slow, but once |
| Invoker.Call() | Every request | Fast (direct call) |
| Type assertion | Every request | Very fast |
| JSON parsing | Every request | Normal cost |

The key insight: Heavy reflection happens once at startup, so runtime calls are fast.

## Common Patterns

### Checking Method Capabilities

```go
method := svc.Resolve("Create")

// Does it have input?
if method.Input != nil {
    fmt.Println("Input type:", method.Input.Name)
}

// Does it have output?
if method.Output != nil {
    fmt.Println("Output type:", method.Output.Name)
}
```

### Iterating All Methods

```go
for _, method := range svc.Methods {
    fmt.Printf("Method: %s\n", method.Name)
    fmt.Printf("  Has Input: %v\n", method.Input != nil)
    fmt.Printf("  Has Output: %v\n", method.Output != nil)
}
```

### Dynamic Method Dispatch

```go
func callMethod(svc *contract.Service, name string, inputJSON []byte) ([]byte, error) {
    method := svc.Resolve(name)
    if method == nil {
        return nil, fmt.Errorf("unknown method: %s", name)
    }

    invoker := contract.DefaultInvoker(svc)
    result, err := invoker.Invoke(context.Background(), method, inputJSON)
    if err != nil {
        return nil, err
    }

    return json.Marshal(result)
}
```

## See Also

- [Registration](/contract/register) - How invokers are created
- [Middleware](/contract/middleware) - Wrapping invokers with middleware
- [Architecture](/contract/architecture) - Where invokers fit in the system
