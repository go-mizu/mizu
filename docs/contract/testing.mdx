---
title: "Testing"
description: "Test your Contract services effectively"
---

# Testing

Contract services are easy to test because they're plain Go structs with no framework dependencies. Test at multiple levels: unit tests for business logic, integration tests for transports.

## Unit Testing Services

Test your service methods directly without any transport:

```go
package todo_test

import (
    "context"
    "testing"

    "yourmodule/service/todo"
)

func TestCreate(t *testing.T) {
    svc := &todo.Service{}

    result, err := svc.Create(context.Background(), &todo.CreateInput{
        Title: "Buy groceries",
    })

    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if result.Title != "Buy groceries" {
        t.Errorf("expected title 'Buy groceries', got '%s'", result.Title)
    }
}
```

### Table-Driven Tests

```go
func TestCreate_Validation(t *testing.T) {
    tests := []struct {
        name    string
        input   *todo.CreateInput
        wantErr bool
    }{
        {
            name:    "valid input",
            input:   &todo.CreateInput{Title: "Test"},
            wantErr: false,
        },
        {
            name:    "empty title",
            input:   &todo.CreateInput{Title: ""},
            wantErr: true,
        },
        {
            name:    "nil input",
            input:   nil,
            wantErr: true,
        },
    }

    svc := &todo.Service{}

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            _, err := svc.Create(context.Background(), tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("Create() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}
```

### Testing Error Codes

```go
import "github.com/go-mizu/mizu/contract"

func TestGet_NotFound(t *testing.T) {
    svc := &todo.Service{}

    _, err := svc.Get(context.Background(), &todo.GetInput{ID: "nonexistent"})

    if err == nil {
        t.Fatal("expected error, got nil")
    }

    var contractErr *contract.Error
    if !errors.As(err, &contractErr) {
        t.Fatalf("expected contract.Error, got %T", err)
    }

    if contractErr.Code != contract.ErrCodeNotFound {
        t.Errorf("expected NOT_FOUND, got %s", contractErr.Code)
    }
}
```

## Testing with Dependencies

### Dependency Injection

```go
// Service with dependencies
type Service struct {
    db    Database
    cache Cache
}

// Interface for mocking
type Database interface {
    FindTodo(ctx context.Context, id string) (*Todo, error)
    SaveTodo(ctx context.Context, todo *Todo) error
}

// Test with mock
func TestGet_WithMock(t *testing.T) {
    mockDB := &MockDatabase{
        todos: map[string]*Todo{
            "1": {ID: "1", Title: "Test"},
        },
    }

    svc := &Service{db: mockDB}

    result, err := svc.Get(context.Background(), &GetInput{ID: "1"})
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if result.Title != "Test" {
        t.Errorf("expected 'Test', got '%s'", result.Title)
    }
}
```

### Using testify/mock

```go
import "github.com/stretchr/testify/mock"

type MockDatabase struct {
    mock.Mock
}

func (m *MockDatabase) FindTodo(ctx context.Context, id string) (*Todo, error) {
    args := m.Called(ctx, id)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*Todo), args.Error(1)
}

func TestGet_WithTestify(t *testing.T) {
    mockDB := new(MockDatabase)
    mockDB.On("FindTodo", mock.Anything, "1").Return(&Todo{ID: "1", Title: "Test"}, nil)

    svc := &Service{db: mockDB}

    result, _ := svc.Get(context.Background(), &GetInput{ID: "1"})

    assert.Equal(t, "Test", result.Title)
    mockDB.AssertExpectations(t)
}
```

## Integration Testing Transports

### Testing REST

```go
import (
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"

    "github.com/go-mizu/mizu/contract"
)

func TestREST_Create(t *testing.T) {
    svc, _ := contract.Register("todo", &todo.Service{})

    mux := http.NewServeMux()
    contract.MountREST(mux, svc)

    body := strings.NewReader(`{"title":"Test"}`)
    req := httptest.NewRequest("POST", "/todos", body)
    req.Header.Set("Content-Type", "application/json")

    rec := httptest.NewRecorder()
    mux.ServeHTTP(rec, req)

    if rec.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", rec.Code)
    }

    // Parse response
    var result todo.Todo
    json.NewDecoder(rec.Body).Decode(&result)

    if result.Title != "Test" {
        t.Errorf("expected 'Test', got '%s'", result.Title)
    }
}
```

### Testing JSON-RPC

```go
func TestJSONRPC_Create(t *testing.T) {
    svc, _ := contract.Register("todo", &todo.Service{})

    mux := http.NewServeMux()
    contract.MountJSONRPC(mux, "/rpc", svc)

    body := strings.NewReader(`{
        "jsonrpc": "2.0",
        "id": 1,
        "method": "Create",
        "params": {"title": "Test"}
    }`)
    req := httptest.NewRequest("POST", "/rpc", body)
    req.Header.Set("Content-Type", "application/json")

    rec := httptest.NewRecorder()
    mux.ServeHTTP(rec, req)

    var resp struct {
        Result json.RawMessage `json:"result"`
        Error  *struct {
            Code    int    `json:"code"`
            Message string `json:"message"`
        } `json:"error"`
    }
    json.NewDecoder(rec.Body).Decode(&resp)

    if resp.Error != nil {
        t.Fatalf("unexpected error: %s", resp.Error.Message)
    }
}
```

### Testing MCP

```go
import "github.com/go-mizu/mizu/contract/transport/mcp"

func TestMCP_ToolsCall(t *testing.T) {
    svc, _ := contract.Register("todo", &todo.Service{})

    mux := http.NewServeMux()
    mcp.Mount(mux, "/mcp", svc)

    // First initialize
    initBody := strings.NewReader(`{
        "jsonrpc": "2.0",
        "id": 1,
        "method": "initialize",
        "params": {"protocolVersion": "2025-06-18"}
    }`)
    initReq := httptest.NewRequest("POST", "/mcp", initBody)
    rec := httptest.NewRecorder()
    mux.ServeHTTP(rec, initReq)

    // Then call tool
    callBody := strings.NewReader(`{
        "jsonrpc": "2.0",
        "id": 2,
        "method": "tools/call",
        "params": {
            "name": "todo.Create",
            "arguments": {"title": "Test"}
        }
    }`)
    callReq := httptest.NewRequest("POST", "/mcp", callBody)
    rec = httptest.NewRecorder()
    mux.ServeHTTP(rec, callReq)

    // Verify response
    if rec.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", rec.Code)
    }
}
```

### Testing tRPC

```go
import "github.com/go-mizu/mizu/contract/transport/trpc"

func TestTRPC_Create(t *testing.T) {
    svc, _ := contract.Register("todo", &todo.Service{})

    mux := http.NewServeMux()
    trpc.Mount(mux, "/trpc", svc)

    body := strings.NewReader(`{"title": "Test"}`)
    req := httptest.NewRequest("POST", "/trpc/Create", body)
    req.Header.Set("Content-Type", "application/json")

    rec := httptest.NewRecorder()
    mux.ServeHTTP(rec, req)

    var resp trpc.Envelope
    json.NewDecoder(rec.Body).Decode(&resp)

    if resp.Error != nil {
        t.Fatalf("unexpected error: %s", resp.Error.Message)
    }

    if resp.Result == nil {
        t.Fatal("expected result, got nil")
    }
}
```

## Testing Helpers

### Test Server Setup

```go
func setupTestServer(t *testing.T) (*httptest.Server, func()) {
    t.Helper()

    svc, err := contract.Register("todo", &todo.Service{})
    if err != nil {
        t.Fatalf("failed to register service: %v", err)
    }

    mux := http.NewServeMux()
    contract.MountREST(mux, svc)
    contract.MountJSONRPC(mux, "/rpc", svc)
    mcp.Mount(mux, "/mcp", svc)
    trpc.Mount(mux, "/trpc", svc)

    server := httptest.NewServer(mux)

    cleanup := func() {
        server.Close()
    }

    return server, cleanup
}

func TestIntegration(t *testing.T) {
    server, cleanup := setupTestServer(t)
    defer cleanup()

    // Use server.URL for requests
    resp, err := http.Post(server.URL+"/todos", "application/json",
        strings.NewReader(`{"title":"Test"}`))
    // ...
}
```

### JSON Helpers

```go
func mustMarshal(t *testing.T, v any) []byte {
    t.Helper()
    data, err := json.Marshal(v)
    if err != nil {
        t.Fatalf("failed to marshal: %v", err)
    }
    return data
}

func mustUnmarshal[T any](t *testing.T, data []byte) T {
    t.Helper()
    var v T
    if err := json.Unmarshal(data, &v); err != nil {
        t.Fatalf("failed to unmarshal: %v", err)
    }
    return v
}
```

## Benchmarking

```go
func BenchmarkCreate(b *testing.B) {
    svc := &todo.Service{}
    ctx := context.Background()
    input := &todo.CreateInput{Title: "Benchmark"}

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        svc.Create(ctx, input)
    }
}

func BenchmarkREST_Create(b *testing.B) {
    svc, _ := contract.Register("todo", &todo.Service{})
    mux := http.NewServeMux()
    contract.MountREST(mux, svc)

    body := []byte(`{"title":"Benchmark"}`)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        req := httptest.NewRequest("POST", "/todos", bytes.NewReader(body))
        req.Header.Set("Content-Type", "application/json")
        rec := httptest.NewRecorder()
        mux.ServeHTTP(rec, req)
    }
}
```

## Testing OpenAPI

```go
func TestOpenAPI_Schema(t *testing.T) {
    svc, _ := contract.Register("todo", &todo.Service{})

    mux := http.NewServeMux()
    contract.ServeOpenAPI(mux, "/openapi.json", svc)

    req := httptest.NewRequest("GET", "/openapi.json", nil)
    rec := httptest.NewRecorder()
    mux.ServeHTTP(rec, req)

    if rec.Code != http.StatusOK {
        t.Errorf("expected 200, got %d", rec.Code)
    }

    var spec map[string]any
    json.NewDecoder(rec.Body).Decode(&spec)

    // Verify OpenAPI structure
    if spec["openapi"] != "3.1.0" {
        t.Errorf("expected OpenAPI 3.1.0")
    }

    paths, ok := spec["paths"].(map[string]any)
    if !ok || len(paths) == 0 {
        t.Error("expected paths in spec")
    }
}
```

## Best Practices

### Test Business Logic Separately

```go
// Good: Test service directly
func TestService_Create(t *testing.T) {
    svc := &Service{}
    result, err := svc.Create(ctx, input)
    // Assert on result and err
}

// Also test transports for integration
func TestREST_Create(t *testing.T) {
    // HTTP integration test
}
```

### Use Subtests

```go
func TestTodo(t *testing.T) {
    svc := &todo.Service{}

    t.Run("Create", func(t *testing.T) {
        // ...
    })

    t.Run("Get", func(t *testing.T) {
        // ...
    })

    t.Run("List", func(t *testing.T) {
        // ...
    })
}
```

### Parallel Tests

```go
func TestService(t *testing.T) {
    t.Parallel()

    tests := []struct{
        name string
        // ...
    }{
        // ...
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            t.Parallel()
            // Test code
        })
    }
}
```

## See Also

- [Service Definition](/contract/service) - Writing testable services
- [Error Handling](/contract/errors) - Testing error conditions
- [Architecture](/contract/architecture) - Understanding the layers
