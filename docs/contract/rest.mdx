---
title: "REST Transport"
description: "Learn how Contract automatically creates RESTful HTTP endpoints from your methods"
---

# REST Transport

The REST transport is the most familiar way to expose your API. It automatically creates standard HTTP endpoints from your service methods using naming conventions - no route definitions needed.

## What Is REST?

REST (Representational State Transfer) is the most common style of web API. It uses HTTP methods (verbs) to represent actions:

| HTTP Method | Action | Example |
|-------------|--------|---------|
| GET | Read data | Get a user's profile |
| POST | Create new data | Create a new user |
| PUT | Update data | Update a user's email |
| DELETE | Remove data | Delete a user |

REST APIs are what you interact with when using curl, fetch in JavaScript, or any HTTP client.

## Quick Start

Getting a REST API running takes just a few lines:

```go
import "github.com/go-mizu/mizu/contract"

// Register your service
svc, _ := contract.Register("todo", &TodoService{})

// Create HTTP server
mux := http.NewServeMux()

// Mount REST endpoints
contract.MountREST(mux, svc)

// Start server
http.ListenAndServe(":8080", mux)
```

That's it! Your service is now accessible via REST. If your service has `Create`, `List`, `Get`, `Update`, and `Delete` methods, you now have:

| Endpoint | HTTP Method | Service Method |
|----------|-------------|----------------|
| `/todos` | POST | Create |
| `/todos` | GET | List |
| `/todos/{id}` | GET | Get |
| `/todos/{id}` | PUT | Update |
| `/todos/{id}` | DELETE | Delete |

## How Method Names Become Endpoints

Contract uses method names to determine which HTTP verb to use:

### The Naming Convention

| Method Name Starts With | HTTP Verb | Path |
|-------------------------|-----------|------|
| `Create` | POST | `/resources` |
| `Get` | GET | `/resources/{id}` |
| `List` | GET | `/resources` |
| `Update` | PUT | `/resources/{id}` |
| `Delete` | DELETE | `/resources/{id}` |
| Anything else | POST | `/resources` |

### Examples

```go
// Method: Create or CreateTodo
// Endpoint: POST /todos
func (s *Service) Create(ctx context.Context, in *CreateInput) (*Todo, error)

// Method: List or ListAll
// Endpoint: GET /todos
func (s *Service) List(ctx context.Context) (*ListOutput, error)

// Method: Get or GetByID
// Endpoint: GET /todos/{id}
func (s *Service) Get(ctx context.Context, in *GetInput) (*Todo, error)

// Method: Update or UpdateStatus
// Endpoint: PUT /todos/{id}
func (s *Service) Update(ctx context.Context, in *UpdateInput) (*Todo, error)

// Method: Delete or DeleteTodo
// Endpoint: DELETE /todos/{id}
func (s *Service) Delete(ctx context.Context, in *DeleteInput) error

// Method: Archive (doesn't match any prefix)
// Endpoint: POST /todos
func (s *Service) Archive(ctx context.Context, in *ArchiveInput) error
```

### Path Pluralization

The service name is automatically pluralized for the path:

| Service Name | Path Prefix |
|--------------|-------------|
| `todo` | `/todos` |
| `user` | `/users` |
| `product` | `/products` |
| `category` | `/categorys` (naive pluralization) |

## Making Requests

### Creating a Resource (POST)

```bash
curl -X POST http://localhost:8080/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Buy groceries"}'
```

Response:
```json
{
  "id": "todo_1",
  "title": "Buy groceries",
  "completed": false
}
```

### Listing Resources (GET)

```bash
curl http://localhost:8080/todos
```

Response:
```json
{
  "items": [
    {"id": "todo_1", "title": "Buy groceries", "completed": false},
    {"id": "todo_2", "title": "Walk the dog", "completed": true}
  ],
  "count": 2
}
```

### Getting a Single Resource (GET with ID)

```bash
curl http://localhost:8080/todos/todo_1
```

Response:
```json
{
  "id": "todo_1",
  "title": "Buy groceries",
  "completed": false
}
```

### Updating a Resource (PUT)

```bash
curl -X PUT http://localhost:8080/todos/todo_1 \
  -H "Content-Type: application/json" \
  -d '{"id": "todo_1", "title": "Buy groceries", "completed": true}'
```

Response:
```json
{
  "id": "todo_1",
  "title": "Buy groceries",
  "completed": true
}
```

### Deleting a Resource (DELETE)

```bash
curl -X DELETE http://localhost:8080/todos/todo_1
```

Response: HTTP 204 No Content (empty body)

## Complete Example

Here's a full working example:

### Define Your Service

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"

    "github.com/go-mizu/mizu/contract"
)

// Service holds our business logic
type TodoService struct {
    mu     sync.RWMutex
    todos  map[string]*Todo
    nextID int
}

// Types
type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type CreateInput struct {
    Title string `json:"title"`
}

type GetInput struct {
    ID string `json:"id"`
}

type UpdateInput struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type DeleteInput struct {
    ID string `json:"id"`
}

type ListOutput struct {
    Items []*Todo `json:"items"`
    Count int     `json:"count"`
}

// Methods

func (s *TodoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    s.nextID++
    todo := &Todo{
        ID:    fmt.Sprintf("todo_%d", s.nextID),
        Title: in.Title,
    }
    s.todos[todo.ID] = todo
    return todo, nil
}

func (s *TodoService) List(ctx context.Context) (*ListOutput, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    items := make([]*Todo, 0, len(s.todos))
    for _, t := range s.todos {
        items = append(items, t)
    }
    return &ListOutput{Items: items, Count: len(items)}, nil
}

func (s *TodoService) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, contract.ErrNotFound("todo not found")
    }
    return todo, nil
}

func (s *TodoService) Update(ctx context.Context, in *UpdateInput) (*Todo, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, contract.ErrNotFound("todo not found")
    }
    todo.Title = in.Title
    todo.Completed = in.Completed
    return todo, nil
}

func (s *TodoService) Delete(ctx context.Context, in *DeleteInput) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    if _, ok := s.todos[in.ID]; !ok {
        return contract.ErrNotFound("todo not found")
    }
    delete(s.todos, in.ID)
    return nil
}

func main() {
    // Create service
    todoService := &TodoService{
        todos: make(map[string]*Todo),
    }

    // Register with Contract
    svc, err := contract.Register("todo", todoService)
    if err != nil {
        panic(err)
    }

    // Create HTTP server
    mux := http.NewServeMux()

    // Mount REST endpoints
    contract.MountREST(mux, svc)

    // Also serve OpenAPI docs
    contract.ServeOpenAPI(mux, "/openapi.json", svc)

    fmt.Println("Server running on http://localhost:8080")
    fmt.Println("REST endpoints: /todos")
    fmt.Println("OpenAPI docs: /openapi.json")
    http.ListenAndServe(":8080", mux)
}
```

### Test It

```bash
# Create a todo
curl -X POST http://localhost:8080/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Learn REST"}'

# List all todos
curl http://localhost:8080/todos

# Get one todo
curl http://localhost:8080/todos/todo_1

# Update a todo
curl -X PUT http://localhost:8080/todos/todo_1 \
  -H "Content-Type: application/json" \
  -d '{"id": "todo_1", "title": "Learn REST", "completed": true}'

# Delete a todo
curl -X DELETE http://localhost:8080/todos/todo_1
```

## Multiple Services

You can mount multiple services on the same server:

```go
todoSvc, _ := contract.Register("todo", &TodoService{})
userSvc, _ := contract.Register("user", &UserService{})
orderSvc, _ := contract.Register("order", &OrderService{})

mux := http.NewServeMux()

// Each gets its own path prefix
contract.MountREST(mux, todoSvc)   // /todos/*
contract.MountREST(mux, userSvc)   // /users/*
contract.MountREST(mux, orderSvc)  // /orders/*

http.ListenAndServe(":8080", mux)
```

## Adding OpenAPI Documentation

Serve automatically-generated API documentation:

```go
mux := http.NewServeMux()
contract.MountREST(mux, svc)
contract.ServeOpenAPI(mux, "/openapi.json", svc)
```

Now you can:
1. View the spec: `curl http://localhost:8080/openapi.json`
2. Use Swagger UI to browse your API
3. Generate client code in any language

## Error Handling

Use Contract's error types for proper HTTP status codes:

```go
func (s *Service) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    todo, ok := s.todos[in.ID]
    if !ok {
        // Returns HTTP 404 Not Found
        return nil, contract.ErrNotFound("todo not found")
    }
    return todo, nil
}

func (s *Service) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    if in.Title == "" {
        // Returns HTTP 400 Bad Request
        return nil, contract.ErrInvalidArgument("title is required")
    }
    // ...
}
```

Error codes map to HTTP status codes:

| Contract Error | HTTP Status |
|---------------|-------------|
| `ErrNotFound` | 404 Not Found |
| `ErrInvalidArgument` | 400 Bad Request |
| `ErrPermissionDenied` | 403 Forbidden |
| `ErrUnauthenticated` | 401 Unauthorized |
| `ErrInternal` | 500 Internal Server Error |
| Plain `error` | 500 Internal Server Error |

## Common Questions

### How do I get the ID from the URL path?

For Get, Update, and Delete methods, the ID is extracted from the URL path and provided in your input struct. Make sure your input type has an `ID` field:

```go
type GetInput struct {
    ID string `json:"id"`
}

func (s *Service) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    // in.ID is automatically populated from the URL: /todos/{id}
    return s.todos[in.ID], nil
}
```

### Can I customize the URL paths?

The current REST transport uses conventions. If you need custom paths, you can:
1. Use meaningful service names (`contract.Register("product", ...)` â†’ `/products`)
2. Use the JSON-RPC transport for more flexibility
3. Wrap the handler with custom routing

### Does REST support query parameters?

Currently, all input comes from the request body. Query parameter support may be added in future versions.

### How do I add authentication?

Use standard HTTP middleware:

```go
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !isValid(token) {
            http.Error(w, "unauthorized", 401)
            return
        }
        next.ServeHTTP(w, r)
    })
}

// Wrap the mux
http.ListenAndServe(":8080", authMiddleware(mux))
```

## See Also

- [JSON-RPC Transport](/contract/jsonrpc) - Alternative protocol with batching
- [OpenAPI](/contract/openapi) - API documentation from your service
- [Transports Overview](/contract/transports-overview) - Compare all transports
- [Error Handling](/contract/errors) - Proper error responses
