---
title: "Registration"
description: "Learn how to register services with Contract and understand all available options"
---

## What is Registration?

Registration is the process of telling Contract about your service. When you register a service, Contract:

1. **Inspects your interface** - Uses reflection to discover all methods
2. **Extracts type information** - Finds all input and output types
3. **Generates schemas** - Creates JSON schemas from your Go types
4. **Creates an invoker** - Builds a callable wrapper for your methods
5. **Prepares for transports** - Sets up HTTP bindings, method names, etc.

After registration, you have everything needed to expose your service via REST, JSON-RPC, MCP, or any other transport.

## Basic Registration

The simplest registration takes just your implementation:

```go
import contract "github.com/go-mizu/mizu/contract/v2"

// Define your interface
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
}

// Create your implementation
impl := &todoService{}

// Register - the generic parameter specifies which interface to use
svc := contract.Register[TodoAPI](impl)
```

The generic parameter `[TodoAPI]` tells Contract which interface to analyze. Your implementation must satisfy this interface or the code won't compile.

## The Generic Parameter

The generic parameter is crucial - it tells Contract which interface defines your API:

```go
// Correct: specifies the interface
svc := contract.Register[TodoAPI](impl)

// The implementation must satisfy the interface
// This is checked at compile time!
```

Why do we need to specify the interface explicitly? Because your implementation struct might have additional methods that aren't part of the API. Contract only exposes methods defined in the interface:

```go
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
}

type todoService struct {
    db *sql.DB
}

// Part of the API (in the interface)
func (s *todoService) Create(...) {...}
func (s *todoService) List(...) {...}

// NOT part of the API (not in the interface)
// These won't be exposed as endpoints
func (s *todoService) validateInput(...) {...}
func (s *todoService) logError(...) {...}

// Only Create and List become API endpoints
svc := contract.Register[TodoAPI](impl)
```

## Registration Options

Options let you customize how your service is registered. Pass them as additional arguments:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithName("Todo"),
    contract.WithDescription("Todo management API"),
    contract.WithDefaultResource("todos"),
)
```

### WithName

Sets the service name used in documentation and method namespacing:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithName("Todo"),  // Service name is "Todo"
)
```

If not specified, the interface name is used (e.g., "TodoAPI").

**Where it appears:**
- OpenAPI spec: `info.title`
- JSON-RPC: Method prefix (e.g., `Todo.Create`)
- MCP: Tool prefix (e.g., `Todo.create`)

### WithDescription

Adds a description to your service:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithDescription("A simple todo list API for managing tasks"),
)
```

**Where it appears:**
- OpenAPI spec: `info.description`
- MCP: Server description shown to AI

### WithDefaultResource

Groups all methods under a resource name. This is important for REST paths:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithDefaultResource("todos"),
)

// Now methods become:
// Create -> POST /todos
// List   -> GET /todos
// Get    -> GET /todos/{id}
// Delete -> DELETE /todos/{id}
```

Without a resource, methods would be at the root path, which is rarely what you want.

### WithResource

Groups specific methods under a resource:

```go
svc := contract.Register[MyAPI](impl,
    contract.WithResource("users", "CreateUser", "GetUser", "ListUsers"),
    contract.WithResource("orders", "CreateOrder", "GetOrder", "ListOrders"),
)

// Now:
// CreateUser  -> POST /users
// GetUser     -> GET /users/{id}
// ListUsers   -> GET /users
// CreateOrder -> POST /orders
// GetOrder    -> GET /orders/{id}
// ListOrders  -> GET /orders
```

This is useful when one interface manages multiple resources.

### WithMethodHTTP

Override the HTTP binding for a specific method:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithDefaultResource("todos"),
    contract.WithMethodHTTP("Create", "POST", "/v1/todos"),     // Custom path
    contract.WithMethodHTTP("Archive", "POST", "/todos/{id}/archive"), // Custom action
)
```

**Use cases:**
- API versioning (`/v1/...`, `/v2/...`)
- Custom action paths (`/{id}/archive`, `/{id}/publish`)
- Non-standard HTTP methods

### WithHTTP

Set HTTP bindings for multiple methods at once:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithHTTP(map[string]contract.HTTPBinding{
        "Create": {Method: "POST", Path: "/v1/todos"},
        "Get":    {Method: "GET", Path: "/v1/todos/{id}"},
        "List":   {Method: "GET", Path: "/v1/todos"},
        "Delete": {Method: "DELETE", Path: "/v1/todos/{id}"},
    }),
)
```

### WithDefaults

Set global defaults for the service:

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithDefaults(contract.Defaults{
        BaseURL: "https://api.example.com",
        Headers: map[string]string{
            "X-API-Version": "2024-01",
        },
    }),
)
```

These defaults appear in generated OpenAPI specs and can be used by client generators.

### WithStreaming

Mark a method as supporting streaming:

```go
svc := contract.Register[ChatAPI](impl,
    contract.WithStreaming("Chat", contract.StreamSSE),  // Server-Sent Events
)
```

**Available stream modes:**
- `StreamSSE` - Server-Sent Events (HTTP streaming)
- `StreamWS` - WebSocket
- `StreamGRPC` - gRPC streaming
- `StreamAsync` - Async message broker

## The Registered Service

After registration, you get a `*RegisteredService` that provides several methods:

### Descriptor

Get the service descriptor with all metadata:

```go
svc := contract.Register[TodoAPI](impl)

desc := svc.Descriptor()

// Access service info
fmt.Println(desc.Name)        // "TodoAPI"
fmt.Println(desc.Description) // ""

// Access resources
for _, res := range desc.Resources {
    fmt.Println("Resource:", res.Name)
    for _, m := range res.Methods {
        fmt.Printf("  %s: %s %s\n", m.Name, m.HTTP.Method, m.HTTP.Path)
    }
}

// Access types
for _, t := range desc.Types {
    fmt.Printf("Type: %s (%s)\n", t.Name, t.Kind)
}
```

### Call

Invoke a method programmatically:

```go
svc := contract.Register[TodoAPI](impl)

ctx := context.Background()
input := &CreateInput{Title: "Test"}

// Call a method by name
result, err := svc.Call(ctx, "todos", "create", input)
if err != nil {
    log.Fatal(err)
}

todo := result.(*Todo)
fmt.Println(todo.ID)
```

**Parameters:**
- `ctx` - Context for the call
- `resource` - Resource name (e.g., "todos")
- `method` - Method name (e.g., "create", lowercase)
- `input` - Input value (or nil for methods without input)

### NewInput

Create a new instance of a method's input type:

```go
svc := contract.Register[TodoAPI](impl)

// Create a new input instance
input, err := svc.NewInput("todos", "create")
if err != nil {
    log.Fatal(err)
}

// Cast and populate
createInput := input.(*CreateInput)
createInput.Title = "My Todo"

// Use it
result, _ := svc.Call(ctx, "todos", "create", createInput)
```

This is useful for transports that need to create input instances before unmarshaling JSON into them.

## How Method Names are Transformed

Contract converts Go method names to lowercase for the API:

| Go Interface Method | API Method Name |
|--------------------|-----------------|
| `Create` | `create` |
| `CreateTodo` | `createTodo` |
| `GetByID` | `getByID` |
| `ListAll` | `listAll` |

The first character is lowercased, the rest stays as-is. This follows the JSON convention of camelCase field names.

## How HTTP Bindings are Inferred

Contract automatically determines HTTP method and path based on your Go method name:

### Method Prefix to HTTP Verb

| Method Name Starts With | HTTP Method |
|------------------------|-------------|
| `Create`, `Add`, `New` | POST |
| `List`, `All`, `Search`, `Find*s` (plural) | GET |
| `Get`, `Find`, `Fetch`, `Read` | GET |
| `Update`, `Edit`, `Modify`, `Set` | PUT |
| `Delete`, `Remove` | DELETE |
| `Patch` | PATCH |
| Everything else | POST |

### Path Generation

| Method Pattern | Path Pattern |
|---------------|--------------|
| Create-like | `/{resource}` |
| List-like | `/{resource}` |
| Get-like | `/{resource}/{id}` |
| Update-like | `/{resource}/{id}` |
| Delete-like | `/{resource}/{id}` |
| Other | `/{resource}/{methodName}` |

### Examples

```go
type ProductAPI interface {
    // POST /products
    Create(ctx context.Context, in *CreateInput) (*Product, error)

    // GET /products
    List(ctx context.Context) (*ListOutput, error)

    // GET /products
    SearchProducts(ctx context.Context, in *SearchInput) (*ListOutput, error)

    // GET /products/{id}
    Get(ctx context.Context, in *GetInput) (*Product, error)

    // PUT /products/{id}
    Update(ctx context.Context, in *UpdateInput) (*Product, error)

    // DELETE /products/{id}
    Delete(ctx context.Context, in *DeleteInput) error

    // POST /products/archive
    Archive(ctx context.Context, in *ArchiveInput) error

    // POST /products/publish
    Publish(ctx context.Context, in *PublishInput) error
}
```

## Path Parameter Extraction

For methods with `{id}` in the path (Get, Update, Delete), Contract needs to know which field in your input struct contains the ID.

### Default Behavior

Contract looks for these fields in order:

1. Field with `path:"id"` tag
2. Field named `ID`
3. Field with name ending in `ID` (e.g., `TodoID`, `UserID`)

### Using Tags

Use the `path` tag to specify the path parameter:

```go
type GetInput struct {
    TodoID string `json:"todoId" path:"id"`  // Maps to {id} in path
}

type UpdateInput struct {
    ID     string `json:"id" path:"id"`      // Maps to {id} in path
    Title  string `json:"title"`
}
```

### Multiple Path Parameters

For nested resources, you can have multiple path parameters:

```go
// Path: /users/{userId}/posts/{id}
type GetPostInput struct {
    UserID string `json:"userId" path:"userId"`
    PostID string `json:"postId" path:"id"`
}
```

## Complete Registration Example

Here's a full example showing various registration options:

```go
package main

import (
    "context"
    "fmt"

    "github.com/go-mizu/mizu"
    contract "github.com/go-mizu/mizu/contract/v2"
    "github.com/go-mizu/mizu/contract/v2/transport/rest"
    "github.com/go-mizu/mizu/contract/v2/transport/jsonrpc"
)

// Types
type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type CreateInput struct {
    Title string `json:"title"`
}

type GetInput struct {
    ID string `json:"id" path:"id"`
}

type UpdateInput struct {
    ID        string `json:"id" path:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type DeleteInput struct {
    ID string `json:"id" path:"id"`
}

type ListOutput struct {
    Items []*Todo `json:"items"`
    Total int     `json:"total"`
}

// Interface
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
    Get(ctx context.Context, in *GetInput) (*Todo, error)
    Update(ctx context.Context, in *UpdateInput) (*Todo, error)
    Delete(ctx context.Context, in *DeleteInput) error
    Archive(ctx context.Context, in *GetInput) error
}

// Implementation
type todoService struct {
    // ...
}

func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    return &Todo{ID: "1", Title: in.Title}, nil
}
func (s *todoService) List(ctx context.Context) (*ListOutput, error) {
    return &ListOutput{Items: []*Todo{}, Total: 0}, nil
}
func (s *todoService) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    return &Todo{ID: in.ID, Title: "Sample"}, nil
}
func (s *todoService) Update(ctx context.Context, in *UpdateInput) (*Todo, error) {
    return &Todo{ID: in.ID, Title: in.Title, Completed: in.Completed}, nil
}
func (s *todoService) Delete(ctx context.Context, in *DeleteInput) error {
    return nil
}
func (s *todoService) Archive(ctx context.Context, in *GetInput) error {
    return nil
}

func main() {
    impl := &todoService{}

    // Register with full configuration
    svc := contract.Register[TodoAPI](impl,
        // Service metadata
        contract.WithName("Todo"),
        contract.WithDescription("A todo list management API"),

        // Resource organization
        contract.WithDefaultResource("todos"),

        // Custom HTTP binding for archive
        contract.WithMethodHTTP("Archive", "POST", "/todos/{id}/archive"),

        // Global defaults
        contract.WithDefaults(contract.Defaults{
            BaseURL: "https://api.example.com",
        }),
    )

    // Print what was registered
    desc := svc.Descriptor()
    fmt.Printf("Service: %s\n", desc.Name)
    fmt.Printf("Description: %s\n", desc.Description)
    fmt.Println("\nEndpoints:")
    for _, res := range desc.Resources {
        for _, m := range res.Methods {
            fmt.Printf("  %-7s %-25s -> %s\n", m.HTTP.Method, m.HTTP.Path, m.Name)
        }
    }

    // Create app and mount transports
    app := mizu.New()
    rest.Mount(app.Router, svc)
    jsonrpc.Mount(app.Router, "/rpc", svc)

    app.Listen(":8080")
}
```

Output:
```
Service: Todo
Description: A todo list management API

Endpoints:
  POST    /todos                    -> create
  GET     /todos                    -> list
  GET     /todos/{id}               -> get
  PUT     /todos/{id}               -> update
  DELETE  /todos/{id}               -> delete
  POST    /todos/{id}/archive       -> archive
```

## Registration Errors

Registration can fail if your interface is invalid. Common issues:

### Missing Context Parameter

```go
// Wrong: no context
type BadAPI interface {
    Create(in *Input) (*Output, error)  // Missing context
}

// Correct
type GoodAPI interface {
    Create(ctx context.Context, in *Input) (*Output, error)
}
```

### Invalid Return Type

```go
// Wrong: multiple return values
type BadAPI interface {
    Get(ctx context.Context) (*User, *Profile, error)  // Too many returns
}

// Correct: wrap in struct
type GetResult struct {
    User    *User    `json:"user"`
    Profile *Profile `json:"profile"`
}

type GoodAPI interface {
    Get(ctx context.Context) (*GetResult, error)
}
```

### Implementation Doesn't Match

```go
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
}

type badService struct{}

// Compile error: badService does not implement TodoAPI
svc := contract.Register[TodoAPI](&badService{})
```

## Best Practices

### Use Descriptive Names

```go
svc := contract.Register[TodoAPI](impl,
    contract.WithName("Todo Management"),
    contract.WithDescription("API for creating, reading, updating, and deleting todos"),
)
```

### Organize with Resources

```go
// Good: methods grouped by resource
svc := contract.Register[API](impl,
    contract.WithResource("users", "CreateUser", "GetUser", "ListUsers"),
    contract.WithResource("posts", "CreatePost", "GetPost", "ListPosts"),
)

// Or use separate interfaces for each resource
userSvc := contract.Register[UserAPI](userImpl, contract.WithDefaultResource("users"))
postSvc := contract.Register[PostAPI](postImpl, contract.WithDefaultResource("posts"))
```

### Keep Registration Close to Implementation

```go
// In user/service.go
package user

type API interface { ... }
type service struct { ... }

func NewService(db *sql.DB) API {
    return &service{db: db}
}

func Register(impl API) *contract.RegisteredService {
    return contract.Register[API](impl,
        contract.WithName("User"),
        contract.WithDefaultResource("users"),
    )
}
```

## Common Questions

### Can I register multiple services?

Yes, register each separately and mount them on the router:

```go
todoSvc := contract.Register[TodoAPI](todoImpl, contract.WithDefaultResource("todos"))
userSvc := contract.Register[UserAPI](userImpl, contract.WithDefaultResource("users"))

rest.Mount(app.Router, todoSvc)
rest.Mount(app.Router, userSvc)
```

### Can I modify registration after the fact?

No, registration is immutable. Create a new registration with different options if needed.

### How do I access the original implementation?

The registered service wraps your implementation. If you need direct access, keep a reference:

```go
impl := &todoService{}
svc := contract.Register[TodoAPI](impl)

// Use impl directly when needed
impl.someInternalMethod()
```

## What's Next?

Now that you understand registration:

- **[Type System](/contract/types)** - How types are converted to schemas
- **[Transports](/contract/transports-overview)** - Mount your service on different protocols
- **[Error Handling](/contract/errors)** - Handle errors across transports
