---
title: "Python SDK"
description: "Generate modern, type-safe Python client libraries with sync and async support from your Contract services"
---

# Python SDK Generator

The Python SDK generator (`sdkpy`) creates modern Python client libraries from your Contract services. The generated code features full type hints, dataclass models, and both synchronous and asynchronous clients powered by httpx.

## Key Features

- **Modern Python**: Python 3.8+ with full type hints
- **Sync and Async**: Both `OpenAI` (sync) and `AsyncOpenAI` (async) clients
- **httpx Powered**: Industry-standard HTTP client with automatic retries
- **Dataclass Models**: Clean, typed data structures
- **uv-Ready**: Includes `pyproject.toml` for modern Python packaging
- **SSE Streaming**: First-class Server-Sent Events support

## Prerequisites

Before generating a Python SDK, you need:

- Python 3.8 or later
- A registered Contract service

For running the generated SDK:
- `httpx` library (`pip install httpx` or `uv add httpx`)

## Quick Start

### Step 1: Define Your Service

```go
// todo/api.go
package todo

type API interface {
    Create(input CreateInput) (Todo, error)
    List() (ListOutput, error)
    Get(id string) (Todo, error)
    Delete(id string) error
}

type Todo struct {
    ID    string `json:"id"`
    Title string `json:"title"`
    Done  bool   `json:"done"`
}

type CreateInput struct {
    Title string `json:"title"`
}

type ListOutput struct {
    Items []Todo `json:"items"`
    Total int    `json:"total"`
}
```

### Step 2: Generate the SDK

```go
package main

import (
    "os"
    "path/filepath"

    "yourapp/todo"
    contract "github.com/go-mizu/mizu/contract/v2"
    sdkpy "github.com/go-mizu/mizu/contract/v2/sdk/py"
)

func main() {
    impl := todo.NewService()
    svc := contract.Register[todo.API](impl,
        contract.WithDefaultResource("todos"),
    )

    files, err := sdkpy.Generate(svc, &sdkpy.Config{
        Package: "todoclient",
        Version: "1.0.0",
    })
    if err != nil {
        panic(err)
    }

    // Write all files
    for _, f := range files {
        path := filepath.Join("sdk/python", f.Path)
        os.MkdirAll(filepath.Dir(path), 0755)
        os.WriteFile(path, []byte(f.Content), 0644)
    }
}
```

### Step 3: Install and Use

```bash
# Install the generated SDK
cd sdk/python
uv pip install -e .

# Or with pip
pip install -e .
```

```python
from todoclient import OpenAI

# Create a client
client = OpenAI(base_url="http://localhost:8080")

# Create a todo
todo = client.todos.create(title="Learn Mizu Python SDK")
print(f"Created: {todo.id}")

# List all todos
result = client.todos.list()
print(f"Total: {result.total} todos")

# Get a specific todo
todo = client.todos.get(id=todo.id)
print(f"Got: {todo.id} - {todo.title}")

# Delete
client.todos.delete(id=todo.id)
print("Deleted successfully")
```

## Generator API

### Function Signature

```go
func Generate(svc *contract.Service, cfg *Config) ([]*sdk.File, error)
```

### Configuration

```go
type Config struct {
    // Package is the Python import package name.
    // Default: sanitized lowercase service name, or "sdk".
    Package string

    // Version is the package version for pyproject.toml.
    // Default: "0.0.0".
    Version string
}
```

### Return Value

The generator returns multiple files:

| File | Description |
|------|-------------|
| `pyproject.toml` | Package configuration for pip/uv |
| `src/{package}/__init__.py` | Package exports |
| `src/{package}/_client.py` | Client classes (OpenAI, AsyncOpenAI) |
| `src/{package}/_types.py` | Type definitions (dataclasses) |
| `src/{package}/_resource.py` | Resource classes |
| `src/{package}/_streaming.py` | SSE streaming utilities |

## Generated Code Structure

```
sdk/python/
├── pyproject.toml
└── src/
    └── todoclient/
        ├── __init__.py
        ├── _client.py
        ├── _types.py
        ├── _resource.py
        └── _streaming.py
```

### pyproject.toml

```toml
[project]
name = "todoclient"
version = "1.0.0"
requires-python = ">=3.8"
dependencies = ["httpx>=0.24.0"]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

### __init__.py

```python
from ._client import OpenAI, AsyncOpenAI

__all__ = ["OpenAI", "AsyncOpenAI"]
```

## Client Configuration

### Creating a Client

```python
from todoclient import OpenAI

# Basic client
client = OpenAI(base_url="http://localhost:8080")

# With authentication
client = OpenAI(
    api_key="your-api-key",
    base_url="http://localhost:8080",
)

# With all options
client = OpenAI(
    api_key="your-api-key",
    base_url="http://localhost:8080",
    timeout=30.0,
    max_retries=3,
    default_headers={"X-Custom-Header": "value"},
)
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `api_key` | `str \| None` | `None` | Authentication token |
| `base_url` | `str \| None` | Service default | API base URL |
| `timeout` | `float \| None` | `None` (no timeout) | Request timeout in seconds |
| `max_retries` | `int` | `2` | Maximum retry attempts |
| `default_headers` | `Dict[str, str] \| None` | `None` | Headers for all requests |

### Modifying Client Options

Create a new client with modified options:

```python
# Original client
client = OpenAI(api_key="key-1", base_url="http://localhost:8080")

# New client with different API key
other_client = client.with_options(api_key="key-2")

# New client with additional headers
debug_client = client.with_options(
    default_headers={"X-Debug": "true"}
)
```

### Closing the Client

Always close the client when done:

```python
client = OpenAI(base_url="http://localhost:8080")
try:
    # Use client...
    pass
finally:
    client.close()
```

Or use a context manager pattern:

```python
from contextlib import closing

with closing(OpenAI(base_url="http://localhost:8080")) as client:
    todo = client.todos.create(title="Task")
```

## Async Client

The SDK includes a fully async client for use with `asyncio`:

```python
import asyncio
from todoclient import AsyncOpenAI

async def main():
    client = AsyncOpenAI(base_url="http://localhost:8080")

    try:
        # Create a todo
        todo = await client.todos.create(title="Async task")
        print(f"Created: {todo.id}")

        # List todos
        result = await client.todos.list()
        for t in result.items:
            print(f"- {t.title}")

    finally:
        await client.close()

asyncio.run(main())
```

### Async Context Manager

```python
async def main():
    client = AsyncOpenAI(base_url="http://localhost:8080")
    try:
        todos = await client.todos.list()
    finally:
        await client.aclose()  # or await client.close()
```

## Type System

### Type Mapping Reference

| Contract Type | Python Type |
|---------------|-------------|
| `string` | `str` |
| `bool` | `bool` |
| `int`, `int8`-`int64` | `int` |
| `uint`, `uint8`-`uint64` | `int` |
| `float32`, `float64` | `float` |
| `time.Time` | `datetime` |
| `json.RawMessage` | `object` |
| `any` | `object` |
| `[]T` | `List[T]` |
| `map[string]T` | `Dict[str, T]` |

### Dataclass Types

Contract struct types generate Python dataclasses:

```python
from dataclasses import dataclass
from typing import Optional
from datetime import datetime

@dataclass
class Todo:
    id: str
    title: str
    done: bool
    created_at: datetime
```

### Optional and Nullable Fields

| Contract Definition | Python Type |
|---------------------|-------------|
| Required field | `T` |
| `optional: true` | `Optional[T]` |
| `nullable: true` | `Optional[T]` |
| Both optional and nullable | `Optional[T]` |

Example:

```python
@dataclass
class UpdateInput:
    title: str                    # required
    done: Optional[bool] = None   # optional
```

### Enum Fields

Enum fields use literal type hints in the docstring:

```python
@dataclass
class Task:
    # status: One of "pending", "active", "completed"
    status: str
```

### List and Dict Types

```python
from typing import List, Dict

# Contract: kind: slice, elem: Todo
TodoList = List[Todo]

# Contract: kind: map, elem: string
Metadata = Dict[str, str]
```

## Resources and Methods

### Resource Pattern

Each contract resource becomes a property on the client:

```python
client.todos      # TodosResource
client.users      # UsersResource
```

### Method Signatures

Methods use Python naming conventions (snake_case):

| Contract Method | Python Signature |
|-----------------|------------------|
| `Create` | `create(**kwargs) -> Todo` |
| `List` | `list() -> ListOutput` |
| `Get` | `get(id: str) -> Todo` |
| `Delete` | `delete(id: str) -> None` |

### Calling Methods

Methods accept keyword arguments matching the input type fields:

```python
# If input type is CreateInput { title: string }
todo = client.todos.create(title="My task")

# If input type is UpdateInput { title: string, done: bool (optional) }
todo = client.todos.update(id="123", title="Updated", done=True)
```

## Streaming (SSE)

For methods with streaming support, the SDK provides iterator-based consumption:

### Sync Streaming

```python
# Stream events
for event in client.responses.stream(model="gpt-4o", input="Hello"):
    if event.type == "text_delta":
        print(event.text, end="", flush=True)
    elif event.type == "completed":
        print("\n--- Done ---")
```

### Async Streaming

```python
async for event in client.responses.stream(model="gpt-4o", input="Hello"):
    if event.type == "text_delta":
        print(event.text, end="", flush=True)
```

### Collecting All Events

```python
# Collect all events into a list
events = list(client.responses.stream(model="gpt-4o", input="Hello"))

# Or async
events = [event async for event in client.responses.stream(...)]
```

## Error Handling

### Error Types

The SDK defines three error types:

```python
class SDKError(Exception):
    """Base exception for all SDK errors."""
    pass

class APIConnectionError(SDKError):
    """Raised when unable to connect to the API."""
    pass

class APIStatusError(SDKError):
    """Raised when the API returns an error status code."""
    status_code: int
    body: Any
```

### Handling Errors

```python
from todoclient import OpenAI
from todoclient._client import APIStatusError, APIConnectionError

client = OpenAI(base_url="http://localhost:8080")

try:
    todo = client.todos.get(id="nonexistent")
except APIStatusError as e:
    if e.status_code == 404:
        print("Todo not found")
    elif e.status_code == 401:
        print("Unauthorized")
    elif e.status_code == 400:
        print(f"Bad request: {e}")
    else:
        print(f"API error {e.status_code}: {e}")
except APIConnectionError as e:
    print(f"Connection failed: {e}")
```

### Automatic Retries

The client automatically retries failed requests (except for 4xx errors):

```python
# Configure max retries
client = OpenAI(
    base_url="http://localhost:8080",
    max_retries=5,  # Retry up to 5 times
)
```

Retries are attempted for:
- Network errors
- 5xx server errors
- Timeout errors

## Advanced Usage

### Custom Headers

```python
# Default headers for all requests
client = OpenAI(
    base_url="http://localhost:8080",
    default_headers={
        "X-Request-ID": "abc-123",
        "X-API-Version": "2024-01",
    },
)
```

### Authentication Modes

The SDK supports different authentication modes based on your service configuration:

```python
# Bearer token (default)
client = OpenAI(api_key="your-token")
# Sends: Authorization: Bearer your-token

# Basic auth (if service configured with auth: basic)
client = OpenAI(api_key="base64-encoded-credentials")
# Sends: Authorization: Basic base64-encoded-credentials

# No auth (if service configured with auth: none)
client = OpenAI()
# Sends no Authorization header
```

### Timeout Configuration

```python
# Set timeout in seconds
client = OpenAI(
    base_url="http://localhost:8080",
    timeout=30.0,  # 30 second timeout
)

# No timeout (wait indefinitely)
client = OpenAI(
    base_url="http://localhost:8080",
    timeout=None,
)
```

### Using with Existing httpx Client

The generated SDK uses httpx internally. For advanced use cases, you can access the underlying client:

```python
# The SDK creates its own httpx client
client = OpenAI(base_url="http://localhost:8080")
# client._http is the httpx.Client instance
```

## Complete Example

### Server

```go
// main.go
package main

import (
    "github.com/go-mizu/mizu"
    contract "github.com/go-mizu/mizu/contract/v2"
    "github.com/go-mizu/mizu/contract/v2/transport/rest"

    "yourapp/todo"
)

func main() {
    impl := todo.NewService()
    svc := contract.Register[todo.API](impl,
        contract.WithDefaultResource("todos"),
        contract.WithDefaults(&contract.Defaults{
            BaseURL: "http://localhost:8080",
        }),
    )

    app := mizu.New()
    rest.Mount(app.Router, svc)
    app.Listen(":8080")
}
```

### Client Usage

```python
#!/usr/bin/env python3
"""Example usage of the generated Todo client."""

from todoclient import OpenAI

def main():
    # Create client
    client = OpenAI(base_url="http://localhost:8080")

    try:
        # Create a todo
        todo = client.todos.create(title="Buy groceries")
        print(f"Created: {todo.id}")

        # List all todos
        result = client.todos.list()
        print(f"\nAll todos ({result.total} total):")
        for t in result.items:
            status = "x" if t.done else " "
            print(f"  [{status}] {t.id}: {t.title}")

        # Get a specific todo
        fetched = client.todos.get(id=todo.id)
        print(f"\nFetched: {fetched.title}")

        # Delete the todo
        client.todos.delete(id=todo.id)
        print(f"\nDeleted: {todo.id}")

    finally:
        client.close()

if __name__ == "__main__":
    main()
```

### Async Example

```python
#!/usr/bin/env python3
"""Async example usage of the generated Todo client."""

import asyncio
from todoclient import AsyncOpenAI

async def main():
    client = AsyncOpenAI(base_url="http://localhost:8080")

    try:
        # Create multiple todos concurrently
        tasks = [
            client.todos.create(title="Task 1"),
            client.todos.create(title="Task 2"),
            client.todos.create(title="Task 3"),
        ]
        todos = await asyncio.gather(*tasks)

        for todo in todos:
            print(f"Created: {todo.id} - {todo.title}")

        # List all
        result = await client.todos.list()
        print(f"\nTotal: {result.total} todos")

    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(main())
```

## Installation and Distribution

### Installing Locally

```bash
# Using uv (recommended)
cd sdk/python
uv pip install -e .

# Using pip
cd sdk/python
pip install -e .
```

### Publishing to PyPI

```bash
cd sdk/python

# Build the package
uv build
# or: python -m build

# Upload to PyPI
uv publish
# or: twine upload dist/*
```

### Installing from Git

```bash
pip install git+https://github.com/yourorg/yourrepo.git#subdirectory=sdk/python
```

## See Also

- [SDK Overview](/contract/sdk-overview) - Introduction to SDK generation
- [Go SDK](/contract/sdk-go) - Generate Go clients
- [TypeScript SDK](/contract/sdk-typescript) - Generate TypeScript clients
- [Types](/contract/types) - Contract type system
- [REST Transport](/contract/rest) - Serve your API over REST
