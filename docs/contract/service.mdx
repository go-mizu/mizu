---
title: "Defining Services"
description: "How to write plain Go services with canonical method signatures"
---

# Defining Services

A contract service is a plain Go struct with methods. No framework imports, no HTTP dependencies - just pure business logic that's easy to write and test.

## Service Requirements

1. **Must be a struct** (or pointer to struct)
2. **Must have exported methods** (unexported methods are ignored)
3. **Methods must follow canonical signatures** (see below)

## Canonical Method Signatures

The contract package supports these method signatures:

### Full Signature (Input + Output)

```go
func (s *S) Method(ctx context.Context, in *Input) (*Output, error)
```

Use for methods that receive data and return results:

```go
func (s *Service) Create(ctx context.Context, in *CreateIn) (*Todo, error) {
    todo := &Todo{
        ID:    generateID(),
        Title: in.Title,
    }
    return todo, nil
}
```

### Output Only (No Input)

```go
func (s *S) Method(ctx context.Context) (*Output, error)
```

Use for methods that return data without input:

```go
func (s *Service) List(ctx context.Context) (*TodoList, error) {
    return &TodoList{Items: s.todos}, nil
}
```

### Input Only (No Output)

```go
func (s *S) Method(ctx context.Context, in *Input) error
```

Use for methods that receive data but return nothing:

```go
func (s *Service) Delete(ctx context.Context, in *DeleteIn) error {
    delete(s.todos, in.ID)
    return nil
}
```

### Error Only (No Input or Output)

```go
func (s *S) Method(ctx context.Context) error
```

Use for health checks or side-effect operations:

```go
func (s *Service) Health(ctx context.Context) error {
    if s.db.Ping() != nil {
        return errors.New("database unavailable")
    }
    return nil
}
```

## Input/Output Types

### Input Types

Input types must be:
- Pointer to a struct (`*MyInput`)
- Have exported fields
- Use `json` tags for field names

```go
type CreateIn struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    Priority    int    `json:"priority"`
}
```

### Output Types

Output types should be:
- Pointer to a struct (`*MyOutput`)
- Have exported fields
- Use `json` tags for serialization

```go
type Todo struct {
    ID          string    `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    CreatedAt   time.Time `json:"createdAt"`
}
```

## Complete Service Example

```go
package todo

import (
    "context"
    "errors"
    "sync"
    "time"
)

// Service is the todo business logic.
type Service struct {
    mu    sync.RWMutex
    todos map[string]*Todo
    seq   int
}

// Domain types
type Todo struct {
    ID          string    `json:"id"`
    Title       string    `json:"title"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"createdAt"`
}

type TodoList struct {
    Items []*Todo `json:"items"`
    Total int     `json:"total"`
}

// Input types
type CreateIn struct {
    Title string `json:"title"`
}

type GetIn struct {
    ID string `json:"id"`
}

type UpdateIn struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type DeleteIn struct {
    ID string `json:"id"`
}

// Errors
var (
    ErrNotFound   = errors.New("todo not found")
    ErrTitleEmpty = errors.New("title cannot be empty")
)

// Create adds a new todo.
func (s *Service) Create(ctx context.Context, in *CreateIn) (*Todo, error) {
    if in.Title == "" {
        return nil, ErrTitleEmpty
    }

    s.mu.Lock()
    defer s.mu.Unlock()

    if s.todos == nil {
        s.todos = make(map[string]*Todo)
    }

    s.seq++
    todo := &Todo{
        ID:        fmt.Sprintf("todo_%d", s.seq),
        Title:     in.Title,
        CreatedAt: time.Now(),
    }
    s.todos[todo.ID] = todo

    return todo, nil
}

// Get retrieves a todo by ID.
func (s *Service) Get(ctx context.Context, in *GetIn) (*Todo, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, ErrNotFound
    }
    return todo, nil
}

// List returns all todos.
func (s *Service) List(ctx context.Context) (*TodoList, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    items := make([]*Todo, 0, len(s.todos))
    for _, t := range s.todos {
        items = append(items, t)
    }

    return &TodoList{
        Items: items,
        Total: len(items),
    }, nil
}

// Update modifies an existing todo.
func (s *Service) Update(ctx context.Context, in *UpdateIn) (*Todo, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, ErrNotFound
    }

    if in.Title != "" {
        todo.Title = in.Title
    }
    todo.Completed = in.Completed

    return todo, nil
}

// Delete removes a todo.
func (s *Service) Delete(ctx context.Context, in *DeleteIn) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    if _, ok := s.todos[in.ID]; !ok {
        return ErrNotFound
    }

    delete(s.todos, in.ID)
    return nil
}

// Health checks service health.
func (s *Service) Health(ctx context.Context) error {
    return nil
}
```

## Testing Services

Because services have no HTTP dependencies, testing is straightforward:

```go
package todo_test

import (
    "context"
    "testing"
    "yourmodule/service/todo"
)

func TestCreate(t *testing.T) {
    svc := &todo.Service{}
    ctx := context.Background()

    result, err := svc.Create(ctx, &todo.CreateIn{Title: "Test"})
    if err != nil {
        t.Fatal(err)
    }

    if result.Title != "Test" {
        t.Errorf("expected title 'Test', got %q", result.Title)
    }
}

func TestCreate_EmptyTitle(t *testing.T) {
    svc := &todo.Service{}
    ctx := context.Background()

    _, err := svc.Create(ctx, &todo.CreateIn{Title: ""})
    if err != todo.ErrTitleEmpty {
        t.Errorf("expected ErrTitleEmpty, got %v", err)
    }
}
```

## Best Practices

### Keep Services Pure

- No HTTP imports in service packages
- No framework dependencies
- Only standard library + your domain

### Use Context

- Always accept `context.Context` as first argument
- Honor context cancellation in long operations
- Use context for request-scoped values

### Define Clear Boundaries

```
service/
├── todo/
│   ├── todo.go      # Service and methods
│   ├── types.go     # Input/output types (optional)
│   └── errors.go    # Service errors (optional)
└── user/
    ├── user.go
    └── types.go
```

### Handle Errors Gracefully

Return typed errors for expected conditions:

```go
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
    ErrInvalidInput = errors.New("invalid input")
)
```

## See Also

- [Registration](/contract/register) - Register services to create contracts
- [Type System](/contract/types) - How types are converted to schemas
- [Contract Template](/cli/template-contract) - Complete project example
