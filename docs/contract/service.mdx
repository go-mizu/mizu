---
title: "Services"
description: "Learn how to design interfaces and implementations for Contract - the foundation of your API"
---

## The Interface-First Approach

In Contract, a **service** is defined by two parts:

1. **An interface** - Declares what operations your API supports
2. **An implementation** - Contains the actual business logic

This separation is intentional and powerful. The interface is your API contract - it's the source of truth for what your service can do. The implementation is a detail that clients don't need to know about.

```go
// The interface (the contract)
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
}

// The implementation (the details)
type todoService struct {
    db *sql.DB
}

func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    // actual code here
}
```

## Why Interface-First?

### Compile-Time Safety

If your implementation doesn't match the interface, you'll know immediately:

```go
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
}

type todoService struct{}

// This won't compile - todoService doesn't implement TodoAPI!
// You'll see: "missing method Create"
var _ TodoAPI = (*todoService)(nil)
```

The compiler catches mismatches before your code even runs.

### Clear Contracts

The interface IS your API documentation. Anyone can read it and understand exactly what your service does:

```go
// This interface tells you everything about the API
type UserAPI interface {
    // Create a new user account
    Create(ctx context.Context, in *CreateUserInput) (*User, error)

    // Get user by ID
    Get(ctx context.Context, in *GetUserInput) (*User, error)

    // Update user profile
    Update(ctx context.Context, in *UpdateUserInput) (*User, error)

    // Delete a user account (soft delete)
    Delete(ctx context.Context, in *DeleteUserInput) error

    // List all users with pagination
    List(ctx context.Context, in *ListUsersInput) (*ListUsersOutput, error)
}
```

### Easy Testing

You can create mock implementations for testing:

```go
// Production implementation
type userService struct {
    db *sql.DB
}

// Test mock
type mockUserService struct {
    users map[string]*User
}

func (m *mockUserService) Get(ctx context.Context, in *GetUserInput) (*User, error) {
    if user, ok := m.users[in.ID]; ok {
        return user, nil
    }
    return nil, errors.New("not found")
}

// Both implement UserAPI!
```

### Multiple Implementations

You can swap implementations without changing clients:

```go
type StorageAPI interface {
    Save(ctx context.Context, in *SaveInput) error
    Load(ctx context.Context, in *LoadInput) (*Data, error)
}

// Implementation 1: Local file system
type fileStorage struct { basePath string }

// Implementation 2: AWS S3
type s3Storage struct { bucket string; client *s3.Client }

// Implementation 3: In-memory (for tests)
type memoryStorage struct { data map[string][]byte }

// All implement StorageAPI - swap at runtime based on config
```

## Defining Your Interface

### Basic Structure

Every interface method must follow specific patterns:

```go
type MyAPI interface {
    // Every method needs ctx as first parameter
    MethodName(ctx context.Context, ...) ...
}
```

### Method Signatures

Contract supports four method patterns:

#### Pattern 1: Input and Output

The most common pattern - receive data, return data:

```go
func MethodName(ctx context.Context, in *InputType) (*OutputType, error)
```

**Example:**

```go
type OrderAPI interface {
    // Place a new order
    Create(ctx context.Context, in *CreateOrderInput) (*Order, error)

    // Get order details
    Get(ctx context.Context, in *GetOrderInput) (*Order, error)

    // Calculate shipping cost
    CalculateShipping(ctx context.Context, in *ShippingInput) (*ShippingOutput, error)
}
```

**When to use:** Most CRUD operations, calculations, any method that receives and returns data.

#### Pattern 2: Output Only (No Input)

Return data without receiving any input:

```go
func MethodName(ctx context.Context) (*OutputType, error)
```

**Example:**

```go
type DashboardAPI interface {
    // Get current stats (no input needed)
    GetStats(ctx context.Context) (*StatsOutput, error)

    // List all items (no filters)
    ListAll(ctx context.Context) (*ListOutput, error)

    // Get server health
    Health(ctx context.Context) (*HealthOutput, error)
}
```

**When to use:** List operations, getting current status, dashboard data, health checks with results.

#### Pattern 3: Input Only (No Output)

Accept input but return only success/failure:

```go
func MethodName(ctx context.Context, in *InputType) error
```

**Example:**

```go
type NotificationAPI interface {
    // Send notification (we don't need a response)
    Send(ctx context.Context, in *SendInput) error

    // Delete a notification
    Delete(ctx context.Context, in *DeleteInput) error

    // Mark all as read
    MarkAllRead(ctx context.Context, in *MarkReadInput) error
}
```

**When to use:** Delete operations, fire-and-forget updates, operations where you only care about success/failure.

#### Pattern 4: No Input or Output

Just do something and report success/failure:

```go
func MethodName(ctx context.Context) error
```

**Example:**

```go
type MaintenanceAPI interface {
    // Ping the service
    Ping(ctx context.Context) error

    // Run cleanup (no params, no response)
    Cleanup(ctx context.Context) error

    // Check database connection
    CheckDB(ctx context.Context) error
}
```

**When to use:** Health checks, ping endpoints, administrative operations.

## Defining Input and Output Types

### Input Types

Input types describe what clients send to your methods:

```go
type CreateUserInput struct {
    // Required fields
    Email    string `json:"email"`
    Password string `json:"password"`
    Name     string `json:"name"`

    // Optional fields (will be zero value if not sent)
    Phone    string `json:"phone,omitempty"`
    Avatar   string `json:"avatar,omitempty"`
}
```

**Key points:**
- Use pointer types in method signatures: `*CreateUserInput`
- Use `json` tags for field names in JSON
- Add `omitempty` for optional fields

### Output Types

Output types describe what you return:

```go
type User struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    CreatedAt time.Time `json:"createdAt"`
    UpdatedAt time.Time `json:"updatedAt"`
}

type ListUsersOutput struct {
    Users []*User `json:"users"`
    Total int     `json:"total"`
    Page  int     `json:"page"`
}
```

### Shared Types

You can use the same type for both input and output:

```go
type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type TodoAPI interface {
    // Uses Todo for both input and output
    Create(ctx context.Context, in *Todo) (*Todo, error)
    Update(ctx context.Context, in *Todo) (*Todo, error)
}
```

However, it's often better to have separate types for clarity:

```go
type CreateTodoInput struct {
    Title string `json:"title"` // Only title needed for creation
}

type UpdateTodoInput struct {
    ID        string `json:"id"`        // Need ID to know which todo
    Title     string `json:"title"`     // Can update title
    Completed bool   `json:"completed"` // Can update status
}

type Todo struct {
    ID        string    `json:"id"`
    Title     string    `json:"title"`
    Completed bool      `json:"completed"`
    CreatedAt time.Time `json:"createdAt"` // Server-generated
    UpdatedAt time.Time `json:"updatedAt"` // Server-generated
}
```

### Nested Types

You can nest types for complex data:

```go
type Order struct {
    ID       string     `json:"id"`
    Customer *Customer  `json:"customer"`
    Items    []*Item    `json:"items"`
    Shipping *Address   `json:"shipping"`
    Billing  *Address   `json:"billing"`
}

type Customer struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type Item struct {
    ProductID string  `json:"productId"`
    Quantity  int     `json:"quantity"`
    Price     float64 `json:"price"`
}

type Address struct {
    Street  string `json:"street"`
    City    string `json:"city"`
    Country string `json:"country"`
    Zip     string `json:"zip"`
}
```

## Implementing Your Interface

### Basic Implementation

Create a struct that implements all interface methods:

```go
// The interface
type TodoAPI interface {
    Create(ctx context.Context, in *CreateInput) (*Todo, error)
    List(ctx context.Context) (*ListOutput, error)
    Get(ctx context.Context, in *GetInput) (*Todo, error)
    Delete(ctx context.Context, in *DeleteInput) error
}

// The implementation struct
type todoService struct {
    db *sql.DB  // Dependencies go here
}

// Constructor function
func NewTodoService(db *sql.DB) TodoAPI {
    return &todoService{db: db}
}

// Implement each method
func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    // Implementation
}

func (s *todoService) List(ctx context.Context) (*ListOutput, error) {
    // Implementation
}

func (s *todoService) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    // Implementation
}

func (s *todoService) Delete(ctx context.Context, in *DeleteInput) error {
    // Implementation
}
```

### With Dependencies

Inject dependencies through the constructor:

```go
type userService struct {
    db     *sql.DB           // Database
    cache  *redis.Client     // Cache
    mailer *email.Client     // Email service
    logger *slog.Logger      // Logging
}

func NewUserService(
    db *sql.DB,
    cache *redis.Client,
    mailer *email.Client,
    logger *slog.Logger,
) UserAPI {
    return &userService{
        db:     db,
        cache:  cache,
        mailer: mailer,
        logger: logger,
    }
}

func (s *userService) Create(ctx context.Context, in *CreateUserInput) (*User, error) {
    // Use s.db to save to database
    // Use s.cache to cache the result
    // Use s.mailer to send welcome email
    // Use s.logger to log the operation
}
```

### Compile-Time Interface Check

Add a compile-time check to ensure your implementation is complete:

```go
// This line ensures todoService implements TodoAPI
// If it doesn't, you'll get a compile error
var _ TodoAPI = (*todoService)(nil)
```

Put this after your struct definition:

```go
type todoService struct {
    db *sql.DB
}

// Compile-time check
var _ TodoAPI = (*todoService)(nil)

func (s *todoService) Create(...) { ... }
// ...
```

## Method Naming Conventions

Method names affect how they're exposed via REST:

| Method Name Pattern | REST Endpoint | HTTP Method |
|---------------------|--------------|-------------|
| `Create`, `Add`, `New` | `/{resource}` | POST |
| `List`, `All`, `Search` | `/{resource}` | GET |
| `Get`, `Find`, `Fetch` | `/{resource}/{id}` | GET |
| `Update`, `Edit`, `Set` | `/{resource}/{id}` | PUT |
| `Delete`, `Remove` | `/{resource}/{id}` | DELETE |
| `Patch` | `/{resource}/{id}` | PATCH |
| Other names | `/{resource}/{action}` | POST |

**Examples:**

```go
type ProductAPI interface {
    CreateProduct(...)   // POST /products
    ListProducts(...)    // GET /products
    GetProduct(...)      // GET /products/{id}
    UpdateProduct(...)   // PUT /products/{id}
    DeleteProduct(...)   // DELETE /products/{id}
    SearchProducts(...)  // GET /products (with query params)
    ArchiveProduct(...)  // POST /products/archive_product
}
```

## Using Context

Every method receives `context.Context` as its first parameter. Use it for:

### Cancellation

Check if the client cancelled the request:

```go
func (s *todoService) SlowOperation(ctx context.Context, in *Input) (*Output, error) {
    for i := 0; i < 1000; i++ {
        // Check if context was cancelled
        if ctx.Err() != nil {
            return nil, ctx.Err()
        }
        // Do some work
    }
    return &Output{}, nil
}
```

### Timeouts

Pass context to database calls:

```go
func (s *todoService) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    // Context timeout is respected by the database driver
    row := s.db.QueryRowContext(ctx, "SELECT * FROM todos WHERE id = $1", in.ID)
    // ...
}
```

### Request-Scoped Values

Access values set by middleware:

```go
func (s *todoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    // Get authenticated user from context (set by auth middleware)
    userID, ok := ctx.Value("userID").(string)
    if !ok {
        return nil, errors.New("not authenticated")
    }

    // Use userID in your logic
    todo := &Todo{
        ID:      generateID(),
        Title:   in.Title,
        OwnerID: userID,  // Associate with the user
    }
    // ...
}
```

## Complete Example

Here's a complete, production-ready service:

```go
package user

import (
    "context"
    "database/sql"
    "errors"
    "time"

    "github.com/google/uuid"
)

// ─────────────────────────────────────────────────────────────
// Types
// ─────────────────────────────────────────────────────────────

type User struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    CreatedAt time.Time `json:"createdAt"`
    UpdatedAt time.Time `json:"updatedAt"`
}

type CreateUserInput struct {
    Email string `json:"email"`
    Name  string `json:"name"`
}

type GetUserInput struct {
    ID string `json:"id"`
}

type UpdateUserInput struct {
    ID   string `json:"id"`
    Name string `json:"name"`
}

type DeleteUserInput struct {
    ID string `json:"id"`
}

type ListUsersInput struct {
    Limit  int `json:"limit"`
    Offset int `json:"offset"`
}

type ListUsersOutput struct {
    Users []*User `json:"users"`
    Total int     `json:"total"`
}

// ─────────────────────────────────────────────────────────────
// Interface
// ─────────────────────────────────────────────────────────────

type UserAPI interface {
    Create(ctx context.Context, in *CreateUserInput) (*User, error)
    Get(ctx context.Context, in *GetUserInput) (*User, error)
    Update(ctx context.Context, in *UpdateUserInput) (*User, error)
    Delete(ctx context.Context, in *DeleteUserInput) error
    List(ctx context.Context, in *ListUsersInput) (*ListUsersOutput, error)
}

// ─────────────────────────────────────────────────────────────
// Implementation
// ─────────────────────────────────────────────────────────────

type userService struct {
    db *sql.DB
}

// Compile-time check
var _ UserAPI = (*userService)(nil)

func NewUserService(db *sql.DB) UserAPI {
    return &userService{db: db}
}

func (s *userService) Create(ctx context.Context, in *CreateUserInput) (*User, error) {
    if in.Email == "" {
        return nil, errors.New("email is required")
    }
    if in.Name == "" {
        return nil, errors.New("name is required")
    }

    now := time.Now()
    user := &User{
        ID:        uuid.New().String(),
        Email:     in.Email,
        Name:      in.Name,
        CreatedAt: now,
        UpdatedAt: now,
    }

    _, err := s.db.ExecContext(ctx,
        "INSERT INTO users (id, email, name, created_at, updated_at) VALUES ($1, $2, $3, $4, $5)",
        user.ID, user.Email, user.Name, user.CreatedAt, user.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }

    return user, nil
}

func (s *userService) Get(ctx context.Context, in *GetUserInput) (*User, error) {
    user := &User{}
    err := s.db.QueryRowContext(ctx,
        "SELECT id, email, name, created_at, updated_at FROM users WHERE id = $1",
        in.ID,
    ).Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt, &user.UpdatedAt)

    if err == sql.ErrNoRows {
        return nil, errors.New("user not found")
    }
    if err != nil {
        return nil, err
    }

    return user, nil
}

func (s *userService) Update(ctx context.Context, in *UpdateUserInput) (*User, error) {
    now := time.Now()

    result, err := s.db.ExecContext(ctx,
        "UPDATE users SET name = $1, updated_at = $2 WHERE id = $3",
        in.Name, now, in.ID,
    )
    if err != nil {
        return nil, err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return nil, errors.New("user not found")
    }

    return s.Get(ctx, &GetUserInput{ID: in.ID})
}

func (s *userService) Delete(ctx context.Context, in *DeleteUserInput) error {
    result, err := s.db.ExecContext(ctx, "DELETE FROM users WHERE id = $1", in.ID)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return errors.New("user not found")
    }

    return nil
}

func (s *userService) List(ctx context.Context, in *ListUsersInput) (*ListUsersOutput, error) {
    limit := in.Limit
    if limit <= 0 {
        limit = 10
    }

    rows, err := s.db.QueryContext(ctx,
        "SELECT id, email, name, created_at, updated_at FROM users LIMIT $1 OFFSET $2",
        limit, in.Offset,
    )
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []*User
    for rows.Next() {
        user := &User{}
        if err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt, &user.UpdatedAt); err != nil {
            return nil, err
        }
        users = append(users, user)
    }

    var total int
    s.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM users").Scan(&total)

    return &ListUsersOutput{
        Users: users,
        Total: total,
    }, nil
}
```

## Best Practices

### Keep Services Focused

Each service should handle one domain:

```go
// Good: focused services
type UserAPI interface { ... }
type OrderAPI interface { ... }
type ProductAPI interface { ... }

// Bad: one giant service
type EverythingAPI interface {
    CreateUser(...)
    CreateOrder(...)
    CreateProduct(...)
    // 50 more methods...
}
```

### Use Clear Naming

Names should be descriptive and consistent:

```go
// Good: clear and consistent
type SubscriptionAPI interface {
    Create(ctx context.Context, in *CreateSubscriptionInput) (*Subscription, error)
    Get(ctx context.Context, in *GetSubscriptionInput) (*Subscription, error)
    Cancel(ctx context.Context, in *CancelSubscriptionInput) error
    Renew(ctx context.Context, in *RenewSubscriptionInput) (*Subscription, error)
}

// Bad: vague and inconsistent
type SubAPI interface {
    MakeSub(ctx context.Context, in *Input) (*Output, error)
    FetchSubscription(ctx context.Context, in *GetInput) (*Sub, error)
    DoCancel(ctx context.Context, in *CancelInput) error
}
```

### Inject Dependencies

Pass dependencies through the constructor, not globally:

```go
// Good: dependency injection
type userService struct {
    db    Database
    cache Cache
}

func NewUserService(db Database, cache Cache) UserAPI {
    return &userService{db: db, cache: cache}
}

// Bad: global dependencies
var globalDB *sql.DB

func (s *userService) Create(...) {
    globalDB.Query(...)  // Don't do this!
}
```

### Keep Business Logic in Implementation

The interface should be pure contracts, logic goes in the implementation:

```go
// Interface: just the contract
type PaymentAPI interface {
    Process(ctx context.Context, in *ProcessPaymentInput) (*Payment, error)
}

// Implementation: all the logic
func (s *paymentService) Process(ctx context.Context, in *ProcessPaymentInput) (*Payment, error) {
    // Validation
    if in.Amount <= 0 {
        return nil, errors.New("amount must be positive")
    }

    // Business logic
    fee := s.calculateFee(in.Amount)
    total := in.Amount + fee

    // External calls
    result, err := s.stripe.Charge(ctx, total)
    if err != nil {
        return nil, err
    }

    // Persistence
    payment := &Payment{ID: result.ID, Amount: in.Amount, Fee: fee}
    s.db.Save(ctx, payment)

    return payment, nil
}
```

## Common Questions

### Can I have multiple return values?

No, methods can only return `(*Output, error)` or `error`. Wrap multiple values in a struct:

```go
// Instead of: func Get() (*User, *Profile, error)
// Use:
type GetUserResult struct {
    User    *User    `json:"user"`
    Profile *Profile `json:"profile"`
}

func (s *Service) GetUser(ctx context.Context, in *GetInput) (*GetUserResult, error) {
    // ...
}
```

### Should input types be pointers?

Yes, always use pointers in the method signature:

```go
// Good
func (s *Service) Create(ctx context.Context, in *CreateInput) (*Output, error)

// Bad
func (s *Service) Create(ctx context.Context, in CreateInput) (Output, error)
```

### How do I handle optional fields?

Fields not provided by clients will have their zero value:

```go
type UpdateInput struct {
    ID    string `json:"id"`    // Required
    Title string `json:"title"` // Optional: "" if not sent
    Count int    `json:"count"` // Optional: 0 if not sent
}
```

For truly optional fields where you need to distinguish "not sent" from "sent empty", use pointers:

```go
type UpdateInput struct {
    ID    string  `json:"id"`
    Title *string `json:"title"` // nil if not sent, "" if sent as empty
}
```

## What's Next?

Now that you know how to define services:

- **[Registration](/contract/register)** - How to register your service with Contract
- **[Error Handling](/contract/errors)** - Handle errors consistently across protocols
- **[Type System](/contract/types)** - Deep dive into type conversion and schemas
- **[Testing](/contract/testing)** - Test your services effectively
