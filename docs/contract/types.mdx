---
title: "Type System"
description: "Understand how Contract converts your Go types into JSON schemas"
---

# Type System

When you register a service, Contract automatically creates JSON schemas from your Go types. These schemas describe the shape of your data and are used for API documentation, validation, and client code generation.

## What Are JSON Schemas?

A JSON schema is a standard way to describe the structure of JSON data. It's like a blueprint that says:
- What fields exist
- What type each field is (string, number, boolean, etc.)
- Which fields are required

Here's an example:

```go
// Your Go type
type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}
```

Contract automatically generates this JSON Schema:

```json
{
    "type": "object",
    "properties": {
        "id": { "type": "string" },
        "title": { "type": "string" },
        "completed": { "type": "boolean" }
    },
    "required": ["id", "title", "completed"]
}
```

## Why Schemas Matter

Schemas are used throughout Contract:

| Use Case | How Schemas Help |
|----------|-----------------|
| **OpenAPI docs** | Generate accurate API documentation |
| **MCP tools** | AI assistants know what parameters to use |
| **Client generation** | Generate typed clients in any language |
| **Validation** | Verify requests match expected format |

## How Type Conversion Works

Contract converts Go types to JSON Schema types:

### Basic Types

| Go Type | JSON Schema | Example |
|---------|-------------|---------|
| `string` | `"type": "string"` | `"hello"` |
| `int`, `int64`, `int32` | `"type": "integer"` | `42` |
| `float64`, `float32` | `"type": "number"` | `3.14` |
| `bool` | `"type": "boolean"` | `true` |
| `time.Time` | `"type": "string", "format": "date-time"` | `"2024-01-15T10:30:00Z"` |

### Structs

Structs become JSON objects with properties:

```go
type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}
```

Becomes:

```json
{
    "type": "object",
    "properties": {
        "name": { "type": "string" },
        "email": { "type": "string" },
        "age": { "type": "integer" }
    },
    "required": ["name", "email", "age"]
}
```

### Slices/Arrays

Slices become JSON arrays:

```go
type TodoList struct {
    Items []*Todo `json:"items"`
    Count int     `json:"count"`
}
```

Becomes:

```json
{
    "type": "object",
    "properties": {
        "items": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/Todo" }
        },
        "count": { "type": "integer" }
    },
    "required": ["items", "count"]
}
```

### Nested Structs

Nested structs are referenced by their schema ID:

```go
type Order struct {
    ID       string `json:"id"`
    Customer *User  `json:"customer"`
}
```

Becomes:

```json
{
    "type": "object",
    "properties": {
        "id": { "type": "string" },
        "customer": { "$ref": "#/components/schemas/User" }
    },
    "required": ["id", "customer"]
}
```

## The TypeRegistry

After registration, all schemas are stored in a `TypeRegistry`:

```go
svc, _ := contract.Register("todo", &TodoService{})

// Get all schemas
schemas := svc.Types.Schemas()

for _, schema := range schemas {
    fmt.Println("Schema ID:", schema.ID)
    fmt.Println("Schema:", schema.JSON)
    fmt.Println()
}
```

Output:
```
Schema ID: todo.CreateInput
Schema: {"type":"object","properties":{"title":{"type":"string"}},"required":["title"]}

Schema ID: todo.Todo
Schema: {"type":"object","properties":{"id":{"type":"string"},"title":{"type":"string"},"completed":{"type":"boolean"}},"required":["id","title","completed"]}
```

## Type References (TypeRef)

Each method's input and output types are represented by a `TypeRef`:

```go
type TypeRef struct {
    ID   string  // Full identifier: "todo.CreateInput"
    Name string  // Short name: "CreateInput"
}
```

Access them via methods:

```go
svc, _ := contract.Register("todo", &TodoService{})

// Get the Create method
createMethod := svc.Resolve("Create")

// Check input type
if createMethod.Input != nil {
    fmt.Println("Input ID:", createMethod.Input.ID)     // "todo.CreateInput"
    fmt.Println("Input Name:", createMethod.Input.Name) // "CreateInput"
}

// Check output type
if createMethod.Output != nil {
    fmt.Println("Output ID:", createMethod.Output.ID)   // "todo.Todo"
    fmt.Println("Output Name:", createMethod.Output.Name) // "Todo"
}
```

## Type ID Format

Type IDs follow the format `packagename.TypeName`:

```go
// In package "todo"
type CreateInput struct { ... }  // ID: "todo.CreateInput"
type Todo struct { ... }         // ID: "todo.Todo"

// In package "user"
type User struct { ... }         // ID: "user.User"
type LoginInput struct { ... }   // ID: "user.LoginInput"
```

This ensures uniqueness across services.

## Using JSON Tags

Contract uses JSON tags to determine field names:

```go
type Todo struct {
    ID        string    `json:"id"`           // Field name: "id"
    Title     string    `json:"title"`        // Field name: "title"
    CreatedAt time.Time `json:"created_at"`   // Field name: "created_at"
    UpdatedAt time.Time `json:"updatedAt"`    // Field name: "updatedAt"
}
```

Without JSON tags, Go field names are used as-is:

```go
type Todo struct {
    ID    string  // Field name: "ID" (uppercase)
    Title string  // Field name: "Title" (uppercase)
}
```

**Best practice**: Always use JSON tags for consistent, lowercase field names.

## Viewing Schemas

### Via Code

```go
svc, _ := contract.Register("todo", &TodoService{})

// Pretty print all schemas
for _, schema := range svc.Types.Schemas() {
    fmt.Printf("=== %s ===\n", schema.ID)

    jsonBytes, _ := json.MarshalIndent(schema.JSON, "", "  ")
    fmt.Println(string(jsonBytes))
    fmt.Println()
}
```

### Via OpenAPI

Schemas are included in the OpenAPI spec:

```bash
curl http://localhost:8080/openapi.json | jq '.components.schemas'
```

### Via tRPC Meta

```bash
curl http://localhost:8080/trpc.meta | jq '.schemas'
```

## Complete Example

Given this service:

```go
package todo

import (
    "context"
    "time"
)

type Service struct{}

// Input type
type CreateInput struct {
    Title       string `json:"title"`
    Description string `json:"description"`
    Priority    int    `json:"priority"`
}

// Output type
type Todo struct {
    ID          string    `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Priority    int       `json:"priority"`
    Completed   bool      `json:"completed"`
    CreatedAt   time.Time `json:"createdAt"`
}

// List output type
type ListOutput struct {
    Items []*Todo `json:"items"`
    Total int     `json:"total"`
}

func (s *Service) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    return nil, nil
}

func (s *Service) List(ctx context.Context) (*ListOutput, error) {
    return nil, nil
}
```

Registration produces these schemas:

**todo.CreateInput:**
```json
{
    "type": "object",
    "properties": {
        "title": { "type": "string" },
        "description": { "type": "string" },
        "priority": { "type": "integer" }
    },
    "required": ["title", "description", "priority"]
}
```

**todo.Todo:**
```json
{
    "type": "object",
    "properties": {
        "id": { "type": "string" },
        "title": { "type": "string" },
        "description": { "type": "string" },
        "priority": { "type": "integer" },
        "completed": { "type": "boolean" },
        "createdAt": { "type": "string", "format": "date-time" }
    },
    "required": ["id", "title", "description", "priority", "completed", "createdAt"]
}
```

**todo.ListOutput:**
```json
{
    "type": "object",
    "properties": {
        "items": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/todo.Todo" }
        },
        "total": { "type": "integer" }
    },
    "required": ["items", "total"]
}
```

## Tips for Good Types

### Use Clear Names

```go
// Good: clear, descriptive names
type CreateTodoInput struct { ... }
type UpdateUserInput struct { ... }
type OrderSummary struct { ... }

// Bad: vague or confusing names
type Input struct { ... }
type Data struct { ... }
type Resp struct { ... }
```

### Use Appropriate Go Types

```go
type Todo struct {
    // Good: appropriate types
    ID        string    `json:"id"`         // IDs are strings
    Title     string    `json:"title"`      // Text is string
    Count     int       `json:"count"`      // Counts are integers
    Price     float64   `json:"price"`      // Prices are floats
    Active    bool      `json:"active"`     // Flags are booleans
    CreatedAt time.Time `json:"createdAt"`  // Timestamps are time.Time
}
```

### Organize Related Types

```go
// Group related types together

// === Input Types ===
type CreateInput struct { ... }
type UpdateInput struct { ... }
type DeleteInput struct { ... }

// === Output Types ===
type Todo struct { ... }
type ListOutput struct { ... }

// === Shared Types ===
type Pagination struct { ... }
type Sorting struct { ... }
```

## Common Questions

### Are all fields required?

Currently, yes. All exported struct fields are marked as required in the schema. Pointer fields may become optional in future versions.

### Can I customize the schema?

Not directly. Schemas are generated automatically from Go types. If you need specific schema features, consider structuring your Go types accordingly.

### What about maps?

Maps are supported and become JSON objects with additional properties:

```go
type Config struct {
    Settings map[string]string `json:"settings"`
}
```

### What about interfaces?

Interfaces aren't supported as types since their concrete type isn't known at registration time. Use concrete struct types instead.

## See Also

- [Registration](/contract/register) - How types are discovered
- [OpenAPI](/contract/openapi) - Using schemas in API documentation
- [Client Generation](/contract/client-generation) - Generating typed clients
