---
title: "MCP Transport"
description: "Connect your API to AI assistants like Claude using the Model Context Protocol"
---

# MCP Transport

The MCP (Model Context Protocol) transport lets AI assistants like Claude use your API as tools. Instead of telling an AI "call the todo API with this JSON", the AI can directly call your methods as if they were built-in capabilities.

## What Is MCP?

MCP is a protocol developed by Anthropic that lets AI models interact with external tools and services. When you expose your service via MCP:

1. **AI can discover your tools**: Claude can ask "what can I do?" and see all your methods
2. **AI can call your tools**: Claude can execute methods with proper parameters
3. **AI understands the results**: Responses are formatted so the AI can interpret them

Think of it like giving an AI a "toolbox" - each method in your service becomes a tool the AI can use.

## Quick Start

Add MCP support in just a few lines:

```go
import "github.com/go-mizu/mizu/contract/transport/mcp"

// Register your service
svc, _ := contract.Register("todo", &TodoService{})

// Create HTTP server
mux := http.NewServeMux()

// Mount MCP endpoint
mcp.Mount(mux, "/mcp", svc)

// Start server
http.ListenAndServe(":8080", mux)
```

Your service methods are now available as AI tools!

## How Methods Become Tools

Each method in your service becomes an MCP tool:

| Service Method | MCP Tool Name |
|----------------|---------------|
| `Create` | `todo.Create` |
| `List` | `todo.List` |
| `Get` | `todo.Get` |
| `Delete` | `todo.Delete` |

The tool name combines the service name and method name: `<service>.<method>`.

## The MCP Conversation

Here's how an AI interacts with your MCP server:

### Step 1: Initialize

The AI starts by establishing a connection:

```bash
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
      "protocolVersion": "2025-06-18"
    }
  }'
```

Response:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "tools": {"listChanged": false}
    },
    "serverInfo": {
      "name": "mizu-contract",
      "version": "0.1.0"
    }
  }
}
```

### Step 2: Discover Tools

The AI asks what tools are available:

```bash
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/list"
  }'
```

Response:
```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "tools": [
      {
        "name": "todo.Create",
        "description": "Create a new todo",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {"type": "string"}
          },
          "required": ["title"]
        }
      },
      {
        "name": "todo.List",
        "description": "List all todos",
        "inputSchema": {
          "type": "object",
          "properties": {}
        }
      }
    ]
  }
}
```

The AI now knows:
- What tools exist (`todo.Create`, `todo.List`)
- What parameters each tool needs (`title` for Create)
- What types those parameters should be (string)

### Step 3: Call a Tool

The AI calls a tool to do something:

```bash
curl -X POST http://localhost:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "todo.Create",
      "arguments": {
        "title": "Buy groceries"
      }
    }
  }'
```

Success response:
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"id\":\"1\",\"title\":\"Buy groceries\"}"
      }
    ],
    "isError": false
  }
}
```

Error response (if something goes wrong):
```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "content": [
      {
        "type": "text",
        "text": "todo not found"
      }
    ],
    "isError": true
  }
}
```

## Complete Example

### Define Your Service

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"

    "github.com/go-mizu/mizu/contract"
    "github.com/go-mizu/mizu/contract/transport/mcp"
)

// TodoService is our business logic
type TodoService struct {
    mu     sync.RWMutex
    todos  map[string]*Todo
    nextID int
}

type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type CreateInput struct {
    Title string `json:"title"`
}

type GetInput struct {
    ID string `json:"id"`
}

type ListOutput struct {
    Items []*Todo `json:"items"`
}

// Create a new todo
func (s *TodoService) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    s.mu.Lock()
    defer s.mu.Unlock()

    s.nextID++
    todo := &Todo{
        ID:    fmt.Sprintf("%d", s.nextID),
        Title: in.Title,
    }
    s.todos[todo.ID] = todo
    return todo, nil
}

// List all todos
func (s *TodoService) List(ctx context.Context) (*ListOutput, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    items := make([]*Todo, 0, len(s.todos))
    for _, t := range s.todos {
        items = append(items, t)
    }
    return &ListOutput{Items: items}, nil
}

// Get a specific todo
func (s *TodoService) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    s.mu.RLock()
    defer s.mu.RUnlock()

    todo, ok := s.todos[in.ID]
    if !ok {
        return nil, contract.ErrNotFound("todo not found")
    }
    return todo, nil
}

func main() {
    todoService := &TodoService{
        todos: make(map[string]*Todo),
    }

    svc, _ := contract.Register("todo", todoService)

    mux := http.NewServeMux()

    // Mount MCP
    mcp.Mount(mux, "/mcp", svc,
        mcp.WithInstructions("Use these tools to manage a todo list."),
    )

    // Also mount REST for testing
    contract.MountREST(mux, svc)

    fmt.Println("Server running on http://localhost:8080")
    fmt.Println("MCP endpoint: /mcp")
    fmt.Println("REST endpoint: /todos")
    http.ListenAndServe(":8080", mux)
}
```

### Test with curl

```bash
# Initialize
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18"}}'

# List tools
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc":"2.0","id":2,"method":"tools/list"}'

# Create a todo
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"todo.Create","arguments":{"title":"Buy milk"}}}'

# List todos
curl -X POST http://localhost:8080/mcp \
  -d '{"jsonrpc":"2.0","id":4,"method":"tools/call","params":{"name":"todo.List","arguments":{}}}'
```

## Configuration Options

Customize the MCP server with options:

```go
mcp.Mount(mux, "/mcp", svc,
    // Custom server info shown during initialization
    mcp.WithServerInfo(mcp.ServerInfo{
        Name:    "my-todo-api",
        Title:   "My Todo API",
        Version: "1.0.0",
    }),

    // Instructions shown to the AI
    mcp.WithInstructions("Use these tools to manage todos. Be careful with delete operations."),

    // CORS settings for browser-based AI interfaces
    mcp.WithAllowedOrigins("https://claude.ai"),
)
```

### Available Options

| Option | Description |
|--------|-------------|
| `WithServerInfo` | Customize server name, title, and version |
| `WithInstructions` | Provide usage guidance to the AI |
| `WithAllowedOrigins` | Set allowed CORS origins |
| `WithResolver` | Custom method name resolution |
| `WithInvoker` | Custom method invocation (for middleware) |

## Using with Claude Desktop

Claude Desktop can connect to MCP servers. To use your API with Claude Desktop:

1. Start your server:
```bash
go run main.go
# Server running on http://localhost:8080
# MCP endpoint: /mcp
```

2. Configure Claude Desktop to connect to your MCP server (see Claude Desktop documentation for details)

3. Now you can ask Claude things like:
   - "Create a todo to buy groceries"
   - "Show me all my todos"
   - "Mark the first todo as complete"

Claude will use your MCP tools to fulfill these requests!

## Security Considerations

### Origin Validation

MCP validates the `Origin` header to prevent DNS rebinding attacks. By default, only same-origin requests are allowed.

For development or trusted origins:
```go
mcp.Mount(mux, "/mcp", svc,
    mcp.WithAllowedOrigins("https://claude.ai", "http://localhost:3000"),
)
```

### Authentication

Add authentication with middleware:

```go
func authMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if !isValidToken(token) {
            http.Error(w, "unauthorized", http.StatusUnauthorized)
            return
        }
        next.ServeHTTP(w, r)
    })
}

// Create the handler and wrap it
handler := mcp.NewHandler(svc)
mux.Handle("/mcp", authMiddleware(handler))
```

### Input Validation

Always validate inputs in your service methods - don't trust AI-provided data:

```go
func (s *Service) Create(ctx context.Context, in *CreateInput) (*Todo, error) {
    // Validate input
    if in.Title == "" {
        return nil, contract.ErrInvalidArgument("title is required")
    }
    if len(in.Title) > 500 {
        return nil, contract.ErrInvalidArgument("title too long")
    }

    // Proceed with validated input
    // ...
}
```

## Error Handling

MCP has a specific way of reporting errors:

### Method Errors (Your Code)

When your method returns an error, MCP wraps it with `isError: true`:

```go
func (s *Service) Get(ctx context.Context, in *GetInput) (*Todo, error) {
    return nil, contract.ErrNotFound("todo not found")
}
```

Response:
```json
{
  "result": {
    "content": [{"type": "text", "text": "todo not found"}],
    "isError": true
  }
}
```

### Protocol Errors (JSON-RPC)

Invalid requests return JSON-RPC errors:

```json
{
  "error": {
    "code": -32601,
    "message": "Method not found"
  }
}
```

| Error Code | Meaning |
|------------|---------|
| -32700 | Parse error (invalid JSON) |
| -32600 | Invalid request format |
| -32601 | Method/tool not found |
| -32602 | Invalid parameters |
| -32603 | Internal error |

## Common Questions

### How does the AI know what parameters to use?

The `tools/list` response includes `inputSchema` for each tool. This JSON Schema tells the AI exactly what parameters are expected, their types, and which are required.

### Can I add descriptions to my tools?

Tool descriptions come from your method's doc comments (in future versions) or can be customized via method metadata. Currently, the description shows the method's full name.

### What if I have multiple services?

Each service needs its own MCP endpoint:

```go
todoSvc, _ := contract.Register("todo", &TodoService{})
userSvc, _ := contract.Register("user", &UserService{})

mux := http.NewServeMux()
mcp.Mount(mux, "/mcp/todo", todoSvc)
mcp.Mount(mux, "/mcp/user", userSvc)
```

### Can I use MCP and REST together?

Yes! Mount both transports:

```go
mux := http.NewServeMux()
mcp.Mount(mux, "/mcp", svc)           // For AI assistants
contract.MountREST(mux, svc)          // For humans/curl
contract.ServeOpenAPI(mux, "/openapi.json", svc)  // For docs
```

This is actually recommended - REST is great for testing and debugging while MCP serves the AI.

## See Also

- [Transports Overview](/contract/transports-overview) - Compare all transports
- [JSON-RPC Transport](/contract/jsonrpc) - Similar protocol (MCP is built on JSON-RPC)
- [Error Handling](/contract/errors) - Proper error responses
- [REST Transport](/contract/rest) - For human-facing APIs
