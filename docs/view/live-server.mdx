---
title: "Live Server"
description: "Configure the live server for WebSocket connections"
---

# Live Server

The Live server manages WebSocket connections, handles message routing, and provides hooks for authentication and lifecycle events. This guide covers all configuration options.

## Creating a Server

Create a server with `live.NewServer()`:

```go
import "github.com/go-mizu/mizu/live"

server := live.NewServer(live.Options{
    // Configuration options
})
```

## Configuration Options

### OnAuth

Called when a client attempts to connect. Returns the session ID and whether to accept the connection.

```go
live.Options{
    OnAuth: func(r *http.Request) (string, bool) {
        // Option 1: Accept with query parameter
        userID := r.URL.Query().Get("user")
        if userID == "" {
            return "", false // Reject
        }
        return userID, true

        // Option 2: Validate JWT token
        token := r.Header.Get("Authorization")
        claims, err := validateJWT(token)
        if err != nil {
            return "", false
        }
        return claims.UserID, true

        // Option 3: Use session cookie
        cookie, err := r.Cookie("session")
        if err != nil {
            return "", false
        }
        userID, err := getSessionUser(cookie.Value)
        if err != nil {
            return "", false
        }
        return userID, true
    },
}
```

If `OnAuth` is nil, all connections are accepted with an auto-generated ID.

### OnConnect

Called after a connection is authenticated and established.

```go
live.Options{
    OnConnect: func(s *live.Session) {
        log.Printf("User %s connected from %s", s.ID(), s.RemoteAddr())

        // Subscribe to default topics
        s.Subscribe("global")
        s.Subscribe("user:" + s.ID())

        // Send welcome message
        s.Send([]byte(`{"type":"welcome"}`))

        // Store session metadata
        s.Set("connected_at", time.Now())
    },
}
```

### OnDisconnect

Called when a connection closes (for any reason).

```go
live.Options{
    OnDisconnect: func(s *live.Session) {
        log.Printf("User %s disconnected", s.ID())

        // Clean up resources
        removeUserFromRoom(s.ID())

        // Notify others
        server.Publish("presence", []byte(fmt.Sprintf(
            `{"type":"leave","user":"%s"}`, s.ID(),
        )))
    },
}
```

### OnMessage

Called when a client sends a message.

```go
live.Options{
    OnMessage: func(s *live.Session, msg []byte) {
        log.Printf("Message from %s: %s", s.ID(), msg)

        // Parse message
        var data map[string]any
        if err := json.Unmarshal(msg, &data); err != nil {
            return
        }

        // Route based on type
        switch data["type"] {
        case "chat":
            handleChatMessage(s, data)
        case "typing":
            handleTypingIndicator(s, data)
        case "subscribe":
            topic := data["topic"].(string)
            s.Subscribe(topic)
        }
    },
}
```

### SendBuffer

The size of the send buffer per session. Messages are queued if the client can't keep up.

```go
live.Options{
    SendBuffer: 256,  // Default: 256
}
```

If the buffer fills up, oldest messages are dropped to prevent blocking.

### PingInterval

How often to send ping frames to keep the connection alive.

```go
live.Options{
    PingInterval: 30 * time.Second,  // Default: 30s
}
```

### PongTimeout

How long to wait for a pong response before closing the connection.

```go
live.Options{
    PongTimeout: 10 * time.Second,  // Default: 10s
}
```

### ReadLimit

Maximum message size from clients.

```go
live.Options{
    ReadLimit: 64 * 1024,  // Default: 64KB
}
```

Messages larger than this are rejected.

## Complete Example

```go
server := live.NewServer(live.Options{
    // Authentication
    OnAuth: func(r *http.Request) (string, bool) {
        token := r.URL.Query().Get("token")
        userID, err := validateToken(token)
        if err != nil {
            return "", false
        }
        return userID, true
    },

    // Connection lifecycle
    OnConnect: func(s *live.Session) {
        log.Printf("Connected: %s", s.ID())

        // Subscribe to user's topics
        s.Subscribe("user:" + s.ID())
        s.Subscribe("global")

        // Track online users
        onlineUsers.Add(s.ID())

        // Broadcast presence
        server.Publish("presence", []byte(fmt.Sprintf(
            `{"type":"join","user":"%s"}`, s.ID(),
        )))
    },

    OnDisconnect: func(s *live.Session) {
        log.Printf("Disconnected: %s", s.ID())

        onlineUsers.Remove(s.ID())

        server.Publish("presence", []byte(fmt.Sprintf(
            `{"type":"leave","user":"%s"}`, s.ID(),
        )))
    },

    // Message handling
    OnMessage: func(s *live.Session, msg []byte) {
        handleMessage(s, msg)
    },

    // Performance tuning
    SendBuffer:   512,
    PingInterval: 25 * time.Second,
    PongTimeout:  10 * time.Second,
    ReadLimit:    128 * 1024,
})
```

## Server Methods

### Handler

Returns an HTTP handler for WebSocket upgrades.

```go
app.Get("/ws", server.Handler())

// Or with standard http.ServeMux
mux.HandleFunc("/ws", server.Handler())
```

### Publish

Sends a message to all sessions subscribed to a topic.

```go
// Publish to a topic
server.Publish("chat:room1", []byte(`{"text":"Hello!"}`))

// Publish with JSON
data, _ := json.Marshal(message)
server.Publish(topic, data)
```

### PublishExcept

Publishes to all subscribers except specific session IDs.

```go
// Send to everyone in room except sender
server.PublishExcept("chat:room1", msg, senderID)

// Exclude multiple sessions
server.PublishExcept("chat:room1", msg, "user1", "user2")
```

### Session

Gets a session by ID.

```go
session := server.Session("user123")
if session != nil {
    session.Send([]byte("Direct message"))
}
```

### Sessions

Returns all active sessions.

```go
for _, session := range server.Sessions() {
    log.Printf("Active: %s", session.ID())
}
```

### SessionCount

Returns the number of active connections.

```go
log.Printf("Active connections: %d", server.SessionCount())
```

### Subscribers

Returns sessions subscribed to a topic.

```go
subscribers := server.Subscribers("chat:room1")
log.Printf("%d users in room1", len(subscribers))
```

### Close

Gracefully shuts down the server, closing all connections.

```go
// Graceful shutdown
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

if err := server.Close(ctx); err != nil {
    log.Printf("Shutdown error: %v", err)
}
```

## Mounting the Server

### With Mizu

```go
app := mizu.New()
app.Get("/ws", server.Handler())
app.Listen(":8080")
```

### With Standard Library

```go
mux := http.NewServeMux()
mux.HandleFunc("/ws", server.Handler())
http.ListenAndServe(":8080", mux)
```

### Multiple Endpoints

Create different servers for different purposes:

```go
chatServer := live.NewServer(live.Options{...})
notifyServer := live.NewServer(live.Options{...})

app.Get("/ws/chat", chatServer.Handler())
app.Get("/ws/notifications", notifyServer.Handler())
```

## Middleware Integration

### Authentication Middleware

Share authentication logic with HTTP routes:

```go
func authMiddleware(next mizu.Handler) mizu.Handler {
    return func(c *mizu.Ctx) error {
        token := c.Get("Authorization")
        user, err := validateToken(token)
        if err != nil {
            return c.Status(401).JSON(map[string]string{"error": "unauthorized"})
        }
        c.Locals("user", user)
        return next(c)
    }
}

// HTTP routes use middleware
app.Use(authMiddleware)

// WebSocket uses OnAuth
server := live.NewServer(live.Options{
    OnAuth: func(r *http.Request) (string, bool) {
        token := r.Header.Get("Authorization")
        user, err := validateToken(token)
        if err != nil {
            return "", false
        }
        return user.ID, true
    },
})
```

## Error Handling

### Connection Errors

Errors during connection are logged internally. The client receives a WebSocket close frame.

### Message Errors

Handle errors in `OnMessage`:

```go
OnMessage: func(s *live.Session, msg []byte) {
    var data Message
    if err := json.Unmarshal(msg, &data); err != nil {
        // Send error back to client
        s.Send([]byte(`{"error":"invalid message format"}`))
        return
    }

    if err := processMessage(data); err != nil {
        s.Send([]byte(fmt.Sprintf(`{"error":"%s"}`, err.Error())))
        return
    }
}
```

## Monitoring

### Connection Metrics

```go
// Track metrics
var (
    activeConnections = prometheus.NewGauge(...)
    messagesReceived  = prometheus.NewCounter(...)
    messagesSent      = prometheus.NewCounter(...)
)

server := live.NewServer(live.Options{
    OnConnect: func(s *live.Session) {
        activeConnections.Inc()
    },
    OnDisconnect: func(s *live.Session) {
        activeConnections.Dec()
    },
    OnMessage: func(s *live.Session, msg []byte) {
        messagesReceived.Inc()
        // ...
    },
})
```

### Health Check

```go
app.Get("/health", func(c *mizu.Ctx) error {
    return c.JSON(map[string]any{
        "status":      "healthy",
        "connections": server.SessionCount(),
    })
})
```

## Best Practices

### 1. Always Authenticate

Never accept unauthenticated connections in production:

```go
OnAuth: func(r *http.Request) (string, bool) {
    // Always validate credentials
    if !validateCredentials(r) {
        return "", false
    }
    return userID, true
},
```

### 2. Set Reasonable Limits

Protect against abuse:

```go
live.Options{
    SendBuffer: 256,         // Don't let buffers grow too large
    ReadLimit:  64 * 1024,   // Limit incoming message size
}
```

### 3. Handle Disconnects Gracefully

Clean up resources when clients disconnect:

```go
OnDisconnect: func(s *live.Session) {
    cleanupUserResources(s.ID())
    notifyOthers(s.ID(), "offline")
},
```

### 4. Use Structured Messages

Define a consistent message format:

```go
type Message struct {
    Type    string `json:"type"`
    Payload any    `json:"payload"`
}
```

### 5. Log Important Events

Log connections and errors for debugging:

```go
OnConnect: func(s *live.Session) {
    log.Printf("Connected: id=%s addr=%s", s.ID(), s.RemoteAddr())
},
OnDisconnect: func(s *live.Session) {
    log.Printf("Disconnected: id=%s", s.ID())
},
```
