---
title: "Server"
description: "Configure the sync engine for authoritative state management"
---

The sync engine processes mutations, maintains a change log, and serves data to clients. This guide covers all configuration options.

## Creating the Engine

```go
import (
    "github.com/go-mizu/mizu/sync"
    "github.com/go-mizu/mizu/sync/memory"
)

engine := sync.New(sync.Options{
    Log:      memory.NewLog(),   // Required: change log
    Apply:    applyMutation,     // Required: mutation handler
    Dedupe:   memory.NewDedupe(), // Optional: idempotency
    Snapshot: snapshotFunc,      // Optional: full state
    Now:      time.Now,          // Optional: time source
})
```

## Configuration Options

### Log (Required)

The Log records ordered changes for cursor-based replication:

```go
type Log interface {
    // Append adds changes and returns the final cursor
    Append(ctx context.Context, scope string, changes []Change) (uint64, error)

    // Since returns changes after cursor (up to limit)
    Since(ctx context.Context, scope string, cursor uint64, limit int) ([]Change, error)

    // Cursor returns current position
    Cursor(ctx context.Context, scope string) (uint64, error)

    // Trim removes old changes (compaction)
    Trim(ctx context.Context, scope string, before uint64) error
}
```

**In-memory implementation:**
```go
log := memory.NewLog()
```

**Custom implementation (e.g., PostgreSQL):**
```go
type PostgresLog struct {
    db *sql.DB
}

func (l *PostgresLog) Append(ctx context.Context, scope string, changes []sync.Change) (uint64, error) {
    tx, _ := l.db.BeginTx(ctx, nil)
    defer tx.Rollback()

    var cursor uint64
    for i := range changes {
        err := tx.QueryRowContext(ctx,
            `INSERT INTO change_log (scope, time, data)
             VALUES ($1, $2, $3)
             RETURNING cursor`,
            scope, changes[i].Time, changes[i].Data,
        ).Scan(&cursor)
        if err != nil {
            return 0, err
        }
        changes[i].Cursor = cursor
        changes[i].Scope = scope
    }

    return cursor, tx.Commit()
}

func (l *PostgresLog) Since(ctx context.Context, scope string, cursor uint64, limit int) ([]sync.Change, error) {
    rows, err := l.db.QueryContext(ctx,
        `SELECT cursor, scope, time, data
         FROM change_log
         WHERE scope = $1 AND cursor > $2
         ORDER BY cursor
         LIMIT $3`,
        scope, cursor, limit,
    )
    // ... parse rows
}
```

### Apply (Required)

The Apply function processes mutations and returns changes:

```go
type ApplyFunc func(ctx context.Context, m Mutation) ([]Change, error)
```

```go
sync.Options{
    Apply: func(ctx context.Context, m sync.Mutation) ([]sync.Change, error) {
        switch m.Name {
        case "todo.create":
            // Create todo in database
            // Return changes describing what happened
            return []sync.Change{
                {Data: json.RawMessage(`{"op":"create","id":"123"}`)},
            }, nil
        default:
            return nil, sync.ErrInvalidMutation
        }
    },
}
```

### Dedupe (Optional)

Tracks processed mutations for idempotency:

```go
type Dedupe interface {
    // Seen returns true if mutation was already processed
    Seen(ctx context.Context, scope, id string) (bool, error)

    // Mark records that mutation was processed
    Mark(ctx context.Context, scope, id string) error
}
```

Without Dedupe, replayed mutations will be processed multiple times.

```go
dedupe := memory.NewDedupe()
```

### Snapshot (Optional)

Returns full state for initial sync or recovery:

```go
type SnapshotFunc func(ctx context.Context, scope string) (json.RawMessage, uint64, error)
```

```go
sync.Options{
    Snapshot: func(ctx context.Context, scope string) (json.RawMessage, uint64, error) {
        // Query all data for this scope
        data, err := queryAllData(ctx, scope)
        if err != nil {
            return nil, 0, err
        }

        // Get current cursor
        cursor, err := log.Cursor(ctx, scope)
        if err != nil {
            return nil, 0, err
        }

        return data, cursor, nil
    },
}
```

### Now (Optional)

Time source for change timestamps. Useful for testing:

```go
sync.Options{
    Now: func() time.Time {
        return time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC) // Fixed time
    },
}
```

## Engine Methods

### Push

Applies mutations and returns results:

```go
results, err := engine.Push(ctx, []sync.Mutation{
    {ID: "m1", Name: "todo.create", Args: json.RawMessage(`{"title":"Buy milk"}`)},
})

// Result per mutation
for _, r := range results {
    if r.OK {
        fmt.Printf("Success, cursor: %d\n", r.Cursor)
    } else {
        fmt.Printf("Failed: %s\n", r.Error)
    }
}
```

### Pull

Returns changes since a cursor:

```go
changes, hasMore, err := engine.Pull(ctx, scope, cursor, limit)

for _, c := range changes {
    fmt.Printf("Change at cursor %d: %s\n", c.Cursor, c.Data)
}

if hasMore {
    // Continue pulling
}
```

### Snapshot

Returns full state for a scope:

```go
data, cursor, err := engine.Snapshot(ctx, scope)
// data is JSON of all entities
// cursor is current position
```

### Log

Access the underlying log:

```go
log := engine.Log()
cursor, _ := log.Cursor(ctx, scope)
```

## Types

### Mutation

Client request to change state:

```go
type Mutation struct {
    ID    string          `json:"id"`    // Unique ID for idempotency
    Scope string          `json:"scope"` // Data partition
    Name  string          `json:"name"`  // Operation type
    Args  json.RawMessage `json:"args"`  // Arguments
}
```

### Result

Outcome of applying a mutation:

```go
type Result struct {
    OK      bool     `json:"ok"`
    Cursor  uint64   `json:"cursor,omitempty"`
    Error   string   `json:"error,omitempty"`
    Changes []Change `json:"changes,omitempty"`
}
```

### Change

Record of what changed:

```go
type Change struct {
    Cursor uint64          `json:"cursor"`
    Scope  string          `json:"scope"`
    Time   time.Time       `json:"time"`
    Data   json.RawMessage `json:"data,omitempty"`
}
```

## Errors

| Error | Description |
|-------|-------------|
| `ErrNotFound` | Entity not found |
| `ErrInvalidMutation` | Mutation is malformed |
| `ErrConflict` | Concurrent modification conflict |
| `ErrCursorTooOld` | Log has been trimmed past this cursor |

```go
if errors.Is(err, sync.ErrCursorTooOld) {
    // Client needs full snapshot
    data, cursor, _ := engine.Snapshot(ctx, scope)
}
```

## HTTP Endpoints

Create handlers for your sync API:

```go
// POST /sync/push - Apply mutations
app.Post("/sync/push", func(c *mizu.Ctx) error {
    var mutations []sync.Mutation
    if err := c.BodyJSON(&mutations); err != nil {
        return c.Status(400).JSON(map[string]string{"error": "invalid"})
    }

    results, err := engine.Push(c.Context(), mutations)
    if err != nil {
        return c.Status(500).JSON(map[string]string{"error": err.Error()})
    }

    return c.JSON(results)
})

// GET /sync/pull - Get changes since cursor
app.Get("/sync/pull", func(c *mizu.Ctx) error {
    scope := c.Query("scope", sync.DefaultScope)
    cursor := uint64(c.QueryInt("cursor", 0))
    limit := c.QueryInt("limit", 100)

    changes, hasMore, err := engine.Pull(c.Context(), scope, cursor, limit)
    if err != nil {
        if errors.Is(err, sync.ErrCursorTooOld) {
            return c.Status(410).JSON(map[string]string{"error": "cursor_too_old"})
        }
        return c.Status(500).JSON(map[string]string{"error": err.Error()})
    }

    return c.JSON(map[string]any{
        "changes": changes,
        "hasMore": hasMore,
    })
})

// GET /sync/snapshot - Get full state
app.Get("/sync/snapshot", func(c *mizu.Ctx) error {
    scope := c.Query("scope", sync.DefaultScope)

    data, cursor, err := engine.Snapshot(c.Context(), scope)
    if err != nil {
        return c.Status(500).JSON(map[string]string{"error": err.Error()})
    }

    return c.JSON(map[string]any{
        "data":   json.RawMessage(data),
        "cursor": cursor,
    })
})
```

## Scopes

Scopes partition data:

```go
// Per-user data
scope := "user:" + userID

// Per-team data
scope := "team:" + teamID

// Default scope
scope := sync.DefaultScope  // "_default"
```

## Best Practices

### 1. Design Idempotent Mutations

```go
// Good: specific operation
"todo.markComplete"  // Sets completed=true

// Avoid: toggles current state
"todo.toggle"  // Result depends on current state
```

### 2. Keep Mutations Small

Each mutation should do one thing:

```go
// Good: clear intent
"todo.create"
"todo.updateTitle"
"todo.markComplete"

// Avoid: unclear what changed
"todo.update"
```

### 3. Validate Early

```go
func applyMutation(ctx context.Context, m sync.Mutation) ([]sync.Change, error) {
    // Validate before doing any work
    if m.Name == "" {
        return nil, sync.ErrInvalidMutation
    }
    // ...
}
```

### 4. Use Transactions

When using a database, wrap Apply in a transaction:

```go
Apply: func(ctx context.Context, m sync.Mutation) ([]sync.Change, error) {
    tx, _ := db.BeginTx(ctx, nil)
    defer tx.Rollback()

    // Do work in transaction
    // ...

    tx.Commit()
    return changes, nil
},
```

### 5. Trim Old Changes

Periodically trim the log to save space:

```go
// Keep last 7 days
before := time.Now().Add(-7 * 24 * time.Hour)
engine.Log().Trim(ctx, scope, cursorFromTime(before))
```
