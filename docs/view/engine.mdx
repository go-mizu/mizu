---
title: "Engine"
description: "Learn how to configure the view engine for development and production"
---

The view engine is the core of Mizu's template system. This guide covers all configuration options and how to use them effectively.

## Creating an Engine

Create a view engine with `view.New()`:

```go
import "github.com/go-mizu/mizu/view"

engine := view.New(view.Config{
    Dir:           "./views",
    Extension:     ".html",
    DefaultLayout: "layout",
    Development:   true,
})
```

## Configuration Options

### Dir

The directory where your templates are stored.

```go
view.Config{
    Dir: "./views",  // Default: "." (current directory)
}
```

The engine looks for template files directly in this directory:

```
views/
├── layout.html    # Layout template
├── home.html      # Page template
└── about.html     # Another page template
```

### FS

An `fs.FS` filesystem to load templates from. Use this with `embed.FS` in production to bundle templates into your binary.

```go
import "embed"

//go:embed views
var viewsFS embed.FS

engine := view.New(view.Config{
    FS: viewsFS,  // Use embedded filesystem
})
```

When `FS` is set, templates are loaded from the embedded filesystem instead of the local filesystem. The `Dir` field should match the path prefix in your embed directive.

### Extension

The file extension for template files.

```go
view.Config{
    Extension: ".html",  // Default: ".html"
}
```

You can use other extensions:

```go
view.Config{
    Extension: ".tmpl",  // Now looks for .tmpl files
}
```

### DefaultLayout

The layout template to use when rendering pages.

```go
view.Config{
    DefaultLayout: "layout",  // Uses layout.html
}
```

If not set, pages are rendered without a layout wrapper. You can override this per-render with `view.Layout()` or disable it with `view.NoLayout()`.

### Delims

Custom template delimiters. Useful if your templates contain `{{` and `}}` literally (common with Vue.js or Angular templates).

```go
view.Config{
    Delims: [2]string{"<%", "%>"},  // Default: ["{{", "}}"]
}
```

Now templates use `<% %>` instead:

```html
<h1>Hello, <%.Name%></h1>
```

### Development

Enables development mode features:

- **Template reload** - Templates reload on every request
- **No caching** - Templates are never cached

```go
view.Config{
    Development: true,  // Default: false
}
```

**Important:** Never enable Development mode in production. It significantly impacts performance.

A common pattern is to use an environment variable:

```go
view.Config{
    Development: os.Getenv("ENV") != "production",
}
```

### Funcs

Custom template functions to add to all templates.

```go
import "html/template"
import "strings"

view.Config{
    Funcs: template.FuncMap{
        "uppercase": strings.ToUpper,
        "formatDate": func(t time.Time) string {
            return t.Format("Jan 2, 2006")
        },
    },
}
```

Now you can use these in templates:

```html
<h1>{{uppercase .Name}}</h1>
<p>Posted on {{formatDate .CreatedAt}}</p>
```

## Built-in Functions

The view engine provides these functions by default:

| Function | Description | Example |
|----------|-------------|---------|
| `dict` | Create a map | `{{dict "key" "value"}}` |
| `list` | Create a slice | `{{list 1 2 3}}` |
| `upper` | Uppercase string | `{{upper .Name}}` |
| `lower` | Lowercase string | `{{lower .Name}}` |
| `trim` | Trim whitespace | `{{trim .Text}}` |
| `contains` | Check substring | `{{if contains .Text "hello"}}` |
| `replace` | Replace substring | `{{replace .Text "old" "new"}}` |
| `split` | Split string | `{{split .Tags ","}}` |
| `join` | Join slice | `{{join .Items ", "}}` |
| `hasPrefix` | Check prefix | `{{if hasPrefix .URL "https"}}` |
| `hasSuffix` | Check suffix | `{{if hasSuffix .File ".go"}}` |

## Complete Example

Here's a typical configuration for a production app:

```go
package main

import (
    "embed"
    "html/template"
    "os"
    "strings"
    "time"

    "github.com/go-mizu/mizu"
    "github.com/go-mizu/mizu/view"
)

//go:embed views
var viewsFS embed.FS

func main() {
    isDev := os.Getenv("ENV") != "production"

    config := view.Config{
        Extension:     ".html",
        DefaultLayout: "layout",
        Development:   isDev,
        Funcs: template.FuncMap{
            "formatDate": formatDate,
            "truncate":   truncate,
        },
    }

    if isDev {
        // Development: load from filesystem
        config.Dir = "./views"
    } else {
        // Production: load from embedded FS
        config.FS = viewsFS
    }

    engine := view.New(config)

    // Preload templates in production to fail fast
    if !isDev {
        if err := engine.Load(); err != nil {
            panic(err)
        }
    }

    app := mizu.New()
    engine.Middleware(app)

    // ... routes ...

    app.Listen(":8080")
}

func formatDate(t time.Time) string {
    return t.Format("January 2, 2006")
}

func truncate(s string, length int) string {
    if len(s) <= length {
        return s
    }
    return s[:length] + "..."
}
```

## Engine Methods

### Load

Loads and validates all templates at startup. Call this in production to fail fast if templates have errors.

```go
engine := view.New(config)

if err := engine.Load(); err != nil {
    log.Fatal("template error:", err)
}
```

### Clear

Clears the template cache. Useful if you need to reload templates without restarting.

```go
engine.Clear()
```

### Render

Renders a page template. The first argument is an `io.Writer` (like `http.ResponseWriter`), followed by the template name, data, and optional render options.

```go
err := engine.Render(w, "home", view.Data{
    "Title": "Home",
    "User":  currentUser,
})
```

### Middleware

Adds the engine to a Mizu app so it's available in all handlers via `view.From()`.

```go
app := mizu.New()
engine.Middleware(app)
```

### From

Retrieves the engine from a request context. Use this in handlers after adding the middleware.

```go
func handler(c *mizu.Ctx) error {
    engine := view.From(c)
    return engine.Render(c, "page", data)
}
```

## Render Options

When calling `Render()`, you can pass options to customize behavior.

### Layout

Override the default layout for this render:

```go
engine.Render(c, "dashboard", data, view.Layout("admin"))
```

### NoLayout

Render without any layout (useful for partial responses):

```go
engine.Render(c, "user-row", data, view.NoLayout())
```

## Using with Mizu

### Adding the Middleware

The middleware makes the engine available to all handlers:

```go
app := mizu.New()
engine.Middleware(app)
```

### Rendering in Handlers

Use `view.From()` to get the engine and render pages:

```go
func homeHandler(c *mizu.Ctx) error {
    return view.From(c).Render(c, "home", view.Data{
        "Title": "Welcome",
        "User":  currentUser,
    })
}
```

### Rendering Without Layout

For HTMX or AJAX partial responses:

```go
func partialHandler(c *mizu.Ctx) error {
    return view.From(c).Render(c, "user-row", view.Data{
        "User": user,
    }, view.NoLayout())
}
```

### Using a Different Layout

Override the default layout for specific pages:

```go
func adminHandler(c *mizu.Ctx) error {
    return view.From(c).Render(c, "dashboard", view.Data{
        "Stats": stats,
    }, view.Layout("admin"))
}
```

## Error Handling

### Template Errors

The engine returns an `Error` type that wraps template parsing and execution errors:

```go
err := engine.Render(w, "page", data)
if err != nil {
    var viewErr *view.Error
    if errors.As(err, &viewErr) {
        log.Printf("Template error: %s", viewErr.Error())
    }
}
```

## Best Practices

### 1. Use Development Mode Locally

Always enable development mode during development:

```go
Development: os.Getenv("ENV") != "production"
```

### 2. Load Templates in Production

Call `Load()` at startup to catch template errors early:

```go
if err := engine.Load(); err != nil {
    log.Fatal(err)
}
```

### 3. Embed Templates for Production

Use `embed.FS` so templates are bundled in your binary:

```go
//go:embed views
var viewsFS embed.FS
```

This eliminates the need to deploy template files alongside your binary.

### 4. Keep Custom Functions Pure

Custom functions should be pure (no side effects):

```go
// Good: pure function
"uppercase": strings.ToUpper,

// Bad: has side effects
"log": func(s string) string {
    log.Println(s)  // Side effect!
    return s
},
```

### 5. Use Consistent Data Structures

Create struct types for complex template data:

```go
type PageData struct {
    Title string
    User  *User
    Posts []Post
}

engine.Render(c, "home", PageData{
    Title: "Home",
    User:  currentUser,
    Posts: posts,
})
```

This provides type safety and documentation for what each template expects.
