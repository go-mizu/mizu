---
title: "Quick Start"
description: "Build your first sync endpoint in 10 minutes"
---

This guide walks you through creating a simple sync-enabled API endpoint. You'll learn how to set up the sync engine, handle mutations, and serve changes to clients.

## Prerequisites

- Go 1.22 or later
- Basic understanding of Go
- Familiarity with REST APIs

## Step 1: Create Your Project

```bash
mkdir sync-demo && cd sync-demo
go mod init sync-demo
go get github.com/go-mizu/mizu
```

## Step 2: Create the Sync Engine

Create `main.go`:

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    gosync "sync"

    "github.com/go-mizu/mizu"
    "github.com/go-mizu/mizu/sync"
    "github.com/go-mizu/mizu/sync/memory"
)

// Todo represents a todo item
type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

// In-memory store (replace with database in production)
var (
    todos   = make(map[string]Todo)
    todosMu gosync.RWMutex
)

func main() {
    // Create sync engine components
    changeLog := memory.NewLog()
    dedupe := memory.NewDedupe()

    // Create the sync engine with our mutation handler
    engine := sync.New(sync.Options{
        Log:    changeLog,
        Dedupe: dedupe,
        Apply:  applyMutation,
        Snapshot: func(ctx context.Context, scope string) (json.RawMessage, uint64, error) {
            todosMu.RLock()
            defer todosMu.RUnlock()

            // Return all todos as snapshot
            data, err := json.Marshal(todos)
            if err != nil {
                return nil, 0, err
            }

            cursor, _ := changeLog.Cursor(ctx, scope)
            return data, cursor, nil
        },
    })

    // Create Mizu app
    app := mizu.New()

    // Mount sync endpoints
    app.Post("/sync/push", pushHandler(engine))
    app.Get("/sync/pull", pullHandler(engine))
    app.Get("/sync/snapshot", snapshotHandler(engine))

    log.Println("Server starting on :8080")
    app.Listen(":8080")
}
```

## Step 3: Implement the Mutation Handler

Add the `applyMutation` function:

```go
// applyMutation processes mutations and returns changes
func applyMutation(ctx context.Context, m sync.Mutation) ([]sync.Change, error) {
    switch m.Name {
    case "todo.create":
        return createTodo(m.Args)
    case "todo.update":
        return updateTodo(m.Args)
    case "todo.delete":
        return deleteTodo(m.Args)
    default:
        return nil, sync.ErrInvalidMutation
    }
}

func createTodo(args json.RawMessage) ([]sync.Change, error) {
    var input struct {
        ID    string `json:"id"`
        Title string `json:"title"`
    }
    if err := json.Unmarshal(args, &input); err != nil {
        return nil, sync.ErrInvalidMutation
    }

    todo := Todo{
        ID:        input.ID,
        Title:     input.Title,
        Completed: false,
    }

    todosMu.Lock()
    todos[todo.ID] = todo
    todosMu.Unlock()

    // Return change describing what happened
    changeData, _ := json.Marshal(map[string]any{
        "op":     "create",
        "entity": "todo",
        "id":     todo.ID,
        "data":   todo,
    })

    return []sync.Change{
        {Data: changeData},
    }, nil
}

func updateTodo(args json.RawMessage) ([]sync.Change, error) {
    var input struct {
        ID        string `json:"id"`
        Title     string `json:"title,omitempty"`
        Completed *bool  `json:"completed,omitempty"`
    }
    if err := json.Unmarshal(args, &input); err != nil {
        return nil, sync.ErrInvalidMutation
    }

    todosMu.Lock()
    todo, exists := todos[input.ID]
    if !exists {
        todosMu.Unlock()
        return nil, sync.ErrNotFound
    }

    if input.Title != "" {
        todo.Title = input.Title
    }
    if input.Completed != nil {
        todo.Completed = *input.Completed
    }
    todos[input.ID] = todo
    todosMu.Unlock()

    changeData, _ := json.Marshal(map[string]any{
        "op":     "update",
        "entity": "todo",
        "id":     todo.ID,
        "data":   todo,
    })

    return []sync.Change{
        {Data: changeData},
    }, nil
}

func deleteTodo(args json.RawMessage) ([]sync.Change, error) {
    var input struct {
        ID string `json:"id"`
    }
    if err := json.Unmarshal(args, &input); err != nil {
        return nil, sync.ErrInvalidMutation
    }

    todosMu.Lock()
    _, exists := todos[input.ID]
    if !exists {
        todosMu.Unlock()
        return nil, sync.ErrNotFound
    }
    delete(todos, input.ID)
    todosMu.Unlock()

    changeData, _ := json.Marshal(map[string]any{
        "op":     "delete",
        "entity": "todo",
        "id":     input.ID,
    })

    return []sync.Change{
        {Data: changeData},
    }, nil
}
```

## Step 4: Create HTTP Handlers

Add the HTTP handlers:

```go
func pushHandler(engine *sync.Engine) mizu.Handler {
    return func(c *mizu.Ctx) error {
        var mutations []sync.Mutation
        if err := c.BodyJSON(&mutations); err != nil {
            return c.Status(400).JSON(map[string]string{"error": "invalid request"})
        }

        results, err := engine.Push(c.Context(), mutations)
        if err != nil {
            return c.Status(500).JSON(map[string]string{"error": err.Error()})
        }

        return c.JSON(results)
    }
}

func pullHandler(engine *sync.Engine) mizu.Handler {
    return func(c *mizu.Ctx) error {
        scope := c.Query("scope", sync.DefaultScope)
        cursor := uint64(c.QueryInt("cursor", 0))
        limit := c.QueryInt("limit", 100)

        changes, hasMore, err := engine.Pull(c.Context(), scope, cursor, limit)
        if err != nil {
            return c.Status(500).JSON(map[string]string{"error": err.Error()})
        }

        return c.JSON(map[string]any{
            "changes": changes,
            "hasMore": hasMore,
        })
    }
}

func snapshotHandler(engine *sync.Engine) mizu.Handler {
    return func(c *mizu.Ctx) error {
        scope := c.Query("scope", sync.DefaultScope)

        data, cursor, err := engine.Snapshot(c.Context(), scope)
        if err != nil {
            return c.Status(500).JSON(map[string]string{"error": err.Error()})
        }

        return c.JSON(map[string]any{
            "data":   json.RawMessage(data),
            "cursor": cursor,
        })
    }
}
```

## Step 5: Run and Test

Start the server:

```bash
go run main.go
```

### Create a Todo

```bash
curl -X POST http://localhost:8080/sync/push \
  -H "Content-Type: application/json" \
  -d '[{"id":"m1","name":"todo.create","args":{"id":"t1","title":"Buy milk"}}]'
```

Response:
```json
[{"ok":true,"cursor":1,"changes":[...]}]
```

### Pull Changes

```bash
curl "http://localhost:8080/sync/pull?cursor=0"
```

### Get Snapshot

```bash
curl "http://localhost:8080/sync/snapshot"
```

## Understanding the Flow

```
1. Client sends mutation
   POST /sync/push [{id, name, args}]
         │
         ▼
2. Engine checks idempotency (dedupe)
         │
         ▼
3. ApplyFunc runs your business logic
         │
         ▼
4. Changes appended to log
         │
         ▼
5. Client receives result with cursor
         │
         ▼
6. Other clients pull changes
   GET /sync/pull?cursor=N
```

## Next Steps

- **[Server](/view/sync-server)** - Engine configuration options
- **[Integration](/view/sync-integration)** - Add real-time with Live
