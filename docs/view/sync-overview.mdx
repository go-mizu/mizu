---
title: "Overview"
description: "Authoritative, offline-first state synchronization for Go applications"
---

The `sync` package provides server-side state synchronization with support for offline-first clients. It defines a durable mutation pipeline, an ordered change log, and cursor-based replication so clients can converge to correct state across retries, disconnects, offline operation, and server restarts.

## What is State Synchronization?

In traditional web apps, every action requires a server round-trip:

```
Client: "Create todo"  →  Server: Creates and confirms
Client: "Update todo"  →  Server: Updates and confirms
Client: "Get todos"    →  Server: Returns todos
```

This has problems:
- **Offline doesn't work** - No internet means no app
- **Latency feels slow** - Every action waits for the server
- **Missed updates** - How do clients know when data changed?

State synchronization solves this with a **mutation + change log** pattern:

```
Client: Sends mutations (intent to change)
Server: Applies mutations, records changes
        Returns changes since client's cursor
Clients: Pull changes to stay in sync
```

## Design Principles

| Principle | Description |
|-----------|-------------|
| Authoritative | All durable state changes are applied on the server |
| Offline-first | Clients can queue and replay mutations safely |
| Idempotent | Replayed mutations don't apply twice |
| Pull-based | Clients converge by pulling changes since a cursor |
| Scoped | All data and cursors are partitioned by scope |

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                        SERVER                                │
│  ┌──────────────────────────────────────────────────────┐   │
│  │                   Sync Engine                         │   │
│  │                                                       │   │
│  │  ┌─────────┐  ┌─────────┐  ┌──────────┐             │   │
│  │  │   Log   │  │  Apply  │  │  Dedupe  │             │   │
│  │  │(changes)│  │  Func   │  │(idempot.)│             │   │
│  │  └─────────┘  └─────────┘  └──────────┘             │   │
│  └──────────────────────────────────────────────────────┘   │
│                            │                                 │
│                     Push / Pull / Snapshot                   │
│                            │                                 │
└────────────────────────────│─────────────────────────────────┘
                             │
              ┌──────────────┴──────────────┐
              │                             │
              ▼                             ▼
┌─────────────────────────┐   ┌─────────────────────────┐
│        CLIENT A         │   │        CLIENT B         │
│                         │   │                         │
│  cursor: 42             │   │  cursor: 38             │
│  pending mutations: 2   │   │  pending mutations: 0   │
│                         │   │                         │
└─────────────────────────┘   └─────────────────────────┘
```

## Core Concepts

### Mutation

A **mutation** is a client request to change state. It's a command, not a data patch:

```go
type Mutation struct {
    ID    string          // Unique ID for idempotency
    Scope string          // Data partition
    Name  string          // Operation type (e.g., "todo.create")
    Args  json.RawMessage // Operation arguments
}
```

Example mutation:
```json
{
    "id": "abc123",
    "scope": "user:456",
    "name": "todo.create",
    "args": {"title": "Buy milk", "completed": false}
}
```

### Change

A **change** is a record of what actually happened:

```go
type Change struct {
    Cursor uint64          // Position in log
    Scope  string          // Data partition
    Time   time.Time       // When it happened
    Data   json.RawMessage // What changed (opaque)
}
```

The `Data` field is application-defined. You decide the schema.

### Cursor

A **cursor** is a position in the change log. Clients track their cursor and pull changes since that point:

```
Log:  [Change 1] [Change 2] [Change 3] [Change 4] [Change 5]
                     ^
                     │
              Client cursor = 2

Pull since cursor 2 → Returns changes 3, 4, 5
New cursor = 5
```

### Scope

A **scope** partitions data for different users or tenants:

```
scope: "user:123"    # User 123's private data
scope: "team:456"    # Team 456's shared data
scope: "_default"    # Default scope if not specified
```

Clients only sync data within their scope.

## How It Works

### Push: Apply Mutations

```go
// Client sends mutations
mutations := []sync.Mutation{
    {ID: "m1", Name: "todo.create", Args: ...},
}

// Engine processes them
results, err := engine.Push(ctx, mutations)
```

The Push flow:
1. Check idempotency (was this mutation ID already processed?)
2. If duplicate, return success without re-executing
3. Call ApplyFunc to process the mutation
4. Append resulting changes to the Log
5. Mark mutation ID as processed (for idempotency)

### Pull: Get Changes

```go
// Client pulls changes since their cursor
changes, hasMore, err := engine.Pull(ctx, scope, cursor, limit)

// Process changes and update local state
for _, change := range changes {
    // Apply change to local state
    cursor = change.Cursor
}
```

### Snapshot: Full State

When a cursor is too old (log has been trimmed), clients can get a full snapshot:

```go
data, cursor, err := engine.Snapshot(ctx, scope)
// data contains full current state
// cursor is the current position
```

## Basic Usage

```go
package main

import (
    "context"
    "encoding/json"
    "github.com/go-mizu/mizu/sync"
    "github.com/go-mizu/mizu/sync/memory"
)

func main() {
    // Create in-memory implementations
    log := memory.NewLog()
    dedupe := memory.NewDedupe()

    // Create the sync engine
    engine := sync.New(sync.Options{
        Log:    log,
        Dedupe: dedupe,
        Apply: func(ctx context.Context, m sync.Mutation) ([]sync.Change, error) {
            // Your application logic here
            switch m.Name {
            case "todo.create":
                // Create todo in your database
                // Return changes describing what happened
                return []sync.Change{
                    {Data: json.RawMessage(`{"op":"create","entity":"todo","id":"123"}`)},
                }, nil
            default:
                return nil, sync.ErrInvalidMutation
            }
        },
    })

    // Use the engine
    ctx := context.Background()

    // Push mutations
    results, _ := engine.Push(ctx, []sync.Mutation{
        {ID: "m1", Name: "todo.create", Args: json.RawMessage(`{"title":"Buy milk"}`)},
    })

    // Pull changes
    changes, hasMore, _ := engine.Pull(ctx, sync.DefaultScope, 0, 100)
}
```

## Integration with Live

Combine sync with the `live` package for real-time updates:

```go
// When changes are pushed
results, _ := engine.Push(ctx, mutations)
for _, r := range results {
    if r.OK && len(r.Changes) > 0 {
        // Notify connected clients via WebSocket
        liveServer.Publish("sync:"+scope, []byte(`{"cursor":`+strconv.FormatUint(r.Cursor, 10)+`}`))
    }
}

// Clients receive notification and pull immediately
```

Without live integration, clients can poll:
- Pull every N seconds
- Pull after reconnection
- Pull on user action

## Error Handling

The sync package defines these errors:

| Error | Description |
|-------|-------------|
| `ErrNotFound` | Entity not found |
| `ErrInvalidMutation` | Mutation is malformed |
| `ErrConflict` | Concurrent modification conflict |
| `ErrCursorTooOld` | Cursor has been trimmed from log |

```go
changes, _, err := engine.Pull(ctx, scope, cursor, limit)
if errors.Is(err, sync.ErrCursorTooOld) {
    // Client needs a full snapshot
    data, newCursor, _ := engine.Snapshot(ctx, scope)
}
```

## Use Cases

### Offline-First Mobile App

1. User creates/edits data offline
2. Mutations queue locally
3. When online, push mutations to server
4. Server applies and returns changes
5. Client pulls to reconcile

### Collaborative Application

1. User A makes change, pushes mutation
2. Server applies, records change
3. User B pulls, receives change
4. With live integration: User B notified instantly

### Event Sourcing

The change log provides an audit trail:
- Every change is recorded
- Replay from any cursor
- Time-travel debugging

## What's Next?

1. **[Quick Start](/view/sync-quick-start)** - Build your first synced endpoint
2. **[Server](/view/sync-server)** - Engine configuration and options
3. **[Integration](/view/sync-integration)** - Combine with Live for real-time
