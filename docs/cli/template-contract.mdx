---
title: "Contract Template"
description: "Transport-neutral service template with REST, JSON-RPC, and OpenAPI"
---

# Contract Template

The `contract` template creates a service using Mizu's contract pattern. It demonstrates transport-neutral business logic exposed via REST, JSON-RPC, and OpenAPI simultaneously.

## Create Project

```bash
mizu new myservice --template contract
cd myservice
go mod tidy
go run ./cmd/api
```

## Generated Structure

```
myservice/
├── .gitignore
├── README.md
├── go.mod
├── cmd/
│   └── api/
│       └── main.go           # Application entry point
├── app/
│   └── server/
│       ├── server.go         # Server with all transports
│       └── config.go         # Configuration management
└── service/
    └── todo/
        └── todo.go           # Plain Go service (no HTTP deps)
```

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                        cmd/api/main.go                          │
│                    (Entry point, signals)                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     service/todo/todo.go                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Plain Go Service                                        │   │
│  │  - No framework dependencies                             │   │
│  │  - Pure business logic                                   │   │
│  │  - Easy to test                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ contract.Register()
┌─────────────────────────────────────────────────────────────────┐
│                      app/server/server.go                       │
│  ┌───────────┐    ┌───────────┐    ┌───────────┐               │
│  │   REST    │    │ JSON-RPC  │    │  OpenAPI  │               │
│  │  /todos   │    │   /rpc    │    │/openapi.json              │
│  └───────────┘    └───────────┘    └───────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

## Generated Files

### Entry Point: `cmd/api/main.go`

Handles application lifecycle with graceful shutdown:

```go
package main

import (
    "log"
    "os"
    "os/signal"
    "syscall"

    "example.com/myservice/app/server"
    "example.com/myservice/service/todo"
)

func main() {
    cfg := server.LoadConfig()

    // Create the plain Go service (no framework dependencies).
    todoSvc := &todo.Service{}

    // Create the server with all transports.
    srv, err := server.New(cfg, todoSvc)
    if err != nil {
        log.Fatal(err)
    }

    log.Printf("listening on %s", cfg.Addr)
    log.Printf("REST:     http://localhost%s/todos", cfg.Addr)
    log.Printf("JSON-RPC: http://localhost%s/rpc", cfg.Addr)
    log.Printf("OpenAPI:  http://localhost%s/openapi.json", cfg.Addr)

    stop := make(chan os.Signal, 1)
    signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

    errc := make(chan error, 1)
    go func() { errc <- srv.ListenAndServe() }()

    select {
    case sig := <-stop:
        log.Printf("shutdown: %s", sig.String())
        _ = srv.Close()
    case err := <-errc:
        if err != nil {
            log.Fatal(err)
        }
    }
}
```

### Server Setup: `app/server/server.go`

Mounts all three transports:

```go
package server

import (
    "net/http"

    "github.com/go-mizu/mizu/contract"
    "example.com/myservice/service/todo"
)

type Server struct {
    cfg    Config
    server *http.Server
    svc    *contract.Service
}

func New(cfg Config, todoSvc *todo.Service) (*Server, error) {
    // Register the service to get a contract.
    svc, err := contract.Register("todo", todoSvc)
    if err != nil {
        return nil, err
    }

    mux := http.NewServeMux()

    // Mount REST endpoints (POST /todos, GET /todos, GET /todos/{id}, etc.)
    contract.MountREST(mux, svc)

    // Mount JSON-RPC 2.0 endpoint
    contract.MountJSONRPC(mux, "/rpc", svc)

    // Serve OpenAPI 3.1 spec
    contract.ServeOpenAPI(mux, "/openapi.json", svc)

    // Health check
    mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        _, _ = w.Write([]byte("ok\n"))
    })

    return &Server{
        cfg: cfg,
        server: &http.Server{
            Addr:    cfg.Addr,
            Handler: mux,
        },
        svc: svc,
    }, nil
}

func (s *Server) ListenAndServe() error { return s.server.ListenAndServe() }
func (s *Server) Close() error          { return s.server.Close() }
func (s *Server) Service() *contract.Service { return s.svc }
```

### Configuration: `app/server/config.go`

Environment-based configuration:

```go
package server

import "os"

type Config struct {
    Addr string
    Env  string
}

func LoadConfig() Config {
    return Config{
        Addr: getenv("ADDR", ":8080"),
        Env:  getenv("ENV", "dev"),
    }
}

func getenv(key, fallback string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return fallback
}
```

### Todo Service: `service/todo/todo.go`

Plain Go service with no HTTP dependencies:

```go
package todo

import (
    "context"
    "errors"
    "sync"
)

type Service struct {
    mu    sync.RWMutex
    todos map[string]*Todo
    seq   int
}

type Todo struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type CreateIn struct {
    Title string `json:"title"`
}

type GetIn struct {
    ID string `json:"id"`
}

type UpdateIn struct {
    ID        string `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

type DeleteIn struct {
    ID string `json:"id"`
}

type TodoList struct {
    Items []*Todo `json:"items"`
}

var (
    ErrNotFound   = errors.New("todo not found")
    ErrTitleEmpty = errors.New("title cannot be empty")
)

func (s *Service) Create(ctx context.Context, in *CreateIn) (*Todo, error) {
    // Implementation...
}

func (s *Service) Get(ctx context.Context, in *GetIn) (*Todo, error) {
    // Implementation...
}

func (s *Service) List(ctx context.Context) (*TodoList, error) {
    // Implementation...
}

func (s *Service) Update(ctx context.Context, in *UpdateIn) (*Todo, error) {
    // Implementation...
}

func (s *Service) Delete(ctx context.Context, in *DeleteIn) error {
    // Implementation...
}

func (s *Service) Health(ctx context.Context) error {
    return nil
}
```

## API Endpoints

The template exposes three interfaces:

### REST Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/todos` | Create todo |
| GET | `/todos` | List todos |
| GET | `/todos/{id}` | Get todo |
| PUT | `/todos/{id}` | Update todo |
| DELETE | `/todos/{id}` | Delete todo |
| GET | `/health` | Health check |

### JSON-RPC Endpoint

| Path | Methods |
|------|---------|
| `/rpc` | `Create`, `Get`, `List`, `Update`, `Delete`, `Health` |

### OpenAPI

| Path | Description |
|------|-------------|
| `/openapi.json` | OpenAPI 3.1 specification |

## Quick Start

```bash
# Create the project
mizu new myservice --template contract --module github.com/myorg/myservice

# Enter directory
cd myservice

# Install dependencies
go mod tidy

# Run the server
go run ./cmd/api
```

Test your API:

```bash
# Health check
curl http://localhost:8080/health
# ok

# Create todo (REST)
curl -X POST http://localhost:8080/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Buy milk"}'
# {"id":"todo_1","title":"Buy milk","completed":false}

# Create todo (JSON-RPC)
curl -X POST http://localhost:8080/rpc \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"Create","params":{"title":"Buy eggs"}}'
# {"jsonrpc":"2.0","id":1,"result":{"id":"todo_2","title":"Buy eggs","completed":false}}

# List todos
curl http://localhost:8080/todos
# {"items":[{"id":"todo_1",...},{"id":"todo_2",...}]}

# Get OpenAPI spec
curl http://localhost:8080/openapi.json | jq .info
# {"title":"todo","version":"0.1.0"}
```

## Configuration

Configure via environment variables:

```bash
# Change port
ADDR=:3000 go run ./cmd/api

# Set environment
ENV=production go run ./cmd/api
```

## Adding Services

### Add a New Service

1. Create the service directory:

```bash
mkdir -p service/user
```

2. Add the service (`service/user/user.go`):

```go
package user

import (
    "context"
)

type Service struct{}

type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type CreateIn struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

type GetIn struct {
    ID string `json:"id"`
}

func (s *Service) Create(ctx context.Context, in *CreateIn) (*User, error) {
    return &User{ID: "user_1", Name: in.Name, Email: in.Email}, nil
}

func (s *Service) Get(ctx context.Context, in *GetIn) (*User, error) {
    return &User{ID: in.ID, Name: "John", Email: "john@example.com"}, nil
}
```

3. Register in `app/server/server.go`:

```go
import (
    "example.com/myservice/service/user"
)

func New(cfg Config, todoSvc *todo.Service, userSvc *user.Service) (*Server, error) {
    todoContract, _ := contract.Register("todo", todoSvc)
    userContract, _ := contract.Register("user", userSvc)

    mux := http.NewServeMux()

    contract.MountREST(mux, todoContract)
    contract.MountREST(mux, userContract)

    contract.MountJSONRPC(mux, "/rpc/todo", todoContract)
    contract.MountJSONRPC(mux, "/rpc/user", userContract)

    contract.ServeOpenAPI(mux, "/openapi/todo.json", todoContract)
    contract.ServeOpenAPI(mux, "/openapi/user.json", userContract)

    // ...
}
```

## Testing Services

Services have no HTTP dependencies, making testing simple:

```go
package todo_test

import (
    "context"
    "testing"

    "example.com/myservice/service/todo"
)

func TestCreate(t *testing.T) {
    svc := &todo.Service{}
    ctx := context.Background()

    result, err := svc.Create(ctx, &todo.CreateIn{Title: "Test"})
    if err != nil {
        t.Fatal(err)
    }

    if result.Title != "Test" {
        t.Errorf("expected 'Test', got %q", result.Title)
    }
}

func TestCreate_EmptyTitle(t *testing.T) {
    svc := &todo.Service{}
    ctx := context.Background()

    _, err := svc.Create(ctx, &todo.CreateIn{Title: ""})
    if err != todo.ErrTitleEmpty {
        t.Errorf("expected ErrTitleEmpty, got %v", err)
    }
}
```

## When to Use

<Check>
**Use the contract template when:**
- You need multiple API protocols (REST + JSON-RPC)
- You want transport-independent business logic
- You need auto-generated OpenAPI specs
- You're building clean architecture services
- You want easy-to-test service layers
</Check>

## See Also

- [Minimal Template](/cli/template-minimal) - Simpler single-file starter
- [API Template](/cli/template-api) - Traditional Mizu handler-based API
- [Templates Overview](/cli/templates) - All available templates
- [Contract Overview](/contract/overview) - Contract system documentation
