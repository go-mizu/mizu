---
icon: "heart"
title: "Why Mizu"
description: "The idea and purpose behind the Mizu framework."
---

Mizu exists because web frameworks often add complexity that Go developers do not need. Go already has excellent HTTP primitives. Mizu builds on them with a thin layer that improves ergonomics without hiding what is happening underneath.

### Stay close to the standard library

Mizu uses Go 1.22's enhanced `ServeMux` for routing. Your handlers receive a context that wraps `http.ResponseWriter` and `*http.Request`. You can access the underlying types anytime:

```go
func handler(c *mizu.Ctx) error {
    w := c.Writer()    // http.ResponseWriter
    r := c.Request()   // *http.Request
    return c.Text(200, "ok")
}
```

Any `http.Handler` can be mounted directly. Any middleware that works with `net/http` works with Mizu.

### Return errors from handlers

Standard Go handlers have no return value. Errors must be handled inline, which leads to repeated patterns. Mizu handlers return an error:

```go
func createUser(c *mizu.Ctx) error {
    var input UserInput
    if err := c.BindJSON(&input, 1<<20); err != nil {
        return err // handled centrally
    }
    // ...
}
```

One central error handler catches all returned errors and recovered panics. Your route handlers stay focused on business logic.

### No reflection or magic

Mizu does not scan struct tags to bind parameters. It does not generate code. It does not use dependency injection. You read data with explicit method calls and write responses with explicit helpers.

```go
id := c.Param("id")           // path parameter
q := c.Query("search")        // query string
form, _ := c.Form()           // form data
name := form.Get("name")
```

This makes debugging straightforward. You can step through Mizu code and understand what happens at each line.

### Production defaults

Mizu includes what you need for production without extra setup:

- Graceful shutdown that drains connections
- Structured logging with `slog`
- Panic recovery with stack traces
- Health check endpoints for load balancers

You can configure shutdown timing and swap out the logger, but sensible defaults work out of the box.

### Small surface area

The entire framework fits in a few files. There are no plugins, no lifecycle hooks beyond middleware, and no framework-specific conventions to learn. If you understand Go's `net/http`, you understand Mizu.

### When to use Mizu

Mizu works well when you want:

- A lightweight wrapper over Go's HTTP server
- Explicit code without hidden behavior
- Easy integration with existing `net/http` code
- Production-ready defaults without external dependencies

If you need an opinionated full-stack framework with ORM, auth, and admin panels built in, Mizu is probably not the right choice. Mizu stays small so you can compose it with the libraries you prefer.
