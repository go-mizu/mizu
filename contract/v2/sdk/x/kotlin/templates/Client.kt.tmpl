{{define "Client.kt.tmpl"}}// Code generated by sdkkotlin. DO NOT EDIT.

package {{.Package}}

import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.engine.cio.*
import io.ktor.client.plugins.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.utils.io.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import kotlinx.serialization.json.Json
{{- if .HasDate}}
import kotlinx.datetime.Instant
{{- end}}
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

// MARK: - Client Options

/**
 * Configuration options for the SDK client.
 */
data class ClientOptions(
    /** API key for authentication. */
    val apiKey: String? = null,

    /** Base URL for API requests. */
    val baseUrl: String = {{kotlinString .Defaults.BaseURL}},

    /** Request timeout. */
    val timeout: Duration = 60.seconds,

    /** Maximum number of retry attempts for failed requests. */
    val maxRetries: Int = 2,

    /** Default headers to include in all requests. */
    val defaultHeaders: Map<String, String> = {{if .Defaults.Headers}}mapOf(
{{- range $i, $h := .Defaults.Headers}}
        {{kotlinString $h.K}} to {{kotlinString $h.V}}{{if lt $i (sub (len $.Defaults.Headers) 1)}},{{end}}
{{- end}}
    ){{else}}emptyMap(){{end}},

    /** Authentication mode. */
    val authMode: AuthMode = AuthMode.BEARER,

    /** Custom HTTP client (optional). */
    val httpClient: HttpClient? = null
)

/**
 * Authentication mode for API requests.
 */
enum class AuthMode {
    /** Bearer token authentication. */
    BEARER,
    /** Basic authentication. */
    BASIC,
    /** No authentication. */
    NONE
}

// MARK: - Main Client
{{if .Service.Description}}
/**
 * {{.Service.Description}}
 */
{{end -}}
class {{.Service.Sanitized}}(
    private val options: ClientOptions = ClientOptions()
) {
    private val httpClientWrapper = HttpClientWrapper(options)

{{- range .Resources}}
    /** Access to {{.Name}} operations. */
    val {{.KotlinName}}: {{.ClassName}} = {{.ClassName}}(httpClientWrapper)
{{- end}}

    /**
     * Creates a new client with modified configuration.
     */
    fun with(
        apiKey: String? = options.apiKey,
        baseUrl: String = options.baseUrl,
        timeout: Duration = options.timeout,
        maxRetries: Int = options.maxRetries,
        defaultHeaders: Map<String, String> = options.defaultHeaders,
        authMode: AuthMode = options.authMode
    ): {{.Service.Sanitized}} = {{.Service.Sanitized}}(
        ClientOptions(
            apiKey = apiKey,
            baseUrl = baseUrl,
            timeout = timeout,
            maxRetries = maxRetries,
            defaultHeaders = defaultHeaders,
            authMode = authMode
        )
    )

    /**
     * Closes the HTTP client and releases resources.
     */
    fun close() {
        httpClientWrapper.close()
    }
}

// MARK: - HTTP Client Wrapper

internal class HttpClientWrapper(
    private val options: ClientOptions
) {
    private val client: HttpClient = options.httpClient ?: HttpClient(CIO) {
        install(ContentNegotiation) {
            json(Json {
                ignoreUnknownKeys = true
                isLenient = true
                encodeDefaults = true
            })
        }
        install(HttpTimeout) {
            requestTimeoutMillis = options.timeout.inWholeMilliseconds
            connectTimeoutMillis = options.timeout.inWholeMilliseconds
        }
    }

    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
        encodeDefaults = true
    }

    suspend inline fun <reified T> request(
        method: HttpMethod,
        path: String,
        body: Any? = null
    ): T {
        var lastException: Exception? = null

        repeat(options.maxRetries + 1) { attempt ->
            try {
                val response = client.request {
                    this.method = method
                    url(options.baseUrl + path)

                    applyHeaders()
                    applyAuth()

                    body?.let {
                        contentType(ContentType.Application.Json)
                        setBody(it)
                    }
                }

                if (response.status.value >= 400) {
                    throw parseErrorResponse(response)
                }

                return response.body()
            } catch (e: SDKException) {
                throw e // Don't retry SDK errors
            } catch (e: Exception) {
                lastException = e
                if (attempt < options.maxRetries) {
                    delay(backoff(attempt))
                }
            }
        }

        throw SDKException.ConnectionError(
            lastException ?: Exception("Unknown error")
        )
    }

    suspend fun requestUnit(
        method: HttpMethod,
        path: String,
        body: Any? = null
    ) {
        var lastException: Exception? = null

        repeat(options.maxRetries + 1) { attempt ->
            try {
                val response = client.request {
                    this.method = method
                    url(options.baseUrl + path)

                    applyHeaders()
                    applyAuth()

                    body?.let {
                        contentType(ContentType.Application.Json)
                        setBody(it)
                    }
                }

                if (response.status.value >= 400) {
                    throw parseErrorResponse(response)
                }

                return
            } catch (e: SDKException) {
                throw e
            } catch (e: Exception) {
                lastException = e
                if (attempt < options.maxRetries) {
                    delay(backoff(attempt))
                }
            }
        }

        throw SDKException.ConnectionError(
            lastException ?: Exception("Unknown error")
        )
    }

{{- if .HasSSE}}

    inline fun <reified T> stream(
        method: HttpMethod,
        path: String,
        body: Any? = null
    ): Flow<T> = flow {
        val response = client.request {
            this.method = method
            url(options.baseUrl + path)
            header("Accept", "text/event-stream")

            applyHeaders()
            applyAuth()

            body?.let {
                contentType(ContentType.Application.Json)
                setBody(it)
            }
        }

        if (response.status.value >= 400) {
            throw parseErrorResponse(response)
        }

        val channel: ByteReadChannel = response.body()
        var buffer = StringBuilder()

        while (!channel.isClosedForRead) {
            val line = channel.readUTF8Line() ?: break

            if (line.isEmpty()) {
                val data = buffer.toString().trim()
                buffer = StringBuilder()

                if (data.isNotEmpty() && data != "[DONE]") {
                    emit(json.decodeFromString<T>(data))
                }
            } else if (line.startsWith("data:")) {
                val content = line.removePrefix("data:").trimStart()
                if (buffer.isNotEmpty()) buffer.append("\n")
                buffer.append(content)
            }
        }
    }.flowOn(Dispatchers.IO)
{{- end}}

    private fun HttpRequestBuilder.applyHeaders() {
        options.defaultHeaders.forEach { (key, value) ->
            header(key, value)
        }
    }

    private fun HttpRequestBuilder.applyAuth() {
        options.apiKey?.let { key ->
            when (options.authMode) {
                AuthMode.BEARER -> header("Authorization", "Bearer $key")
                AuthMode.BASIC -> header("Authorization", "Basic $key")
                AuthMode.NONE -> { }
            }
        }
    }

    private suspend fun parseErrorResponse(response: HttpResponse): SDKException {
        val statusCode = response.status.value
        val bodyText = try {
            response.bodyAsText()
        } catch (_: Exception) {
            null
        }

        val message = try {
            val jsonBody = bodyText?.let { json.parseToJsonElement(it) }
            when {
                jsonBody is kotlinx.serialization.json.JsonObject -> {
                    (jsonBody["message"] as? kotlinx.serialization.json.JsonPrimitive)?.content
                        ?: (jsonBody["error"] as? kotlinx.serialization.json.JsonPrimitive)?.content
                        ?: "HTTP $statusCode"
                }
                else -> bodyText ?: "HTTP $statusCode"
            }
        } catch (_: Exception) {
            bodyText ?: "HTTP $statusCode"
        }

        return SDKException.ApiError(statusCode, message, bodyText)
    }

    private fun backoff(attempt: Int): Long {
        val baseDelay = 500L // 0.5 seconds
        return baseDelay * (1 shl attempt) // Exponential backoff
    }

    fun close() {
        client.close()
    }
}
{{end}}
