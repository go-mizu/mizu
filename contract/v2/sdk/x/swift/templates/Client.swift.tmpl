{{define "Client.swift.tmpl"}}// Code generated by sdkswift. DO NOT EDIT.

import Foundation

// MARK: - Client Options

/// Configuration options for the SDK client.
public struct ClientOptions: Sendable {
    /// API key for authentication.
    public var apiKey: String?

    /// Base URL for API requests.
    public var baseURL: URL

    /// Request timeout in seconds.
    public var timeout: TimeInterval

    /// Maximum number of retry attempts for failed requests.
    public var maxRetries: Int

    /// Default headers to include in all requests.
    public var defaultHeaders: [String: String]

    /// Authentication mode.
    public var authMode: AuthMode

    /// Creates new client options.
    public init(
        apiKey: String? = nil,
        baseURL: URL? = nil,
        timeout: TimeInterval = 60,
        maxRetries: Int = 2,
        defaultHeaders: [String: String] = [:],
        authMode: AuthMode = .bearer
    ) {
        self.apiKey = apiKey
        self.baseURL = baseURL ?? URL(string: {{swiftString .Defaults.BaseURL}})!
        self.timeout = timeout
        self.maxRetries = maxRetries
        self.authMode = authMode

        // Merge default headers
        var headers: [String: String] = [:]
{{- range .Defaults.Headers}}
        headers[{{swiftString .K}}] = {{swiftString .V}}
{{- end}}
        for (key, value) in defaultHeaders {
            headers[key] = value
        }
        self.defaultHeaders = headers
    }
}

/// Authentication mode for API requests.
public enum AuthMode: String, Sendable {
    /// Bearer token authentication.
    case bearer
    /// Basic authentication.
    case basic
    /// No authentication.
    case none
}

// MARK: - Main Client

{{- if .Service.Description}}
/// {{.Service.Description}}
{{- end}}
public final class {{.Service.Sanitized}}: Sendable {
    private let httpClient: HTTPClient

{{- range .Resources}}
    /// Access to {{.Name}} operations.
    public let {{.SwiftName}}: {{.ClassName}}
{{- end}}

    /// Creates a new client with the specified options.
    public init(options: ClientOptions = .init()) {
        self.httpClient = HTTPClient(options: options)
{{- range .Resources}}
        self.{{.SwiftName}} = {{.ClassName}}(client: self.httpClient)
{{- end}}
    }

    /// Creates a new client with a modified configuration.
    public func with(
        apiKey: String? = nil,
        baseURL: URL? = nil,
        timeout: TimeInterval? = nil,
        maxRetries: Int? = nil,
        defaultHeaders: [String: String]? = nil
    ) -> {{.Service.Sanitized}} {
        let currentOptions = httpClient.options
        let newOptions = ClientOptions(
            apiKey: apiKey ?? currentOptions.apiKey,
            baseURL: baseURL ?? currentOptions.baseURL,
            timeout: timeout ?? currentOptions.timeout,
            maxRetries: maxRetries ?? currentOptions.maxRetries,
            defaultHeaders: defaultHeaders ?? currentOptions.defaultHeaders,
            authMode: currentOptions.authMode
        )
        return {{.Service.Sanitized}}(options: newOptions)
    }
}

// MARK: - HTTP Client

internal actor HTTPClient {
    let options: ClientOptions
    private let session: URLSession
    private let encoder: JSONEncoder
    private let decoder: JSONDecoder

    init(options: ClientOptions) {
        self.options = options

        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = options.timeout
        config.timeoutIntervalForResource = options.timeout * 2
        self.session = URLSession(configuration: config)

        self.encoder = JSONEncoder()
        self.encoder.dateEncodingStrategy = .iso8601

        self.decoder = JSONDecoder()
        self.decoder.dateDecodingStrategy = .iso8601
    }

    func request<T: Decodable>(
        method: String,
        path: String,
        body: (any Encodable)? = nil
    ) async throws -> T {
        let url = options.baseURL.appendingPathComponent(path)
        var request = URLRequest(url: url)
        request.httpMethod = method
        request.timeoutInterval = options.timeout

        // Apply headers
        applyDefaultHeaders(&request)
        applyAuth(&request)

        // Encode body
        if let body = body {
            request.httpBody = try encoder.encode(AnyEncodable(body))
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }

        // Retry loop
        var lastError: Error?
        for attempt in 0...options.maxRetries {
            do {
                let (data, response) = try await session.data(for: request)

                guard let httpResponse = response as? HTTPURLResponse else {
                    throw SDKError.connectionError(underlying: URLError(.badServerResponse))
                }

                if httpResponse.statusCode >= 400 {
                    throw try parseErrorResponse(statusCode: httpResponse.statusCode, data: data)
                }

                if httpResponse.statusCode == 204 || data.isEmpty {
                    // Handle void response - this is a workaround for Void decoding
                    if T.self == EmptyResponse.self {
                        return EmptyResponse() as! T
                    }
                }

                return try decoder.decode(T.self, from: data)
            } catch let error as SDKError {
                throw error // Don't retry SDK errors
            } catch let error as APIError {
                throw error // Don't retry API errors
            } catch {
                lastError = error
                if attempt < options.maxRetries {
                    try await Task.sleep(nanoseconds: backoffNanoseconds(attempt: attempt))
                }
            }
        }
        throw SDKError.connectionError(underlying: lastError ?? URLError(.unknown))
    }

    func requestVoid(
        method: String,
        path: String,
        body: (any Encodable)? = nil
    ) async throws {
        let _: EmptyResponse = try await request(method: method, path: path, body: body)
    }

{{- if .HasSSE}}

    func stream<T: Decodable>(
        method: String,
        path: String,
        body: (any Encodable)? = nil,
        as type: T.Type
    ) -> AsyncThrowingStream<T, Error> {
        AsyncThrowingStream { continuation in
            let task = Task {
                do {
                    let url = options.baseURL.appendingPathComponent(path)
                    var request = URLRequest(url: url)
                    request.httpMethod = method
                    request.setValue("text/event-stream", forHTTPHeaderField: "Accept")

                    applyDefaultHeaders(&request)
                    applyAuth(&request)

                    if let body = body {
                        request.httpBody = try encoder.encode(AnyEncodable(body))
                        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                    }

                    let (bytes, response) = try await session.bytes(for: request)

                    guard let httpResponse = response as? HTTPURLResponse else {
                        throw SDKError.connectionError(underlying: URLError(.badServerResponse))
                    }

                    if httpResponse.statusCode >= 400 {
                        var body = Data()
                        for try await byte in bytes {
                            body.append(byte)
                        }
                        throw try parseErrorResponse(statusCode: httpResponse.statusCode, data: body)
                    }

                    var buffer = ""
                    for try await line in bytes.lines {
                        try Task.checkCancellation()

                        if line.isEmpty {
                            // Empty line = end of event
                            if !buffer.isEmpty {
                                let data = buffer.trimmingCharacters(in: .whitespaces)
                                buffer = ""

                                if data == "[DONE]" {
                                    break
                                }

                                let item = try decoder.decode(T.self, from: Data(data.utf8))
                                continuation.yield(item)
                            }
                            continue
                        }

                        if line.hasPrefix("data:") {
                            var data = String(line.dropFirst(5))
                            if data.hasPrefix(" ") {
                                data = String(data.dropFirst())
                            }
                            if !buffer.isEmpty {
                                buffer += "\n"
                            }
                            buffer += data
                        }
                    }

                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }

            continuation.onTermination = { @Sendable _ in
                task.cancel()
            }
        }
    }
{{- end}}

    private func applyDefaultHeaders(_ request: inout URLRequest) {
        for (key, value) in options.defaultHeaders {
            request.setValue(value, forHTTPHeaderField: key)
        }
    }

    private func applyAuth(_ request: inout URLRequest) {
        guard let apiKey = options.apiKey else { return }

        switch options.authMode {
        case .bearer:
            request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        case .basic:
            request.setValue("Basic \(apiKey)", forHTTPHeaderField: "Authorization")
        case .none:
            break
        }
    }

    private func parseErrorResponse(statusCode: Int, data: Data) throws -> APIError {
        var message = "HTTP \(statusCode)"
        var body: Any? = nil

        if let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
            body = json
            if let msg = json["message"] as? String {
                message = msg
            } else if let msg = json["error"] as? String {
                message = msg
            }
        } else if let text = String(data: data, encoding: .utf8), !text.isEmpty {
            body = text
            message = text
        }

        return APIError(statusCode: statusCode, message: message, body: body)
    }

    private func backoffNanoseconds(attempt: Int) -> UInt64 {
        let baseDelay: UInt64 = 500_000_000 // 0.5 seconds
        let multiplier = UInt64(1 << attempt) // Exponential backoff
        return baseDelay * multiplier
    }
}

// MARK: - Helper Types

/// Empty response type for void returns.
internal struct EmptyResponse: Decodable {}

/// Type-erasing wrapper for encoding any Encodable value.
internal struct AnyEncodable: Encodable {
    private let encode: (Encoder) throws -> Void

    init(_ value: any Encodable) {
        self.encode = { encoder in
            try value.encode(to: encoder)
        }
    }

    func encode(to encoder: Encoder) throws {
        try encode(encoder)
    }
}
{{end}}
