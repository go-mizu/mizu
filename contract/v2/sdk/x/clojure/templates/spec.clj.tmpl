{{define "spec.clj.tmpl"}};; Code generated by sdkclojure. DO NOT EDIT.

(ns {{.Namespace}}.spec
  "Clojure specs for {{.Service.Name}} SDK types.

   These specs provide:
     - Runtime validation
     - Generative testing support
     - Documentation

   Usage:
     (require '[{{.Namespace}}.spec :as spec])
     (s/valid? ::spec/message msg)
     (s/explain ::spec/message invalid-msg)"
  (:require [clojure.spec.alpha :as s]
{{- if .HasDate}}
            [java-time.api :as jt])
  (:import [java.time Instant])
{{- else}})
{{- end}})

;; -----------------------------------------------------------------------------
;; Primitive Specs
;; -----------------------------------------------------------------------------

(s/def ::non-empty-string (s/and string? seq))
(s/def ::non-negative-int (s/and int? (complement neg?)))
(s/def ::positive-int (s/and int? pos?))
{{if .HasDate}}
(s/def ::instant #(instance? Instant %))
{{end}}

;; -----------------------------------------------------------------------------
;; Type Specs
;; -----------------------------------------------------------------------------
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

;; {{$type.RecordName}}
{{- if $type.Description}}
;; {{$type.Description}}
{{- end}}
{{- range $f := $type.Fields}}
{{- if $f.Enum}}
(s/def ::{{$type.CljName}}-{{$f.CljName}} #{{"{"}}{{range $i, $e := $f.Enum}}{{if $i}} {{end}}{{$e.Name}}{{end}}{{"}"}})
{{- else if $f.Const}}
(s/def ::{{$type.CljName}}-{{$f.CljName}} #{"{"}}{{cljString $f.Const}}{{"}"}})
{{- else}}
(s/def ::{{$type.CljName}}-{{$f.CljName}} {{$f.CljType}})
{{- end}}
{{- end}}

(s/def ::{{$type.CljName}}
  (s/keys {{if $type.Fields}}:req-un [{{range $i, $f := $type.Fields}}{{if not $f.Optional}}{{if $i}} {{end}}::{{$type.CljName}}-{{$f.CljName}}{{end}}{{end}}]
          :opt-un [{{range $i, $f := $type.Fields}}{{if $f.Optional}}{{if $i}} {{end}}::{{$type.CljName}}-{{$f.CljName}}{{end}}{{end}}]{{else}}{{end}}))
{{- end}}

{{- if eq $type.Kind "slice"}}

;; {{$type.RecordName}} (list of {{$type.Elem}})
(s/def ::{{$type.CljName}} (s/coll-of {{$type.ElemClj}}))
{{- end}}

{{- if eq $type.Kind "map"}}

;; {{$type.RecordName}} (map with string keys and {{$type.Elem}} values)
(s/def ::{{$type.CljName}} (s/map-of keyword? {{$type.ElemClj}}))
{{- end}}

{{- if eq $type.Kind "union"}}

;; {{$type.RecordName}} (union)
{{- if $type.Description}}
;; {{$type.Description}}
{{- end}}
;; Discriminated by: {{$type.Tag}}
{{- range $v := $type.Variants}}
(s/def ::{{$type.CljName}}-{{kebab $v.Value}}
  (s/and map?
         #(= {{cljString $v.Value}} (get % {{cljString $type.Tag}} (get % (keyword {{cljString $type.Tag}}))))))
{{- end}}

(s/def ::{{$type.CljName}}
  (s/or {{range $i, $v := $type.Variants}}{{if $i}}
        {{end}}{{$v.CljName}} ::{{$type.CljName}}-{{kebab $v.Value}}{{end}}))
{{- end}}
{{- end}}

;; -----------------------------------------------------------------------------
;; Request/Response Specs
;; -----------------------------------------------------------------------------
{{range $r := .Resources}}
{{- range $m := $r.Methods}}
{{- if $m.HasInput}}

;; {{$m.FullName}} request
(s/def ::{{$m.FullName}}-request ::{{kebab $m.InputType}})
{{- end}}
{{- if $m.HasOutput}}

;; {{$m.FullName}} response
(s/def ::{{$m.FullName}}-response ::{{kebab $m.OutputType}})
{{- end}}
{{- end}}
{{- end}}

;; -----------------------------------------------------------------------------
;; Validation Functions
;; -----------------------------------------------------------------------------

(defn valid?
  "Returns true if x is valid according to spec."
  [spec x]
  (s/valid? spec x))

(defn explain
  "Prints an explanation of why x doesn't conform to spec."
  [spec x]
  (s/explain spec x))

(defn explain-str
  "Returns a string explanation of why x doesn't conform to spec."
  [spec x]
  (s/explain-str spec x))

(defn validate!
  "Validates x against spec, throwing an exception if invalid."
  [spec x]
  (if (s/valid? spec x)
    x
    (throw (ex-info (str "Validation failed: " (s/explain-str spec x))
                    {:type :validation-error
                     :spec spec
                     :value x
                     :problems (s/explain-data spec x)}))))

(defn conform
  "Conforms x to spec, returning the conformed value or :clojure.spec.alpha/invalid."
  [spec x]
  (s/conform spec x))

;; -----------------------------------------------------------------------------
;; Development Tools
;; -----------------------------------------------------------------------------

(defn instrument!
  "Enables spec instrumentation for all SDK functions.
   Useful during development for catching invalid arguments.

   Requires org.clojure/spec.alpha and expound/expound on classpath."
  []
  (require 'clojure.spec.test.alpha)
  (when-let [instrument (resolve 'clojure.spec.test.alpha/instrument)]
    (instrument)))

(defn unstrument!
  "Disables spec instrumentation for all SDK functions."
  []
  (require 'clojure.spec.test.alpha)
  (when-let [unstrument (resolve 'clojure.spec.test.alpha/unstrument)]
    (unstrument)))

(defn check
  "Runs generative tests on the given function.

   Requires org.clojure/test.check on classpath.

   Options:
     :num-tests - Number of tests to run (default: 100)"
  ([sym]
   (check sym {}))
  ([sym opts]
   (require 'clojure.spec.test.alpha)
   (when-let [check-fn (resolve 'clojure.spec.test.alpha/check)]
     (check-fn sym (merge {:clojure.spec.test.check/opts {:num-tests 100}} opts)))))
{{end}}