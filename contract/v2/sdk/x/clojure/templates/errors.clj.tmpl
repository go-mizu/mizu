{{define "errors.clj.tmpl"}};; Code generated by sdkclojure. DO NOT EDIT.

(ns {{.Namespace}}.errors
  "Error types and error handling for {{.Service.Name}} SDK.

   All errors are thrown as ex-info exceptions with a :type key
   indicating the error category:
     :api-error        - API returned an error response
     :connection-error - Network/connection failure
     :timeout          - Request timed out
     :decoding-error   - Failed to parse response")

;; -----------------------------------------------------------------------------
;; Error Constructors
;; -----------------------------------------------------------------------------

(defn api-error
  "Creates an API error exception.

   Thrown when the API returns an error status code (4xx, 5xx).

   ex-data keys:
     :type   - :api-error
     :status - HTTP status code
     :body   - Response body (string)"
  [status body]
  (ex-info (str "API error: HTTP " status)
           {:type :api-error
            :status status
            :body body}))

(defn connection-error
  "Creates a connection error exception.

   Thrown when a network error occurs (connection refused, DNS failure, etc.).

   ex-data keys:
     :type  - :connection-error
     :cause - Original exception"
  [cause]
  (ex-info (str "Connection error: " (.getMessage ^Throwable cause))
           {:type :connection-error
            :cause cause}
           cause))

(defn timeout-error
  "Creates a timeout error exception.

   Thrown when the request times out.

   ex-data keys:
     :type - :timeout"
  []
  (ex-info "Request timed out"
           {:type :timeout}))

(defn decoding-error
  "Creates a JSON decoding error exception.

   Thrown when the response cannot be parsed as JSON.

   ex-data keys:
     :type  - :decoding-error
     :raw   - Raw response string
     :cause - Original exception"
  [cause raw]
  (ex-info (str "Failed to decode response: " (.getMessage ^Throwable cause))
           {:type :decoding-error
            :raw raw
            :cause cause}
           cause))

(defn stream-error
  "Creates a streaming error exception.

   Thrown when an error occurs during SSE streaming.

   ex-data keys:
     :type    - :stream-error
     :details - Additional error details"
  [details]
  (ex-info (str "Stream error: " (:message details "Unknown error"))
           {:type :stream-error
            :details details}))

;; -----------------------------------------------------------------------------
;; Error Predicates
;; -----------------------------------------------------------------------------

(defn api-error?
  "Returns true if the exception is an API error."
  [e]
  (and (instance? clojure.lang.ExceptionInfo e)
       (= :api-error (:type (ex-data e)))))

(defn connection-error?
  "Returns true if the exception is a connection error."
  [e]
  (and (instance? clojure.lang.ExceptionInfo e)
       (= :connection-error (:type (ex-data e)))))

(defn timeout-error?
  "Returns true if the exception is a timeout error."
  [e]
  (and (instance? clojure.lang.ExceptionInfo e)
       (= :timeout (:type (ex-data e)))))

(defn decoding-error?
  "Returns true if the exception is a decoding error."
  [e]
  (and (instance? clojure.lang.ExceptionInfo e)
       (= :decoding-error (:type (ex-data e)))))

(defn stream-error?
  "Returns true if the exception is a stream error."
  [e]
  (and (instance? clojure.lang.ExceptionInfo e)
       (= :stream-error (:type (ex-data e)))))

(defn retryable?
  "Returns true if the error should be retried.

   Retryable errors:
     - Connection errors (transient network issues)
     - Timeout errors
     - API errors with status >= 500 (server errors)
     - API errors with status 429 (rate limiting)"
  [e]
  (cond
    (connection-error? e) true
    (timeout-error? e) true
    (api-error? e)
    (let [status (:status (ex-data e))]
      (or (>= status 500) (= status 429)))
    :else false))

;; -----------------------------------------------------------------------------
;; Error Extraction
;; -----------------------------------------------------------------------------

(defn error-type
  "Returns the error type keyword, or nil if not an SDK error."
  [e]
  (when (instance? clojure.lang.ExceptionInfo e)
    (:type (ex-data e))))

(defn error-status
  "Returns the HTTP status code for API errors, or nil."
  [e]
  (when (api-error? e)
    (:status (ex-data e))))

(defn error-body
  "Returns the response body for API errors, or nil."
  [e]
  (when (api-error? e)
    (:body (ex-data e))))

(defn parse-error-body
  "Attempts to parse the error body as JSON.
   Returns the parsed map or nil if parsing fails."
  [e]
  (when-let [body (error-body e)]
    (try
      (cheshire.core/parse-string body true)
      (catch Exception _ nil))))

;; -----------------------------------------------------------------------------
;; Error Handling Helpers
;; -----------------------------------------------------------------------------

(defmacro with-error-handling
  "Wraps body in error handling that converts exceptions to result maps.

   Returns:
     {:ok true :result <value>} on success
     {:ok false :error <ex-data>} on failure

   Example:
     (with-error-handling
       (api/messages-create client request))"
  [& body]
  `(try
     {:ok true :result (do ~@body)}
     (catch clojure.lang.ExceptionInfo e#
       {:ok false :error (ex-data e#)})
     (catch Exception e#
       {:ok false :error {:type :unknown-error
                          :message (.getMessage e#)
                          :cause e#}})))

(defmacro retry-on-error
  "Retries the body on retryable errors.

   Options:
     :max-retries - Maximum number of retry attempts (default: 3)
     :delay-ms    - Initial delay between retries in ms (default: 500)
     :backoff     - Backoff multiplier (default: 2)

   Example:
     (retry-on-error {:max-retries 5}
       (api/messages-create client request))"
  [opts & body]
  `(let [opts# (merge {:max-retries 3 :delay-ms 500 :backoff 2} ~opts)]
     (loop [attempt# 0]
       (let [result# (try
                       {:ok true :value (do ~@body)}
                       (catch Exception e#
                         {:ok false :error e#}))]
         (if (:ok result#)
           (:value result#)
           (if (and (retryable? (:error result#))
                    (< attempt# (:max-retries opts#)))
             (do
               (Thread/sleep (long (* (:delay-ms opts#)
                                      (Math/pow (:backoff opts#) attempt#))))
               (recur (inc attempt#)))
             (throw (:error result#))))))))
{{end}}