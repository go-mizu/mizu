{{define "core.clj.tmpl"}};; Code generated by sdkclojure. DO NOT EDIT.

(ns {{.Namespace}}.core
  "{{.Service.Name}} SDK client.
{{- if .Service.Description}}

   {{.Service.Description}}
{{- end}}"
  (:require [clj-http.client :as http]
            [cheshire.core :as json]
            [{{.Namespace}}.errors :as errors]
            [{{.Namespace}}.types :as types]
{{- if .HasSSE}}
            [{{.Namespace}}.streaming :as streaming]
{{- end}}
{{- if .HasDate}}
            [java-time.api :as jt]
{{- end}})
  (:import [java.net SocketTimeoutException ConnectException]))

;; -----------------------------------------------------------------------------
;; Authentication Modes
;; -----------------------------------------------------------------------------

(def auth-modes
  "Supported authentication modes."
  #{:bearer :basic :api-key :none})

;; -----------------------------------------------------------------------------
;; Client Configuration
;; -----------------------------------------------------------------------------

(def default-config
  "Default client configuration."
  {:base-url {{cljString .Client.BaseURL}}
   :auth-mode {{if eq .Client.Auth "bearer"}}:bearer{{else if eq .Client.Auth "basic"}}:basic{{else if eq .Client.Auth "apikey"}}:api-key{{else}}:bearer{{end}}
   :timeout-ms 60000
   :connection-timeout-ms 10000
   :max-retries 2
   :default-headers {{"{"}}"Content-Type" "application/json"
                     "Accept" "application/json"{{range .Client.Headers}}
                     {{cljString .K}} {{cljString .V}}{{end}}{{"}"}}})

(defrecord Client [config])

(defn create-client
  "Creates a new {{.Service.Name}} API client.

   Options:
     :api-key             - API key for authentication
     :base-url            - Base URL for API requests (default: {{.Client.BaseURL}})
     :auth-mode           - Authentication mode (:bearer, :basic, :api-key, :none)
     :timeout-ms          - Request timeout in milliseconds (default: 60000)
     :connection-timeout-ms - Connection timeout in milliseconds (default: 10000)
     :max-retries         - Maximum retry attempts for failed requests (default: 2)
     :default-headers     - Additional headers to include in all requests

   Example:
     (create-client {:api-key \"sk-xxx\"})
     (create-client {:api-key \"sk-xxx\" :base-url \"http://localhost:8080\"})"
  ([]
   (create-client {}))
  ([opts]
   (->Client (merge default-config opts))))

;; -----------------------------------------------------------------------------
;; Client Modifiers
;; -----------------------------------------------------------------------------

(defn with-api-key
  "Returns a new client with the given API key."
  [client api-key]
  (->Client (assoc (:config client) :api-key api-key)))

(defn with-base-url
  "Returns a new client with the given base URL."
  [client base-url]
  (->Client (assoc (:config client) :base-url base-url)))

(defn with-timeout
  "Returns a new client with the given timeout (in milliseconds)."
  [client timeout-ms]
  (->Client (assoc (:config client) :timeout-ms timeout-ms)))

(defn with-headers
  "Returns a new client with additional default headers merged in."
  [client headers]
  (->Client (update-in (:config client) [:default-headers] merge headers)))

;; -----------------------------------------------------------------------------
;; Internal Request Handling
;; -----------------------------------------------------------------------------

(defn- build-headers
  "Constructs request headers including authentication."
  [{:keys [api-key auth-mode default-headers]}]
  (cond-> default-headers
    (and api-key (= auth-mode :bearer))
    (assoc "Authorization" (str "Bearer " api-key))

    (and api-key (= auth-mode :basic))
    (assoc "Authorization" (str "Basic " api-key))

    (and api-key (= auth-mode :api-key))
    (assoc "X-Api-Key" api-key)))

(defn- retryable-error?
  "Returns true if the error should be retried."
  [e status]
  (or (instance? SocketTimeoutException e)
      (instance? ConnectException e)
      (and status (or (>= status 500) (= status 429)))))

(defn- execute-with-retry
  "Executes a request with retry logic."
  [request-fn config attempts]
  (loop [attempt 0]
    (let [result (try
                   {:success true :response (request-fn)}
                   (catch SocketTimeoutException e
                     {:success false :error e :retryable true})
                   (catch ConnectException e
                     {:success false :error e :retryable true})
                   (catch Exception e
                     {:success false :error e :retryable false}))]
      (cond
        ;; Success
        (:success result)
        (let [{:keys [status body]} (:response result)]
          (if (< status 400)
            (if (and body (not (empty? body)))
              (json/parse-string body true)
              nil)
            (if (and (< attempt attempts)
                     (retryable-error? nil status))
              (do
                (Thread/sleep (* 500 (long (Math/pow 2 attempt))))
                (recur (inc attempt)))
              (throw (errors/api-error status body)))))

        ;; Retryable error
        (and (:retryable result) (< attempt attempts))
        (do
          (Thread/sleep (* 500 (long (Math/pow 2 attempt))))
          (recur (inc attempt)))

        ;; Non-retryable error
        :else
        (throw (errors/connection-error (:error result)))))))

(defn request
  "Makes an HTTP request to the API.

   Arguments:
     client  - The API client
     method  - HTTP method (:get, :post, :put, :patch, :delete)
     path    - API path (e.g., \"/v1/messages\")
     body    - Request body (will be JSON-encoded)
     opts    - Additional options (:timeout-ms to override timeout)

   Returns the parsed JSON response.
   Throws ex-info on error with :type key indicating error type."
  ([client method path]
   (request client method path nil {}))
  ([client method path body]
   (request client method path body {}))
  ([client method path body opts]
   (let [config (:config client)
         {:keys [base-url timeout-ms connection-timeout-ms max-retries]} config
         effective-timeout (or (:timeout-ms opts) timeout-ms)
         url (str base-url path)
         headers (build-headers config)
         request-fn (fn []
                      (http/request
                        (cond-> {:method method
                                 :url url
                                 :headers headers
                                 :socket-timeout effective-timeout
                                 :connection-timeout connection-timeout-ms
                                 :throw-exceptions false
                                 :as :string}
                          body (assoc :body (json/generate-string body)))))]
     (execute-with-retry request-fn config max-retries))))

{{if .HasSSE}}
;; -----------------------------------------------------------------------------
;; Streaming Request
;; -----------------------------------------------------------------------------

(defn stream-request
  "Makes a streaming HTTP request to the API.

   Returns a core.async channel that will receive events.
   Each event is a map with :data key containing the parsed JSON.
   Channel closes when stream ends or on error."
  ([client method path body]
   (stream-request client method path body {}))
  ([client method path body opts]
   (streaming/stream-request client method path body opts)))
{{end}}

;; -----------------------------------------------------------------------------
;; Resource Accessors
;; -----------------------------------------------------------------------------
{{range $r := .Resources}}

;; {{$r.Name}} resource
{{- range .Methods}}
{{- if not .IsStreaming}}

(defn {{.FullName}}
  "{{if .Description}}{{.Description}}{{else}}Calls {{.Name}} on the {{$r.Name}} resource.{{end}}
{{- if .HasInput}}

   Arguments:
     client  - The API client
     request - Request parameters{{if eq .HTTPMethod "get"}} (query params){{else}} (request body){{end}}
     opts    - Optional: {:timeout-ms N} to override timeout
{{- else}}

   Arguments:
     client  - The API client
     opts    - Optional: {:timeout-ms N} to override timeout
{{- end}}"
  {{- if .HasInput}}
  ([client request]
   ({{.FullName}} client request {}))
  ([client request opts]
   (-> (request client :{{.HTTPMethod}} {{cljString .HTTPPath}}{{if eq .HTTPMethod "get"}} nil{{else}} request{{end}} opts)
       {{- if .HasOutput}}
       types/->{{kebab .OutputType}}{{end}}))
  {{- else}}
  ([client]
   ({{.FullName}} client {}))
  ([client opts]
   (-> (request client :{{.HTTPMethod}} {{cljString .HTTPPath}} nil opts)
       {{- if .HasOutput}}
       types/->{{kebab .OutputType}}{{end}}))
  {{- end}}
{{- else}}

(defn {{.FullName}}
  "{{if .Description}}{{.Description}}{{else}}Streams {{.Name}} from the {{$r.Name}} resource.{{end}}

   Returns a core.async channel of events.
{{- if .HasInput}}

   Arguments:
     client  - The API client
     request - Request parameters
     opts    - Optional: {:timeout-ms N} to override timeout
{{- else}}

   Arguments:
     client  - The API client
     opts    - Optional: {:timeout-ms N} to override timeout
{{- end}}"
  {{- if .HasInput}}
  ([client request]
   ({{.FullName}} client request {}))
  ([client request opts]
   (stream-request client :{{.HTTPMethod}} {{cljString .HTTPPath}} (assoc request :stream true) opts))
  {{- else}}
  ([client]
   ({{.FullName}} client {}))
  ([client opts]
   (stream-request client :{{.HTTPMethod}} {{cljString .HTTPPath}} {:stream true} opts))
  {{- end}}

(defn {{.FullName}}-collect
  "Like {{.FullName}} but collects all events and returns them as a vector.
   Blocks until the stream completes."
  {{- if .HasInput}}
  ([client request]
   ({{.FullName}}-collect client request {}))
  ([client request opts]
   (streaming/collect-stream ({{.FullName}} client request opts)))
  {{- else}}
  ([client]
   ({{.FullName}}-collect client {}))
  ([client opts]
   (streaming/collect-stream ({{.FullName}} client opts)))
  {{- end}}
{{- end}}
{{- end}}
{{- end}}
{{end}}