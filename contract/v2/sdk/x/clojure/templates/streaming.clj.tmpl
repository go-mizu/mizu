{{define "streaming.clj.tmpl"}};; Code generated by sdkclojure. DO NOT EDIT.

(ns {{.Namespace}}.streaming
  "Server-Sent Events (SSE) streaming support for {{.Service.Name}} SDK."
  (:require [clojure.core.async :as async]
            [clojure.string :as str]
            [clj-http.client :as http]
            [cheshire.core :as json]
            [{{.Namespace}}.errors :as errors])
  (:import [java.io BufferedReader InputStreamReader]
           [java.net SocketTimeoutException]))

{{if .HasSSE}}
;; -----------------------------------------------------------------------------
;; SSE Event Parsing
;; -----------------------------------------------------------------------------

(defn- parse-sse-line
  "Parses a single SSE line into a field/value pair."
  [line]
  (cond
    (str/blank? line)
    {:type :dispatch}

    (str/starts-with? line ":")
    {:type :comment :value (subs line 1)}

    (str/starts-with? line "data:")
    {:type :data :value (str/trim (subs line 5))}

    (str/starts-with? line "event:")
    {:type :event :value (str/trim (subs line 6))}

    (str/starts-with? line "id:")
    {:type :id :value (str/trim (subs line 3))}

    (str/starts-with? line "retry:")
    {:type :retry :value (parse-long (str/trim (subs line 6)))}

    :else
    nil))

(defn- emit-event!
  "Emits an SSE event to the output channel if it has data."
  [out-ch event]
  (when (and (:data event) (not= (:data event) "[DONE]"))
    (try
      (let [parsed (json/parse-string (:data event) true)]
        (async/>!! out-ch {:type :data
                          :data parsed
                          :event (:event event)
                          :id (:id event)}))
      (catch Exception e
        (async/>!! out-ch {:type :error
                          :error {:type :parse-error
                                  :message (.getMessage e)
                                  :raw (:data event)}})))))

(defn- process-sse-stream
  "Processes an SSE input stream and sends events to the output channel."
  [input-stream out-ch]
  (async/thread
    (try
      (with-open [reader (BufferedReader. (InputStreamReader. input-stream "UTF-8"))]
        (loop [current-event {}]
          (if-let [line (.readLine reader)]
            (if-let [parsed (parse-sse-line line)]
              (case (:type parsed)
                :dispatch
                (do
                  (emit-event! out-ch current-event)
                  (recur {}))

                :data
                (let [data (:value parsed)
                      existing-data (:data current-event)]
                  (recur (assoc current-event :data
                                (if existing-data
                                  (str existing-data "\n" data)
                                  data))))

                :event
                (recur (assoc current-event :event (:value parsed)))

                :id
                (recur (assoc current-event :id (:value parsed)))

                :retry
                (recur (assoc current-event :retry (:value parsed)))

                :comment
                (recur current-event)

                ;; Unknown type, skip
                (recur current-event))
              ;; Unparseable line, skip
              (recur current-event))
            ;; End of stream
            (do
              (emit-event! out-ch current-event)
              (async/>!! out-ch {:type :done})))))
      (catch SocketTimeoutException _
        (async/>!! out-ch {:type :error :error {:type :timeout}}))
      (catch Exception e
        (async/>!! out-ch {:type :error :error {:type :stream-error
                                                :message (.getMessage e)}}))
      (finally
        (async/close! out-ch)))))

;; -----------------------------------------------------------------------------
;; Streaming API
;; -----------------------------------------------------------------------------

(defn stream-request
  "Makes a streaming HTTP request to the API.

   Returns a core.async channel that emits events:
     {:type :data, :data <parsed-json>, :event <event-type>, :id <event-id>}
     {:type :error, :error {:type :keyword, :message \"...\"}}
     {:type :done}

   The channel closes when the stream ends or on error."
  ([client method path body]
   (stream-request client method path body {}))
  ([client method path body opts]
   (let [config (:config client)
         {:keys [base-url api-key auth-mode default-headers timeout-ms]} config
         effective-timeout (or (:timeout-ms opts) timeout-ms)
         url (str base-url path)
         headers (cond-> (merge default-headers
                                {"Accept" "text/event-stream"
                                 "Cache-Control" "no-cache"})
                   (and api-key (= auth-mode :bearer))
                   (assoc "Authorization" (str "Bearer " api-key))

                   (and api-key (= auth-mode :basic))
                   (assoc "Authorization" (str "Basic " api-key))

                   (and api-key (= auth-mode :api-key))
                   (assoc "X-Api-Key" api-key))
         out-ch (async/chan 100)]

     (async/thread
       (try
         (let [response (http/request
                          {:method method
                           :url url
                           :headers headers
                           :body (when body (json/generate-string body))
                           :socket-timeout effective-timeout
                           :connection-timeout 10000
                           :as :stream
                           :throw-exceptions false})]
           (if (< (:status response) 400)
             (process-sse-stream (:body response) out-ch)
             (do
               (async/>!! out-ch {:type :error
                                  :error {:type :api-error
                                          :status (:status response)
                                          :body (slurp (:body response))}})
               (async/close! out-ch))))
         (catch Exception e
           (async/>!! out-ch {:type :error
                              :error {:type :connection-error
                                      :message (.getMessage e)}})
           (async/close! out-ch))))

     out-ch)))

(defn collect-stream
  "Collects all data events from a stream into a vector.

   Returns a vector of parsed data items.
   Blocks until the stream completes.
   Throws on error."
  [events-ch]
  (loop [items []]
    (if-let [event (async/<!! events-ch)]
      (case (:type event)
        :data (recur (conj items (:data event)))
        :error (throw (ex-info "Stream error"
                               {:type :stream-error
                                :error (:error event)}))
        :done items
        (recur items))
      items)))

(defn stream->lazy-seq
  "Converts a stream channel to a lazy sequence of data items.

   Use with care - the channel will remain open until the sequence is
   fully consumed or the channel is explicitly closed."
  [events-ch]
  (lazy-seq
    (when-let [event (async/<!! events-ch)]
      (case (:type event)
        :data (cons (:data event) (stream->lazy-seq events-ch))
        :error (throw (ex-info "Stream error"
                               {:type :stream-error
                                :error (:error event)}))
        :done nil
        (stream->lazy-seq events-ch)))))

(defn transduce-stream
  "Applies a transducer to a stream, returning a channel of transformed data.

   Example:
     (transduce-stream (map :content) events-ch)"
  [xf events-ch]
  (let [out-ch (async/chan 100 xf)]
    (async/go-loop []
      (if-let [event (async/<! events-ch)]
        (do
          (when (= :data (:type event))
            (async/>! out-ch (:data event)))
          (when (= :error (:type event))
            (async/close! out-ch))
          (when-not (= :done (:type event))
            (recur)))
        (async/close! out-ch)))
    out-ch))
{{else}}
;; -----------------------------------------------------------------------------
;; Streaming Support (Disabled)
;; -----------------------------------------------------------------------------

;; Streaming support is not enabled for this SDK.
;; To enable, add methods with Stream configuration to the contract.

(defn stream-request
  "Streaming is not enabled for this SDK."
  [& _]
  (throw (ex-info "Streaming not supported"
                  {:type :unsupported-operation})))

(defn collect-stream
  "Streaming is not enabled for this SDK."
  [& _]
  (throw (ex-info "Streaming not supported"
                  {:type :unsupported-operation})))
{{end}}
{{end}}