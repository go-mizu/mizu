{{define "types.clj.tmpl"}};; Code generated by sdkclojure. DO NOT EDIT.

(ns {{.Namespace}}.types
  "Type definitions and coercion functions for {{.Service.Name}} SDK."
  (:require [cheshire.core :as json]
            [cheshire.generate :as json-gen]
            [clojure.walk :as walk])
{{- if .HasDate}}
  (:import [java.time Instant]
           [java.time.format DateTimeFormatter])
{{- end}})

;; -----------------------------------------------------------------------------
;; JSON Encoding Extensions
;; -----------------------------------------------------------------------------
{{if .HasDate}}

;; Custom JSON encoder for java.time.Instant
(json-gen/add-encoder Instant
  (fn [^Instant d ^com.fasterxml.jackson.core.JsonGenerator jg]
    (.writeString jg (.toString d))))
{{end}}

;; -----------------------------------------------------------------------------
;; Key Transformation
;; -----------------------------------------------------------------------------

(defn- camel->kebab
  "Converts camelCase string to kebab-case keyword."
  [s]
  (-> s
      (clojure.string/replace #"([a-z])([A-Z])" "$1-$2")
      (clojure.string/replace #"_" "-")
      clojure.string/lower-case
      keyword))

(defn- kebab->camel
  "Converts kebab-case keyword to camelCase string."
  [k]
  (let [s (name k)
        parts (clojure.string/split s #"-")]
    (apply str (first parts)
           (map clojure.string/capitalize (rest parts)))))

(defn transform-keys
  "Transforms all map keys in nested data structure."
  [f m]
  (walk/postwalk
    (fn [x]
      (if (map? x)
        (into {} (map (fn [[k v]] [(f k) v]) x))
        x))
    m))

(defn keywordize-response
  "Transforms response map keys from camelCase to kebab-case keywords."
  [m]
  (transform-keys
    (fn [k]
      (if (string? k)
        (camel->kebab k)
        k))
    m))

(defn stringify-request
  "Transforms request map keys from kebab-case keywords to camelCase strings."
  [m]
  (transform-keys
    (fn [k]
      (if (keyword? k)
        (kebab->camel k)
        k))
    m))

;; -----------------------------------------------------------------------------
;; Record Definitions
;; -----------------------------------------------------------------------------
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

{{- if $type.Description}}
;; {{$type.Description}}
{{- end}}
(defrecord {{$type.RecordName}} [{{range $i, $f := $type.Fields}}{{if $i}} {{end}}{{$f.CljName}}{{end}}])
{{- end}}
{{- end}}

;; -----------------------------------------------------------------------------
;; Coercion Functions
;; -----------------------------------------------------------------------------
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

(defn ->{{$type.CljName}}
  "Coerces a map to a {{$type.RecordName}} record.
   Handles key transformation from camelCase to kebab-case.
{{- if $type.Description}}

   {{$type.Description}}
{{- end}}"
  [m]
  (when m
    (let [data (if (map? m) (keywordize-response m) m)]
      (map->{{$type.RecordName}}
        (cond-> data
{{- range $f := $type.Fields}}
{{- if eq $f.CljType "inst?"}}
          (string? ({{$f.CljKeyword}} data))
          (update {{$f.CljKeyword}} #(when % (Instant/parse %)))
{{- end}}
{{- end}})))))
{{- end}}

{{- if eq $type.Kind "slice"}}

(defn ->{{$type.CljName}}
  "Coerces a sequence to a {{$type.RecordName}} vector."
  [coll]
  (when coll
    (mapv ->{{kebab $type.Elem}} coll)))
{{- end}}

{{- if eq $type.Kind "union"}}

(defmulti ->{{$type.CljName}}
  "Coerces a map to the appropriate {{$type.RecordName}} variant.
   Dispatches on the :{{$type.Tag}} field.
{{- if $type.Description}}

   {{$type.Description}}
{{- end}}"
  (fn [m] (get m {{cljString $type.Tag}} (get m (keyword {{cljString $type.Tag}})))))
{{range $v := $type.Variants}}
(defmethod ->{{$type.CljName}} {{cljString $v.Value}} [m]
  (keywordize-response m))
{{end}}
(defmethod ->{{$type.CljName}} :default [m]
  (keywordize-response m))
{{- end}}
{{- end}}

;; -----------------------------------------------------------------------------
;; Response Coercion Helper
;; -----------------------------------------------------------------------------

(defn coerce-response
  "Coerces a raw response to the appropriate type based on structure."
  [response type-kw]
  (case type-kw
{{- range $type := .Types}}
{{- if eq $type.Kind "struct"}}
    :{{$type.CljName}} (->{{$type.CljName}} response)
{{- end}}
{{- if eq $type.Kind "union"}}
    :{{$type.CljName}} (->{{$type.CljName}} response)
{{- end}}
{{- end}}
    ;; Default: just keywordize keys
    (keywordize-response response)))
{{end}}