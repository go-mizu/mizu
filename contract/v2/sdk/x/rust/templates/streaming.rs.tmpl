{{define "streaming.rs.tmpl"}}// Code generated by sdkrust. DO NOT EDIT.

//! Server-Sent Events (SSE) streaming support.

use bytes::Bytes;
use futures_core::Stream;
use pin_project_lite::pin_project;
use std::collections::VecDeque;
use std::pin::Pin;
use std::task::{Context, Poll};

use crate::error::{Error, Result};

/// An SSE event.
#[derive(Debug, Clone, Default)]
pub struct SseEvent {
    /// Event type.
    pub event: Option<String>,
    /// Event data.
    pub data: Option<String>,
    /// Event ID.
    pub id: Option<String>,
    /// Retry interval in milliseconds.
    pub retry: Option<u64>,
}

/// SSE parser state.
#[derive(Debug, Default)]
struct SseParser {
    buffer: String,
}

impl SseParser {
    fn new() -> Self {
        Self::default()
    }

    /// Feed data to the parser and return complete events.
    fn feed(&mut self, data: &str) -> Vec<SseEvent> {
        self.buffer.push_str(data);
        let mut events = Vec::new();

        while let Some(pos) = self.buffer.find("\n\n") {
            let event_data = self.buffer[..pos].to_string();
            self.buffer = self.buffer[pos + 2..].to_string();

            if let Some(event) = self.parse_event(&event_data) {
                events.push(event);
            }
        }

        events
    }

    fn parse_event(&self, data: &str) -> Option<SseEvent> {
        let mut event = SseEvent::default();
        let mut has_data = false;

        for line in data.lines() {
            if line.is_empty() || line.starts_with(':') {
                continue;
            }

            let (field, value) = if let Some(pos) = line.find(':') {
                let field = &line[..pos];
                let value = line[pos + 1..].trim_start();
                (field, value)
            } else {
                (line, "")
            };

            match field {
                "event" => event.event = Some(value.to_string()),
                "data" => {
                    if let Some(ref mut existing) = event.data {
                        existing.push('\n');
                        existing.push_str(value);
                    } else {
                        event.data = Some(value.to_string());
                    }
                    has_data = true;
                }
                "id" => event.id = Some(value.to_string()),
                "retry" => event.retry = value.parse().ok(),
                _ => {}
            }
        }

        if has_data {
            Some(event)
        } else {
            None
        }
    }
}

pin_project! {
    /// A stream of typed events from an SSE endpoint.
    pub struct EventStream<T, S> {
        #[pin]
        inner: S,
        parser: SseParser,
        pending: VecDeque<Result<T>>,
        _marker: std::marker::PhantomData<T>,
    }
}

impl<T, S> EventStream<T, S>
where
    T: serde::de::DeserializeOwned + Send + 'static,
    S: Stream<Item = std::result::Result<Bytes, reqwest::Error>> + Send + 'static,
{
    /// Creates a new event stream from a byte stream.
    pub fn new(inner: S) -> Pin<Box<dyn Stream<Item = Result<T>> + Send>> {
        Box::pin(Self {
            inner,
            parser: SseParser::new(),
            pending: VecDeque::new(),
            _marker: std::marker::PhantomData,
        })
    }
}

impl<T, S> Stream for EventStream<T, S>
where
    T: serde::de::DeserializeOwned + Unpin,
    S: Stream<Item = std::result::Result<Bytes, reqwest::Error>> + Unpin,
{
    type Item = Result<T>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let this = self.project();

        // Return pending events first
        if let Some(event) = this.pending.pop_front() {
            return Poll::Ready(Some(event));
        }

        // Poll for more data
        loop {
            match this.inner.poll_next(cx) {
                Poll::Ready(Some(Ok(bytes))) => {
                    let data = String::from_utf8_lossy(&bytes);
                    let events = this.parser.feed(&data);

                    for sse_event in events {
                        if let Some(data) = sse_event.data {
                            // Skip [DONE] marker
                            if data == "[DONE]" {
                                continue;
                            }

                            match serde_json::from_str(&data) {
                                Ok(parsed) => this.pending.push_back(Ok(parsed)),
                                Err(e) => {
                                    this.pending.push_back(Err(Error::Deserialization(e)));
                                }
                            }
                        }
                    }

                    if let Some(event) = this.pending.pop_front() {
                        return Poll::Ready(Some(event));
                    }
                }
                Poll::Ready(Some(Err(e))) => {
                    return Poll::Ready(Some(Err(Error::Connection(e))));
                }
                Poll::Ready(None) => {
                    return if let Some(event) = this.pending.pop_front() {
                        Poll::Ready(Some(event))
                    } else {
                        Poll::Ready(None)
                    };
                }
                Poll::Pending => return Poll::Pending,
            }
        }
    }
}
{{end}}
