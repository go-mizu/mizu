{{define "types.rs.tmpl"}}// Code generated by sdkrust. DO NOT EDIT.

//! Type definitions for the {{.Service.Name}} API.

use serde::{Deserialize, Serialize};
{{- if .HasDate}}
use chrono::{DateTime, Utc};
{{- end}}

// MARK: - Generated Types
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}
{{- if $type.Description}}
/// {{$type.Description}}
{{- end}}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct {{$type.RustName}} {
{{- if not $type.Fields}}
    // Empty struct - acts as a marker type
    #[serde(skip)]
    _private: (),
{{- else}}
{{- range $field := $type.Fields}}
{{- if $field.Description}}
    /// {{$field.Description}}
{{- end}}
{{- if $field.Enum}}
    #[serde(rename = {{rustString $field.JSONName}})]
    {{- if or $field.Optional $field.Nullable}}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub {{$field.RustName}}: Option<{{$type.RustName}}{{$field.RustName | pascal}}>,
    {{- else}}
    pub {{$field.RustName}}: {{$type.RustName}}{{$field.RustName | pascal}},
    {{- end}}
{{- else}}
    #[serde(rename = {{rustString $field.JSONName}})]
    {{- if or $field.Optional $field.Nullable}}
    #[serde(skip_serializing_if = "Option::is_none")]
    {{- end}}
    pub {{$field.RustName}}: {{$field.RustType}},
{{- end}}
{{- end}}
{{- end}}
}

{{- if $type.Fields}}
impl {{$type.RustName}} {
    /// Creates a new builder for this type.
    #[must_use]
    pub fn builder() -> {{$type.RustName}}Builder {
        {{$type.RustName}}Builder::default()
    }
}

/// Builder for [`{{$type.RustName}}`].
#[derive(Debug, Clone, Default)]
pub struct {{$type.RustName}}Builder {
{{- range $field := $type.Fields}}
    {{$field.RustName}}: {{if $field.Enum}}Option<{{$type.RustName}}{{$field.RustName | pascal}}>{{else if or $field.Optional $field.Nullable}}{{$field.RustType}}{{else}}Option<{{$field.RustTypeRaw}}>{{end}},
{{- end}}
}

impl {{$type.RustName}}Builder {
{{- range $field := $type.Fields}}
    /// Sets the `{{$field.RustName}}` field.
    #[must_use]
    {{- if $field.Enum}}
    pub fn {{$field.RustName}}(mut self, value: {{$type.RustName}}{{$field.RustName | pascal}}) -> Self {
        self.{{$field.RustName}} = Some(value);
        self
    }
    {{- else if or $field.Optional $field.Nullable}}
    pub fn {{$field.RustName}}(mut self, value: impl Into<{{$field.RustTypeRaw}}>) -> Self {
        self.{{$field.RustName}} = Some(value.into());
        self
    }
    {{- else}}
    pub fn {{$field.RustName}}(mut self, value: impl Into<{{$field.RustTypeRaw}}>) -> Self {
        self.{{$field.RustName}} = Some(value.into());
        self
    }
    {{- end}}
{{- end}}

    /// Builds the [`{{$type.RustName}}`].
    ///
    /// # Panics
    ///
    /// Panics if required fields are not set.
    #[must_use]
    pub fn build(self) -> {{$type.RustName}} {
        {{$type.RustName}} {
{{- range $field := $type.Fields}}
    {{- if $field.Enum}}
            {{$field.RustName}}: {{if or $field.Optional $field.Nullable}}self.{{$field.RustName}}{{else}}self.{{$field.RustName}}.expect("{{$field.Name}} is required"){{end}},
    {{- else if or $field.Optional $field.Nullable}}
            {{$field.RustName}}: self.{{$field.RustName}},
    {{- else}}
            {{$field.RustName}}: self.{{$field.RustName}}.expect("{{$field.Name}} is required"),
    {{- end}}
{{- end}}
        }
    }

    /// Tries to build the [`{{$type.RustName}}`].
    ///
    /// # Errors
    ///
    /// Returns an error if required fields are not set.
    pub fn try_build(self) -> std::result::Result<{{$type.RustName}}, &'static str> {
        Ok({{$type.RustName}} {
{{- range $field := $type.Fields}}
    {{- if $field.Enum}}
            {{$field.RustName}}: {{if or $field.Optional $field.Nullable}}self.{{$field.RustName}}{{else}}self.{{$field.RustName}}.ok_or("{{$field.Name}} is required")?{{end}},
    {{- else if or $field.Optional $field.Nullable}}
            {{$field.RustName}}: self.{{$field.RustName}},
    {{- else}}
            {{$field.RustName}}: self.{{$field.RustName}}.ok_or("{{$field.Name}} is required")?,
    {{- end}}
{{- end}}
        })
    }
}
{{- end}}

{{- range $field := $type.Fields}}
{{- if $field.Enum}}

/// Valid values for [`{{$type.RustName}}::{{$field.RustName}}`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum {{$type.RustName}}{{$field.RustName | pascal}} {
{{- range $e := $field.Enum}}
    /// `{{$e.Value}}`
    #[serde(rename = {{rustString $e.Value}})]
    {{$e.Name}},
{{- end}}
}

impl {{$type.RustName}}{{$field.RustName | pascal}} {
    /// Returns the string representation of this variant.
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
{{- range $e := $field.Enum}}
            Self::{{$e.Name}} => {{rustString $e.Value}},
{{- end}}
        }
    }
}

impl std::fmt::Display for {{$type.RustName}}{{$field.RustName | pascal}} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(self.as_str())
    }
}

impl std::str::FromStr for {{$type.RustName}}{{$field.RustName | pascal}} {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
{{- range $e := $field.Enum}}
            {{rustString $e.Value}} => Ok(Self::{{$e.Name}}),
{{- end}}
            _ => Err(format!("unknown variant: {s}")),
        }
    }
}
{{- end}}
{{- end}}
{{- end}}

{{- if eq $type.Kind "slice"}}
{{- if $type.Description}}
/// {{$type.Description}}
{{- end}}
pub type {{$type.RustName}} = Vec<{{$type.Elem}}>;
{{- end}}

{{- if eq $type.Kind "map"}}
{{- if $type.Description}}
/// {{$type.Description}}
{{- end}}
pub type {{$type.RustName}} = std::collections::HashMap<String, {{$type.Elem}}>;
{{- end}}

{{- if eq $type.Kind "union"}}
{{- if $type.Description}}
/// {{$type.Description}}
{{- end}}
///
/// Discriminated union (tag: "{{$type.Tag}}").
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = {{rustString $type.Tag}})]
pub enum {{$type.RustName}} {
{{- range $v := $type.Variants}}
{{- if $v.Description}}
    /// {{$v.Description}}
{{- end}}
    #[serde(rename = {{rustString $v.Value}})]
    {{$v.RustName}}({{$v.Type | pascal}}),
{{- end}}
}

impl {{$type.RustName}} {
{{- range $v := $type.Variants}}
    /// Returns `true` if this is the `{{$v.RustName}}` variant.
    #[must_use]
    pub const fn is_{{$v.Value | snake}}(&self) -> bool {
        matches!(self, Self::{{$v.RustName}}(_))
    }

    /// Returns the inner value if this is the `{{$v.RustName}}` variant.
    #[must_use]
    pub fn as_{{$v.Value | snake}}(&self) -> Option<&{{$v.Type | pascal}}> {
        match self {
            Self::{{$v.RustName}}(inner) => Some(inner),
            _ => None,
        }
    }

    /// Converts to the inner value if this is the `{{$v.RustName}}` variant.
    #[must_use]
    pub fn into_{{$v.Value | snake}}(self) -> Option<{{$v.Type | pascal}}> {
        match self {
            Self::{{$v.RustName}}(inner) => Some(inner),
            _ => None,
        }
    }
{{- end}}
}
{{- end}}
{{end}}
{{end}}
