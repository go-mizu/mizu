{{define "resources.rs.tmpl"}}// Code generated by sdkrust. DO NOT EDIT.

//! Resource operations for the {{.Service.Name}} API.

use crate::client::Client;
use crate::error::{Error, Result};
use crate::types::*;
{{- if .HasSSE}}
use crate::streaming::EventStream;
use futures_core::Stream;
use std::pin::Pin;
{{- end}}

{{range $r := .Resources}}
/// Operations for the {{$r.Name}} resource.
{{- if $r.Description}}
///
/// {{$r.Description}}
{{- end}}
#[derive(Debug, Clone)]
pub struct {{$r.StructName}} {
    client: Client,
}

impl {{$r.StructName}} {
    /// Creates a new resource accessor.
    pub(crate) fn new(client: Client) -> Self {
        Self { client }
    }

{{- range $m := $r.Methods}}

{{- if $m.Description}}
    /// {{$m.Description}}
{{- else}}
    /// Calls the {{$m.Name}} method.
{{- end}}
    ///
    /// # Errors
    ///
    /// Returns an error if the request fails.
{{- if $m.IsStreaming}}
    pub async fn {{$m.RustName}}(
        &self,
{{- if $m.HasInput}}
        request: &{{$m.InputType}},
{{- end}}
    ) -> Result<Pin<Box<dyn Stream<Item = Result<{{$m.StreamItemType}}>> + Send>>> {
        let url = format!("{}{{$m.HTTPPath}}", self.client.base_url());

        let response = self
            .client
            .http()
            .{{$m.HTTPMethod | lower}}(&url)
{{- if $m.HasInput}}
            .json(request)
{{- end}}
            .header("accept", "text/event-stream")
            .send()
            .await
            .map_err(Error::Connection)?;

        if !response.status().is_success() {
            let status = response.status().as_u16();
            let body = response.text().await.ok();
            return Err(Error::Http { status, body });
        }

        Ok(EventStream::new(response.bytes_stream()))
    }
{{- else if $m.HasOutput}}
    pub async fn {{$m.RustName}}(
        &self,
{{- if $m.HasInput}}
        request: &{{$m.InputType}},
{{- end}}
    ) -> Result<{{$m.OutputType}}> {
        let url = format!("{}{{$m.HTTPPath}}", self.client.base_url());

        let mut last_error = None;
        let max_retries = self.client.config().max_retries;

        for attempt in 0..=max_retries {
            if attempt > 0 {
                // Exponential backoff with jitter
                let delay_ms = (500u64 << (attempt - 1)) + (rand_u64() % 100);
                tokio::time::sleep(std::time::Duration::from_millis(delay_ms)).await;
            }

            match self.do_{{$m.RustName}}_request(&url{{if $m.HasInput}}, request{{end}}).await {
                Ok(response) => return Ok(response),
                Err(e) if e.is_retriable() && attempt < max_retries => {
                    last_error = Some(e);
                    continue;
                }
                Err(e) => return Err(e),
            }
        }

        Err(last_error.unwrap_or_else(|| Error::Connection(
            reqwest::Error::from(std::io::Error::new(
                std::io::ErrorKind::Other,
                "max retries exceeded",
            ))
        )))
    }

    async fn do_{{$m.RustName}}_request(
        &self,
        url: &str,
{{- if $m.HasInput}}
        request: &{{$m.InputType}},
{{- end}}
    ) -> Result<{{$m.OutputType}}> {
        let response = self
            .client
            .http()
            .{{$m.HTTPMethod | lower}}(url)
{{- if $m.HasInput}}
            .json(request)
{{- end}}
            .send()
            .await
            .map_err(Error::Connection)?;

        let status = response.status();
        if !status.is_success() {
            let body = response.text().await.ok();
            return Err(Error::Http {
                status: status.as_u16(),
                body,
            });
        }

        response
            .json()
            .await
            .map_err(Error::Deserialization)
    }
{{- else}}
    pub async fn {{$m.RustName}}(
        &self,
{{- if $m.HasInput}}
        request: &{{$m.InputType}},
{{- end}}
    ) -> Result<()> {
        let url = format!("{}{{$m.HTTPPath}}", self.client.base_url());

        let mut last_error = None;
        let max_retries = self.client.config().max_retries;

        for attempt in 0..=max_retries {
            if attempt > 0 {
                let delay_ms = (500u64 << (attempt - 1)) + (rand_u64() % 100);
                tokio::time::sleep(std::time::Duration::from_millis(delay_ms)).await;
            }

            match self.do_{{$m.RustName}}_request(&url{{if $m.HasInput}}, request{{end}}).await {
                Ok(()) => return Ok(()),
                Err(e) if e.is_retriable() && attempt < max_retries => {
                    last_error = Some(e);
                    continue;
                }
                Err(e) => return Err(e),
            }
        }

        Err(last_error.unwrap_or_else(|| Error::Connection(
            reqwest::Error::from(std::io::Error::new(
                std::io::ErrorKind::Other,
                "max retries exceeded",
            ))
        )))
    }

    async fn do_{{$m.RustName}}_request(
        &self,
        url: &str,
{{- if $m.HasInput}}
        request: &{{$m.InputType}},
{{- end}}
    ) -> Result<()> {
        let response = self
            .client
            .http()
            .{{$m.HTTPMethod | lower}}(url)
{{- if $m.HasInput}}
            .json(request)
{{- end}}
            .send()
            .await
            .map_err(Error::Connection)?;

        let status = response.status();
        if !status.is_success() {
            let body = response.text().await.ok();
            return Err(Error::Http {
                status: status.as_u16(),
                body,
            });
        }

        Ok(())
    }
{{- end}}
{{- end}}
}
{{end}}

// Simple pseudo-random number for jitter (not cryptographically secure)
fn rand_u64() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_nanos() as u64)
        .unwrap_or(0)
        ^ 0x5555555555555555
}
{{end}}
