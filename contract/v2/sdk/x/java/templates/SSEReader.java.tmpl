{{define "SSEReader.java.tmpl"}}// Code generated by sdkjava. DO NOT EDIT.

package {{.Package}}.internal;

import {{.Package}}.exception.DecodingException;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * Reads Server-Sent Events from an HTTP response stream.
 *
 * <p>This class implements both {@link Iterator} and {@link AutoCloseable}.
 * The underlying connection is closed when the iterator is exhausted or when
 * {@link #close()} is called.
 *
 * <p>This class is NOT thread-safe.
 *
 * @param <T> the type of events to read
 */
public final class SSEReader<T> implements Iterator<T>, AutoCloseable {

    private final BufferedReader reader;
    private final ObjectMapper mapper;
    private final Class<T> itemType;
    private T next;
    private boolean done;

    /**
     * Creates a new SSE reader.
     *
     * @param inputStream the input stream to read from
     * @param mapper the ObjectMapper for JSON deserialization
     * @param itemType the class of items to deserialize
     */
    public SSEReader(InputStream inputStream, ObjectMapper mapper, Class<T> itemType) {
        this.reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        this.mapper = mapper;
        this.itemType = itemType;
    }

    @Override
    public boolean hasNext() {
        if (done) {
            return false;
        }
        if (next != null) {
            return true;
        }

        try {
            next = readNext();
            return next != null;
        } catch (IOException e) {
            throw new UncheckedIOException("Error reading SSE stream", e);
        }
    }

    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException("No more events in stream");
        }
        T result = next;
        next = null;
        return result;
    }

    private T readNext() throws IOException {
        StringBuilder data = new StringBuilder();
        String line;

        while ((line = reader.readLine()) != null) {
            if (line.isEmpty()) {
                // Empty line marks end of event
                String content = data.toString().trim();
                data.setLength(0);

                if (content.isEmpty()) {
                    // Skip empty events
                    continue;
                }

                if (content.equals("[DONE]")) {
                    // End of stream marker
                    done = true;
                    return null;
                }

                try {
                    return mapper.readValue(content, itemType);
                } catch (Exception e) {
                    throw new DecodingException("Failed to decode SSE event: " + content, e);
                }
            } else if (line.startsWith("data:")) {
                // Extract data field content
                String content = line.substring(5);
                if (!content.isEmpty() && content.charAt(0) == ' ') {
                    content = content.substring(1);
                }
                if (data.length() > 0) {
                    data.append("\n");
                }
                data.append(content);
            }
            // Ignore other SSE fields: event:, id:, retry:, comments (lines starting with :)
        }

        // Stream closed
        done = true;
        return null;
    }

    @Override
    public void close() {
        done = true;
        try {
            reader.close();
        } catch (IOException ignored) {
            // Ignore close errors
        }
    }
}
{{end}}
