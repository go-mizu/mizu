{{define "Resources.java.tmpl"}}// Code generated by sdkjava. DO NOT EDIT.

package {{.Package}}.resource;

import {{.Package}}.internal.HttpClientWrapper;
import {{.Package}}.model.*;
import {{.Package}}.exception.*;

import java.util.Iterator;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

// MARK: - Resources
{{range $resource := .Resources}}

/**
{{- if $resource.Description}}
 * {{$resource.Description}}
{{- else}}
 * Operations for {{$resource.Name}}.
{{- end}}
 */
public final class {{$resource.ClassName}} {

    private final HttpClientWrapper client;

    public {{$resource.ClassName}}(HttpClientWrapper client) {
        this.client = client;
    }
{{range $method := $resource.Methods}}
{{- if $method.IsStreaming}}

{{- if $method.Description}}
    /**
     * {{$method.Description}}
     *
{{- if $method.HasInput}}
     * @param request the request parameters
{{- end}}
     * @return an Iterator over streamed items
     * @throws SDKException if an error occurs
     */
{{- end}}
{{- if $method.HasInput}}
    public Iterator<{{$method.StreamItemType}}> {{$method.JavaName}}({{$method.InputType}} request) {
        return client.stream(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            request,
            {{$method.StreamItemType}}.class
        );
    }
{{- else}}
    public Iterator<{{$method.StreamItemType}}> {{$method.JavaName}}() {
        return client.stream(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            null,
            {{$method.StreamItemType}}.class
        );
    }
{{- end}}

    /**
     * Stream version of {@link #{{$method.JavaName}}}.
     *
     * <p>The returned stream should be closed after use, or used with try-with-resources.
     *
{{- if $method.HasInput}}
     * @param request the request parameters
{{- end}}
     * @return a Stream over streamed items
     * @throws SDKException if an error occurs
     */
{{- if $method.HasInput}}
    public Stream<{{$method.StreamItemType}}> {{$method.JavaName}}Stream({{$method.InputType}} request) {
        Iterator<{{$method.StreamItemType}}> iterator = {{$method.JavaName}}(request);
{{- else}}
    public Stream<{{$method.StreamItemType}}> {{$method.JavaName}}Stream() {
        Iterator<{{$method.StreamItemType}}> iterator = {{$method.JavaName}}();
{{- end}}
        return StreamSupport.stream(
            Spliterators.spliteratorUnknownSize(iterator, Spliterator.ORDERED),
            false
        ).onClose(() -> {
            if (iterator instanceof AutoCloseable) {
                try {
                    ((AutoCloseable) iterator).close();
                } catch (Exception ignored) {}
            }
        });
    }
{{- else}}

{{- if $method.Description}}
    /**
     * {{$method.Description}}
     *
{{- if $method.HasInput}}
     * @param request the request parameters
{{- end}}
{{- if $method.HasOutput}}
     * @return a CompletableFuture containing the response
{{- else}}
     * @return a CompletableFuture that completes when the request is done
{{- end}}
     * @throws SDKException if an error occurs
     */
{{- end}}
{{- if $method.HasInput}}
{{- if $method.HasOutput}}
    public CompletableFuture<{{$method.OutputType}}> {{$method.JavaName}}({{$method.InputType}} request) {
        return client.requestAsync(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            request,
            {{$method.OutputType}}.class
        );
    }
{{- else}}
    public CompletableFuture<Void> {{$method.JavaName}}({{$method.InputType}} request) {
        return client.requestAsyncVoid(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            request
        );
    }
{{- end}}
{{- else}}
{{- if $method.HasOutput}}
    public CompletableFuture<{{$method.OutputType}}> {{$method.JavaName}}() {
        return client.requestAsync(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            null,
            {{$method.OutputType}}.class
        );
    }
{{- else}}
    public CompletableFuture<Void> {{$method.JavaName}}() {
        return client.requestAsyncVoid(
            "{{$method.HTTPMethod}}",
            {{javaString $method.HTTPPath}},
            null
        );
    }
{{- end}}
{{- end}}

    /**
     * Synchronous version of {@link #{{$method.JavaName}}}.
     *
{{- if $method.HasInput}}
     * @param request the request parameters
{{- end}}
{{- if $method.HasOutput}}
     * @return the response
{{- end}}
     * @throws SDKException if an error occurs
     */
{{- if $method.HasInput}}
{{- if $method.HasOutput}}
    public {{$method.OutputType}} {{$method.JavaName}}Sync({{$method.InputType}} request) {
        return {{$method.JavaName}}(request).join();
    }
{{- else}}
    public void {{$method.JavaName}}Sync({{$method.InputType}} request) {
        {{$method.JavaName}}(request).join();
    }
{{- end}}
{{- else}}
{{- if $method.HasOutput}}
    public {{$method.OutputType}} {{$method.JavaName}}Sync() {
        return {{$method.JavaName}}().join();
    }
{{- else}}
    public void {{$method.JavaName}}Sync() {
        {{$method.JavaName}}().join();
    }
{{- end}}
{{- end}}
{{- end}}
{{end}}
}
{{end}}
{{end}}
