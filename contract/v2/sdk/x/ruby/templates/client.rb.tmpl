{{define "client.rb.tmpl"}}# frozen_string_literal: true

# Code generated by sdkruby. DO NOT EDIT.

require "faraday"
require "faraday/retry"
require "json"

module {{.ModuleName}}
  # Configuration options for the SDK client.
  class Configuration
    # @return [String, nil] API key for authentication
    attr_accessor :api_key

    # @return [String] Base URL for API requests
    attr_accessor :base_url

    # @return [Integer] Request timeout in seconds
    attr_accessor :timeout

    # @return [Integer] Maximum number of retry attempts
    attr_accessor :max_retries

    # @return [Hash{String => String}] Default headers for all requests
    attr_accessor :default_headers

    # @return [Symbol] Authentication mode (:bearer, :basic, :header, :none)
    attr_accessor :auth_mode

    # @return [Logger, nil] Logger instance for request logging
    attr_accessor :logger

    def initialize
      @api_key = nil
      @base_url = {{rubyQuote .Client.BaseURL}}
      @timeout = 60
      @max_retries = 2
      @default_headers = {
{{- range .Client.Headers}}
        {{rubyQuote .K}} => {{rubyQuote .V}},
{{- end}}
      }
      @auth_mode = :bearer
      @logger = nil
    end

    # @return [Hash] Configuration as a hash
    def to_h
      {
        api_key: @api_key,
        base_url: @base_url,
        timeout: @timeout,
        max_retries: @max_retries,
        default_headers: @default_headers.dup,
        auth_mode: @auth_mode,
        logger: @logger
      }
    end
  end

  # The main SDK client providing access to all API resources.
  #
{{- if .Service.Description}}
  # {{.Service.Description}}
{{- end}}
  #
  # @example Create a client with API key
  #   client = {{.ModuleName}}::Client.new(api_key: "your-api-key")
  #
  # @example Create a client with block configuration
  #   client = {{.ModuleName}}::Client.new do |config|
  #     config.api_key = ENV["API_KEY"]
  #     config.timeout = 120
  #   end
  class Client
{{- if .HasSSE}}
    include Streaming
{{- end}}

    # @return [Configuration] Client configuration
    attr_reader :config

{{- range .Resources}}
    # @return [{{.ClassName}}] Access to {{.Name}} operations
    attr_reader :{{.RubyName}}
{{- end}}

    # Creates a new SDK client.
    #
    # @param api_key [String, nil] API key for authentication
    # @param base_url [String, nil] Override base URL
    # @param timeout [Integer, nil] Request timeout in seconds
    # @param max_retries [Integer, nil] Maximum retry attempts
    # @param options [Hash] Additional configuration options
    # @yield [config] Optional configuration block
    # @yieldparam config [Configuration] The configuration instance
    def initialize(api_key: nil, base_url: nil, timeout: nil, max_retries: nil, **options)
      @config = {{.ModuleName}}.configuration&.dup || Configuration.new
      @config.api_key = api_key if api_key
      @config.base_url = base_url if base_url
      @config.timeout = timeout if timeout
      @config.max_retries = max_retries if max_retries

      options.each do |key, value|
        @config.send("#{key}=", value) if @config.respond_to?("#{key}=")
      end

      yield @config if block_given?

      @connection = build_connection

      # Initialize resources
{{- range .Resources}}
      @{{.RubyName}} = {{.ClassName}}.new(self)
{{- end}}
    end

    # Creates a new client with modified configuration.
    #
    # @param options [Hash] Configuration options to override
    # @yield [config] Optional configuration block
    # @return [Client] A new client instance
    def with(**options, &block)
      new_options = @config.to_h.merge(options)
      self.class.new(**new_options, &block)
    end

    # Performs an HTTP request.
    #
    # @api private
    # @param method [Symbol] HTTP method (:get, :post, :put, :patch, :delete)
    # @param path [String] Request path
    # @param body [Hash, nil] Request body
    # @param headers [Hash] Additional headers
    # @return [Hash, nil] Parsed response body
    # @raise [APIError] if the request fails
    def request(method:, path:, body: nil, headers: {})
      response = @connection.run_request(method, path, body&.to_json, build_headers(headers))
      handle_response(response)
    rescue Faraday::ConnectionFailed => e
      raise ConnectionError, "Connection failed: #{e.message}"
    rescue Faraday::TimeoutError => e
      raise TimeoutError, "Request timed out: #{e.message}"
    end

    private

    def build_connection
      Faraday.new(url: @config.base_url) do |conn|
        # Retry middleware with exponential backoff
        conn.request :retry,
                     max: @config.max_retries,
                     interval: 0.5,
                     interval_randomness: 0.5,
                     backoff_factor: 2,
                     exceptions: [
                       Faraday::ConnectionFailed,
                       Faraday::TimeoutError,
                       Timeout::Error
                     ],
                     retry_statuses: [429, 500, 502, 503, 504]

        # Logger middleware
        conn.response :logger, @config.logger, bodies: true if @config.logger

        # Timeouts
        conn.options.timeout = @config.timeout
        conn.options.open_timeout = 10

        # Adapter
        conn.adapter Faraday.default_adapter
      end
    end

    def build_headers(extra = {})
      headers = {
        "Content-Type" => "application/json",
        "Accept" => "application/json"
      }
      headers.merge!(@config.default_headers)
      apply_auth(headers)
      headers.merge!(extra)
      headers
    end

    def apply_auth(headers)
      return unless @config.api_key

      case @config.auth_mode
      when :bearer
        headers["Authorization"] = "Bearer #{@config.api_key}"
      when :basic
        require "base64"
        headers["Authorization"] = "Basic #{Base64.strict_encode64(@config.api_key)}"
      when :header
        headers["X-API-Key"] = @config.api_key
      end
    end

    def handle_response(response)
      raise_api_error(response) if response.status >= 400

      return nil if response.status == 204
      return nil if response.body.nil? || response.body.empty?

      JSON.parse(response.body, symbolize_names: true)
    end

    def raise_api_error(response)
      body = begin
        JSON.parse(response.body, symbolize_names: true)
      rescue StandardError
        response.body
      end

      message = if body.is_a?(Hash)
                  body[:message] || body[:error] || "HTTP #{response.status}"
                else
                  response.body || "HTTP #{response.status}"
                end

      case response.status
      when 400
        raise BadRequestError.new(message, response.status, body)
      when 401
        raise AuthenticationError.new(message, response.status, body)
      when 403
        raise PermissionDeniedError.new(message, response.status, body)
      when 404
        raise NotFoundError.new(message, response.status, body)
      when 422
        raise UnprocessableEntityError.new(message, response.status, body)
      when 429
        retry_after = response.headers["retry-after"]&.to_i
        raise RateLimitError.new(message, response.status, body, retry_after: retry_after)
      when 500..599
        raise InternalServerError.new(message, response.status, body)
      else
        raise APIError.new(message, response.status, body)
      end
    end
  end
end
{{end}}
