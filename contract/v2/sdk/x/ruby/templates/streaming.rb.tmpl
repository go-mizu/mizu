{{define "streaming.rb.tmpl"}}# frozen_string_literal: true

# Code generated by sdkruby. DO NOT EDIT.

require "json"

module {{.ModuleName}}
  # SSE streaming support for the SDK client.
  #
  # Provides methods for handling Server-Sent Events (SSE) streams.
  module Streaming
    # Performs a streaming SSE request.
    #
    # @param method [Symbol] HTTP method (:get, :post, etc.)
    # @param path [String] Request path
    # @param body [Hash, nil] Request body
    # @yield [event] Each parsed SSE event
    # @yieldparam event [Hash] Parsed event data
    # @return [Enumerator<Hash>] if no block given
    def stream(method:, path:, body: nil)
      return enum_for(:stream, method: method, path: path, body: body) unless block_given?

      headers = build_headers({
        "Accept" => "text/event-stream",
        "Cache-Control" => "no-cache"
      })

      buffer = +""

      @connection.run_request(method, path, body&.to_json, headers) do |req|
        req.options.on_data = lambda do |chunk, _size, env|
          # Check for error status on first chunk
          if env.status >= 400
            error_body = buffer + chunk
            handle_stream_error(env.status, error_body)
          end

          buffer << chunk

          # Process complete events (double newline terminated)
          while (idx = buffer.index("\n\n"))
            event_text = buffer.slice!(0, idx + 2)
            event = parse_sse_event(event_text)
            yield event if event
          end
        end
      end
    end

    private

    # Parses a single SSE event.
    #
    # @param text [String] Raw event text
    # @return [Hash, nil] Parsed event or nil
    def parse_sse_event(text)
      data_lines = []

      text.each_line do |line|
        line = line.chomp
        if line.start_with?("data:")
          data_lines << line.delete_prefix("data:").lstrip
        end
      end

      return nil if data_lines.empty?

      data = data_lines.join("\n")
      return nil if data.empty? || data == "[DONE]"

      JSON.parse(data, symbolize_names: true)
    rescue JSON::ParserError => e
      raise StreamParseError.new("Failed to parse SSE event: #{e.message}", data)
    end

    # Handles stream error responses.
    #
    # @param status [Integer] HTTP status code
    # @param body [String] Response body
    # @raise [APIError]
    def handle_stream_error(status, body)
      parsed_body = begin
        JSON.parse(body, symbolize_names: true)
      rescue StandardError
        body
      end

      message = if parsed_body.is_a?(Hash)
                  parsed_body[:message] || parsed_body[:error] || "HTTP #{status}"
                else
                  body || "HTTP #{status}"
                end

      case status
      when 400
        raise BadRequestError.new(message, status, parsed_body)
      when 401
        raise AuthenticationError.new(message, status, parsed_body)
      when 403
        raise PermissionDeniedError.new(message, status, parsed_body)
      when 404
        raise NotFoundError.new(message, status, parsed_body)
      when 422
        raise UnprocessableEntityError.new(message, status, parsed_body)
      when 429
        raise RateLimitError.new(message, status, parsed_body)
      when 500..599
        raise InternalServerError.new(message, status, parsed_body)
      else
        raise APIError.new(message, status, parsed_body)
      end
    end
  end
end
{{end}}
