{{define "client.ml.tmpl"}}(** Code generated by sdkocaml. DO NOT EDIT.

    HTTP client for {{.ModuleName}} API.
*)

open Lwt.Syntax

(** API client handle. *)
type t = {
  config : Config.t;
}

(** Create a new client with default configuration. *)
let create () =
  Lwt.return { config = Config.default }

(** Create a new client with custom configuration. *)
let create_with config =
  Lwt.return { config }

(** Build authentication headers based on config. *)
let build_auth_headers config =
  match config.Config.auth_mode, config.Config.api_key with
  | Config.Bearer, Some key ->
    [("Authorization", "Bearer " ^ key)]
  | Config.Basic, Some key ->
    [("Authorization", "Basic " ^ Base64.encode_string key)]
  | Config.Api_key, Some key ->
    [("X-Api-Key", key)]
  | _ -> []

(** Perform an HTTP request. *)
let request t ~meth ~path ?body ?(headers = []) () =
  let open Cohttp in
  let open Cohttp_lwt_unix in
  let uri = Uri.of_string (t.config.base_url ^ path) in
  let auth_headers = build_auth_headers t.config in
  let all_headers =
    [("Content-Type", "application/json"); ("Accept", "application/json")]
    @ auth_headers
    @ t.config.headers
    @ headers
  in
  let headers = Header.of_list all_headers in
  let body_opt = Option.map (fun b -> Cohttp_lwt.Body.of_string b) body in
  Lwt.catch
    (fun () ->
      let* resp, body =
        match body_opt with
        | Some b -> Client.call ~headers ~body:b meth uri
        | None -> Client.call ~headers meth uri
      in
      let status = Response.status resp |> Code.code_of_status in
      let* body_str = Cohttp_lwt.Body.to_string body in
      if status >= 200 && status < 300 then
        Lwt.return (Ok body_str)
      else
        Lwt.return (Error (Errors.of_response ~status ~body:body_str)))
    (fun exn -> Lwt.return (Error (Errors.of_exn exn)))

(** Perform an HTTP request and decode JSON response. *)
let request_json (type a b) t ~meth ~path ?body ~encode ~decode () =
  let body_str = Option.map (fun b -> Yojson.Safe.to_string (encode b)) body in
  let* result = request t ~meth ~path ?body:body_str () in
  match result with
  | Error e -> Lwt.return (Error e)
  | Ok body_str ->
    (try
      let json = Yojson.Safe.from_string body_str in
      Lwt.return (Ok (decode json))
    with exn ->
      Lwt.return (Error (Errors.Parse_error (Printexc.to_string exn))))

{{if .HasSSE}}
(** Perform a streaming SSE request. *)
let stream (type a b) t ~meth ~path ~body ~encode ~decode () =
  let open Cohttp in
  let open Cohttp_lwt_unix in
  let uri = Uri.of_string (t.config.base_url ^ path) in
  let auth_headers = build_auth_headers t.config in
  let all_headers =
    [("Content-Type", "application/json"); ("Accept", "text/event-stream")]
    @ auth_headers
    @ t.config.headers
  in
  let headers = Header.of_list all_headers in
  let body_str = Yojson.Safe.to_string (encode body) in
  let body = Cohttp_lwt.Body.of_string body_str in
  Lwt.catch
    (fun () ->
      let* resp, body = Client.call ~headers ~body meth uri in
      let status = Response.status resp |> Code.code_of_status in
      if status >= 200 && status < 300 then
        let stream = Cohttp_lwt.Body.to_stream body in
        let event_stream = Streaming.sse_stream ~decode stream in
        Lwt.return (Ok event_stream)
      else
        let* body_str = Cohttp_lwt.Body.to_string body in
        Lwt.return (Error (Errors.of_response ~status ~body:body_str)))
    (fun exn -> Lwt.return (Error (Errors.of_exn exn)))
{{end}}

(** Base64 encoding helper. *)
module Base64 = struct
  let encode_string s =
    let open Bytes in
    let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" in
    let len = String.length s in
    let result_len = ((len + 2) / 3) * 4 in
    let result = Bytes.create result_len in
    let rec loop i j =
      if i >= len then j
      else
        let b0 = Char.code s.[i] in
        let b1 = if i + 1 < len then Char.code s.[i + 1] else 0 in
        let b2 = if i + 2 < len then Char.code s.[i + 2] else 0 in
        Bytes.set result j alphabet.[(b0 lsr 2) land 0x3F];
        Bytes.set result (j + 1) alphabet.[((b0 lsl 4) lor (b1 lsr 4)) land 0x3F];
        Bytes.set result (j + 2)
          (if i + 1 < len then alphabet.[((b1 lsl 2) lor (b2 lsr 6)) land 0x3F] else '=');
        Bytes.set result (j + 3)
          (if i + 2 < len then alphabet.[b2 land 0x3F] else '=');
        loop (i + 3) (j + 4)
    in
    let _ = loop 0 0 in
    Bytes.to_string result
end
{{end}}