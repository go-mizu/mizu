{{define "types.ml.tmpl"}}(** Code generated by sdkocaml. DO NOT EDIT.

    Type definitions for {{.ModuleName}} API.
*)

open Yojson.Safe.Util
{{if .HasDate}}
open Ptime
{{end}}
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

(** {{if $type.Description}}{{$type.Description}}{{else}}{{$type.ModuleName}} type.{{end}} *)
type {{$type.OCamlName}} = {
{{- range $field := $type.Fields}}
  {{$field.OCamlName}} : {{$field.OCamlType}};
  (** {{if $field.Description}}{{$field.Description}}{{else}}{{$field.JSONName}}{{end}} *)
{{- end}}
}

let show_{{$type.OCamlName}} t =
  Printf.sprintf "{ {{range $i, $field := $type.Fields}}{{if $i}}; {{end}}{{$field.OCamlName}} = %s{{end}} }"
{{- range $field := $type.Fields}}
    ({{if $field.Optional}}match t.{{$field.OCamlName}} with Some v -> "Some ..." | None -> "None"{{else if eq $field.OCamlType "string"}}t.{{$field.OCamlName}}{{else}}"..."{{end}})
{{- end}}

let equal_{{$type.OCamlName}} a b =
{{- range $i, $field := $type.Fields}}
  {{if $i}}&&{{else}}  {{end}} a.{{$field.OCamlName}} = b.{{$field.OCamlName}}
{{- end}}

let {{$type.OCamlName}}_of_yojson json =
  {
{{- range $field := $type.Fields}}
    {{$field.OCamlName}} = json |> member {{$field.JSONName | ocamlQuote}} |> {{if $field.Optional}}to_option (fun j -> {{end}}{{if eq $field.OCamlType "string"}}to_string{{else if eq $field.OCamlType "int"}}to_int{{else if eq $field.OCamlType "bool"}}to_bool{{else if eq $field.OCamlType "float"}}to_float{{else if eq $field.OCamlType "Yojson.Safe.t"}}Fun.id{{else}}{{$field.OCamlType}}_of_yojson{{end}}{{if $field.Optional}} j){{end}};
{{- end}}
  }

let yojson_of_{{$type.OCamlName}} t =
  let fields = [
{{- range $field := $type.Fields}}
{{- if $field.Optional}}
    (match t.{{$field.OCamlName}} with Some v -> Some ({{$field.JSONName | ocamlQuote}}, {{if eq $field.OCamlType "string option"}}`String v{{else if eq $field.OCamlType "int option"}}`Int v{{else if eq $field.OCamlType "bool option"}}`Bool v{{else if eq $field.OCamlType "float option"}}`Float v{{else}}yojson_of_{{$field.OCamlType | trimOption}} v{{end}}) | None -> None);
{{- else}}
    Some ({{$field.JSONName | ocamlQuote}}, {{if eq $field.OCamlType "string"}}`String t.{{$field.OCamlName}}{{else if eq $field.OCamlType "int"}}`Int t.{{$field.OCamlName}}{{else if eq $field.OCamlType "bool"}}`Bool t.{{$field.OCamlName}}{{else if eq $field.OCamlType "float"}}`Float t.{{$field.OCamlName}}{{else if eq $field.OCamlType "Yojson.Safe.t"}}t.{{$field.OCamlName}}{{else}}yojson_of_{{$field.OCamlType}} t.{{$field.OCamlName}}{{end}});
{{- end}}
{{- end}}
  ] in
  `Assoc (List.filter_map Fun.id fields)

module {{$type.ModuleName}} = struct
  type t = {{$type.OCamlName}}

  let show = show_{{$type.OCamlName}}
  let equal = equal_{{$type.OCamlName}}
  let of_yojson = {{$type.OCamlName}}_of_yojson
  let yojson_of = yojson_of_{{$type.OCamlName}}
  let t_of_yojson = of_yojson
  let yojson_of_t = yojson_of

  let make
{{- range $field := $type.Fields}}
      {{if $field.Optional}}?{{else}}~{{end}}{{$field.OCamlName}}
{{- end}}
      () =
    { {{range $i, $field := $type.Fields}}{{if $i}}; {{end}}{{$field.OCamlName}}{{if $field.Optional}} = {{$field.OCamlName}}{{end}}{{end}} }
end
{{- range $field := $type.Fields}}
{{- if $field.Enum}}

(** Valid values for '{{$field.OCamlName}}' field of {{$type.ModuleName}}. *)
type {{$type.OCamlName}}_{{$field.OCamlName}} =
{{- range $i, $e := $field.Enum}}
  {{if eq $i 0}}|{{else}}|{{end}} {{$e.Name}}  (** @{{$e.Value}}@ *)
{{- end}}

let show_{{$type.OCamlName}}_{{$field.OCamlName}} = function
{{- range $e := $field.Enum}}
  | {{$e.Name}} -> {{$e.Value | ocamlQuote}}
{{- end}}

let equal_{{$type.OCamlName}}_{{$field.OCamlName}} a b = a = b

let {{$type.OCamlName}}_{{$field.OCamlName}}_of_yojson = function
{{- range $e := $field.Enum}}
  | `String {{$e.Value | ocamlQuote}} -> {{$e.Name}}
{{- end}}
  | _ -> failwith "Unknown {{$type.OCamlName}}_{{$field.OCamlName}}"

let yojson_of_{{$type.OCamlName}}_{{$field.OCamlName}} = function
{{- range $e := $field.Enum}}
  | {{$e.Name}} -> `String {{$e.Value | ocamlQuote}}
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- if eq $type.Kind "union"}}

(** {{if $type.Description}}{{$type.Description}}{{else}}Discriminated union (tag: "{{$type.Tag}}").{{end}}

    Pattern match to access variants:

    {[
      match block with
{{- range $var := $type.Variants}}
      | `{{$var.VariantName}} v -> handle_{{$var.OCamlName}} v
{{- end}}
    ]}
*)
type {{$type.OCamlName}} = [
{{- range $var := $type.Variants}}
  | `{{$var.VariantName}} of {{$var.OCamlName}}
  (** {{if $var.Description}}{{$var.Description}}{{else}}{{$var.VariantName}} variant{{end}} *)
{{- end}}
]

let show_{{$type.OCamlName}} = function
{{- range $var := $type.Variants}}
  | `{{$var.VariantName}} v -> Printf.sprintf "`{{$var.VariantName}} %s" (show_{{$var.OCamlName}} v)
{{- end}}

let equal_{{$type.OCamlName}} a b =
  match a, b with
{{- range $var := $type.Variants}}
  | `{{$var.VariantName}} a, `{{$var.VariantName}} b -> equal_{{$var.OCamlName}} a b
{{- end}}
  | _ -> false

let {{$type.OCamlName}}_of_yojson json =
  let tag = json |> member {{$type.Tag | ocamlQuote}} |> to_string in
  match tag with
{{- range $var := $type.Variants}}
  | {{$var.Value | ocamlQuote}} -> `{{$var.VariantName}} ({{$var.OCamlName}}_of_yojson json)
{{- end}}
  | _ -> failwith ("Unknown {{$type.OCamlName}} type: " ^ tag)

let yojson_of_{{$type.OCamlName}} = function
{{- range $var := $type.Variants}}
  | `{{$var.VariantName}} v -> yojson_of_{{$var.OCamlName}} v
{{- end}}

module {{$type.ModuleName}} = struct
  type t = {{$type.OCamlName}}

  let show = show_{{$type.OCamlName}}
  let equal = equal_{{$type.OCamlName}}
  let of_yojson = {{$type.OCamlName}}_of_yojson
  let yojson_of = yojson_of_{{$type.OCamlName}}
  let t_of_yojson = of_yojson
  let yojson_of_t = yojson_of
end
{{- end}}
{{- end}}
{{end}}