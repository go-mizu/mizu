{{define "streaming.ml.tmpl"}}(** Code generated by sdkocaml. DO NOT EDIT.

    Server-Sent Events (SSE) streaming support.
*)

(** A parsed SSE event. *)
type 'a event =
  | Data of 'a        (** A data event with parsed payload *)
  | Done              (** Stream completion marker *)
  | Heartbeat         (** Keep-alive ping *)

let show_event show_a = function
  | Data a -> Printf.sprintf "Data %s" (show_a a)
  | Done -> "Done"
  | Heartbeat -> "Heartbeat"

let equal_event equal_a a b =
  match a, b with
  | Data a, Data b -> equal_a a b
  | Done, Done -> true
  | Heartbeat, Heartbeat -> true
  | _ -> false

(** Internal stream parsing state. *)
type state = {
  mutable buffer : string;
  mutable event_data : string list;
  mutable event_id : string option;
  mutable retry : int option;
}

(** Create initial parsing state. *)
let initial_state () = {
  buffer = "";
  event_data = [];
  event_id = None;
  retry = None;
}

(** Parse a single SSE line. *)
let parse_line state line =
  if String.length line = 0 then
    (* Empty line signals end of event *)
    let data = String.concat "\n" (List.rev state.event_data) in
    state.event_data <- [];
    if String.length data > 0 then Some data else None
  else if String.length line >= 5 && String.sub line 0 5 = "data:" then
    let value = String.sub line 5 (String.length line - 5) in
    let value = if String.length value > 0 && value.[0] = ' ' then
      String.sub value 1 (String.length value - 1) else value in
    state.event_data <- value :: state.event_data;
    None
  else if String.length line >= 3 && String.sub line 0 3 = "id:" then
    let value = String.sub line 3 (String.length line - 3) in
    state.event_id <- Some (String.trim value);
    None
  else if String.length line >= 6 && String.sub line 0 6 = "retry:" then
    let value = String.sub line 6 (String.length line - 6) in
    (try state.retry <- Some (int_of_string (String.trim value)) with _ -> ());
    None
  else if String.length line >= 1 && line.[0] = ':' then
    (* Comment line, ignore *)
    None
  else
    None

(** Parse a chunk of SSE data.

    @param state Current parsing state
    @param chunk New data chunk
    @param decode JSON decoder for events
    @return List of parsed events
*)
let parse_chunk ~state ~chunk ~decode =
  state.buffer <- state.buffer ^ chunk;
  let lines = String.split_on_char '\n' state.buffer in
  let rec process_lines acc = function
    | [] -> List.rev acc
    | [last] ->
      (* Last element might be incomplete *)
      state.buffer <- last;
      List.rev acc
    | line :: rest ->
      (* Remove trailing \r if present *)
      let line = if String.length line > 0 && line.[String.length line - 1] = '\r'
        then String.sub line 0 (String.length line - 1) else line in
      match parse_line state line with
      | None -> process_lines acc rest
      | Some data ->
        if data = "[DONE]" then
          process_lines (Done :: acc) rest
        else
          try
            let json = Yojson.Safe.from_string data in
            let event = decode json in
            process_lines (Data event :: acc) rest
          with _ ->
            (* Skip malformed data *)
            process_lines (Heartbeat :: acc) rest
  in
  process_lines [] lines

(** Create an SSE stream from a byte stream. *)
let sse_stream ~decode byte_stream =
  let state = initial_state () in
  Lwt_stream.filter_map_s (fun chunk ->
    let events = parse_chunk ~state ~chunk ~decode in
    Lwt.return (match events with [] -> None | _ -> Some events)
  ) byte_stream
  |> Lwt_stream.map_list Fun.id

(** Collect all data events from a stream. *)
let collect_data stream =
  let open Lwt.Syntax in
  let rec loop acc =
    let* event = Lwt_stream.get stream in
    match event with
    | None -> Lwt.return (List.rev acc)
    | Some Done -> Lwt.return (List.rev acc)
    | Some Heartbeat -> loop acc
    | Some (Data e) -> loop (e :: acc)
  in
  loop []

(** Collect all text deltas from a stream. *)
let collect_text ~extract_text stream =
  let open Lwt.Syntax in
  let rec loop acc =
    let* event = Lwt_stream.get stream in
    match event with
    | None -> Lwt.return (List.rev acc)
    | Some Done -> Lwt.return (List.rev acc)
    | Some Heartbeat -> loop acc
    | Some (Data e) ->
      match extract_text e with
      | Some t -> loop (t :: acc)
      | None -> loop acc
  in
  loop []
{{end}}