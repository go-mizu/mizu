{{define "resources.ml.tmpl"}}(** Code generated by sdkocaml. DO NOT EDIT.

    API resources for {{.ModuleName}}.
*)

open Lwt.Syntax
{{range $res := .Resources}}

(** {{if $res.Description}}{{$res.Description}}{{else}}{{$res.ModuleName}} resource operations.{{end}} *)
module {{$res.ModuleName}} = struct
{{- range $method := $res.Methods}}

  (** {{if $method.Description}}{{$method.Description}}{{else}}{{$method.Name}} operation.{{end}} *)
  let {{$method.OCamlName}} client
{{- if $method.HasInput}}
{{- range $field := $method.InputFields}}
      {{if $field.Optional}}?{{else}}~{{end}}{{$field.OCamlName}}
{{- end}}
{{- end}}
      () =
{{- if $method.HasInput}}
    let body = Types.{{$method.InputType | pascal}}.make
{{- range $field := $method.InputFields}}
      {{if $field.Optional}}?{{else}}~{{end}}{{$field.OCamlName}}
{{- end}}
      ()
    in
{{- end}}
{{- if $method.IsStreaming}}
    Client.stream client
      ~meth:`POST
      ~path:{{$method.HTTPPath | ocamlQuote}}
      ~body
      ~encode:Types.{{$method.InputType | pascal}}.yojson_of
      ~decode:Types.{{$method.StreamItemType | pascal}}_of_yojson
      ()
{{- else if and $method.HasInput $method.HasOutput}}
    Client.request_json client
      ~meth:`{{$method.HTTPMethod}}
      ~path:{{$method.HTTPPath | ocamlQuote}}
      ~body
      ~encode:Types.{{$method.InputType | pascal}}.yojson_of
      ~decode:Types.{{$method.OutputType | pascal}}_of_yojson
      ()
{{- else if $method.HasInput}}
    let body_str = Yojson.Safe.to_string (Types.{{$method.InputType | pascal}}.yojson_of body) in
    let+ result = Client.request client ~meth:`{{$method.HTTPMethod}} ~path:{{$method.HTTPPath | ocamlQuote}} ~body:body_str () in
    Result.map (fun _ -> ()) result
{{- else if $method.HasOutput}}
    Client.request_json client
      ~meth:`{{$method.HTTPMethod}}
      ~path:{{$method.HTTPPath | ocamlQuote}}
      ~encode:(fun () -> `Null)
      ~decode:Types.{{$method.OutputType | pascal}}_of_yojson
      ()
{{- else}}
    let+ result = Client.request client ~meth:`{{$method.HTTPMethod}} ~path:{{$method.HTTPPath | ocamlQuote}} () in
    Result.map (fun _ -> ()) result
{{- end}}

  (** {{if $method.Description}}{{$method.Description}}{{else}}{{$method.Name}} operation{{end}} (raises on error). *)
  let {{$method.OCamlName}}_exn client
{{- if $method.HasInput}}
{{- range $field := $method.InputFields}}
      {{if $field.Optional}}?{{else}}~{{end}}{{$field.OCamlName}}
{{- end}}
{{- end}}
      () =
    let* result = {{$method.OCamlName}} client
{{- if $method.HasInput}}
{{- range $field := $method.InputFields}}
      {{if $field.Optional}}?{{else}}~{{end}}{{$field.OCamlName}}
{{- end}}
{{- end}}
      ()
    in
    match result with
    | Ok v -> Lwt.return v
    | Error e -> Lwt.fail_with (Errors.show e)
{{- end}}
end
{{- end}}
{{end}}