{{define "errors.ml.tmpl"}}(** Code generated by sdkocaml. DO NOT EDIT.

    Error types for {{.ModuleName}} API.
*)

open Yojson.Safe.Util

(** Error type classification. *)
type error_type =
  | Bad_request           (** HTTP 400 *)
  | Unauthorized          (** HTTP 401 *)
  | Forbidden             (** HTTP 403 *)
  | Not_found             (** HTTP 404 *)
  | Unprocessable_entity  (** HTTP 422 *)
  | Rate_limited          (** HTTP 429 *)
  | Server_error          (** HTTP 5xx *)
  | Network_error         (** Connection/network errors *)
  | Parse_error_type      (** JSON parsing errors *)
  | Timeout_error_type    (** Request timeout *)
  | Stream_error_type     (** SSE parsing errors *)

let show_error_type = function
  | Bad_request -> "Bad_request"
  | Unauthorized -> "Unauthorized"
  | Forbidden -> "Forbidden"
  | Not_found -> "Not_found"
  | Unprocessable_entity -> "Unprocessable_entity"
  | Rate_limited -> "Rate_limited"
  | Server_error -> "Server_error"
  | Network_error -> "Network_error"
  | Parse_error_type -> "Parse_error"
  | Timeout_error_type -> "Timeout_error"
  | Stream_error_type -> "Stream_error"

let equal_error_type a b = a = b

(** API error details from server response. *)
type api_error = {
  error_type_str : string;
  message : string;
  param : string option;
  code : string option;
}

let show_api_error e =
  Printf.sprintf "{ type = %s; message = %s }" e.error_type_str e.message

let equal_api_error a b =
  a.error_type_str = b.error_type_str &&
  a.message = b.message &&
  a.param = b.param &&
  a.code = b.code

let api_error_of_yojson json =
  let err = json |> member "error" in
  {
    error_type_str = err |> member "type" |> to_string_option |> Option.value ~default:"unknown";
    message = err |> member "message" |> to_string_option |> Option.value ~default:"Unknown error";
    param = err |> member "param" |> to_string_option;
    code = err |> member "code" |> to_string_option;
  }

let yojson_of_api_error e =
  let fields = [
    ("type", `String e.error_type_str);
    ("message", `String e.message);
  ] in
  let fields = match e.param with
    | Some p -> ("param", `String p) :: fields
    | None -> fields
  in
  let fields = match e.code with
    | Some c -> ("code", `String c) :: fields
    | None -> fields
  in
  `Assoc [("error", `Assoc fields)]

(** SDK error type. *)
type t =
  | Api_error of { status : int; error : api_error }
      (** API returned an error response *)
  | Connection_error of string
      (** Network/connection error *)
  | Timeout_error of string
      (** Request timed out *)
  | Parse_error of string
      (** Failed to parse response *)
  | Rate_limit_error of { retry_after : int; error : api_error option }
      (** Rate limited (retry after N seconds) *)
  | Stream_error of string
      (** Error in SSE stream *)

let show = function
  | Api_error { status; error } ->
    Printf.sprintf "Api_error { status = %d; error = %s }" status (show_api_error error)
  | Connection_error msg ->
    Printf.sprintf "Connection_error %S" msg
  | Timeout_error msg ->
    Printf.sprintf "Timeout_error %S" msg
  | Parse_error msg ->
    Printf.sprintf "Parse_error %S" msg
  | Rate_limit_error { retry_after; error } ->
    Printf.sprintf "Rate_limit_error { retry_after = %d; error = %s }"
      retry_after
      (match error with Some e -> show_api_error e | None -> "None")
  | Stream_error msg ->
    Printf.sprintf "Stream_error %S" msg

let equal a b =
  match a, b with
  | Api_error a, Api_error b ->
    a.status = b.status && equal_api_error a.error b.error
  | Connection_error a, Connection_error b -> a = b
  | Timeout_error a, Timeout_error b -> a = b
  | Parse_error a, Parse_error b -> a = b
  | Rate_limit_error a, Rate_limit_error b ->
    a.retry_after = b.retry_after
  | Stream_error a, Stream_error b -> a = b
  | _ -> false

(** Create an error from an HTTP response. *)
let of_response ~status ~body =
  let api_error =
    try Some (api_error_of_yojson (Yojson.Safe.from_string body))
    with _ -> None
  in
  let default_error = {
    error_type_str = "unknown_error";
    message = "Unknown error";
    param = None;
    code = None;
  } in
  match status with
  | 429 ->
    Rate_limit_error {
      retry_after = 60; (* Default retry after 60s *)
      error = api_error;
    }
  | s when s >= 400 && s < 500 ->
    Api_error {
      status = s;
      error = Option.value api_error ~default:default_error;
    }
  | s when s >= 500 ->
    Api_error {
      status = s;
      error = Option.value api_error ~default:{
        error_type_str = "server_error";
        message = "Internal server error";
        param = None;
        code = None;
      };
    }
  | _ ->
    Api_error {
      status;
      error = Option.value api_error ~default:default_error;
    }

(** Create an error from an exception. *)
let of_exn exn =
  Connection_error (Printexc.to_string exn)

(** Check if an error is retryable. *)
let is_retryable = function
  | Rate_limit_error _ -> true
  | Connection_error _ -> true
  | Timeout_error _ -> true
  | Api_error { status; _ } -> status >= 500
  | _ -> false

(** Get human-readable error message. *)
let message = function
  | Api_error { error; _ } -> error.message
  | Connection_error msg -> msg
  | Timeout_error msg -> msg
  | Parse_error msg -> msg
  | Rate_limit_error { retry_after; error } ->
    (match error with
     | Some e -> e.message
     | None -> Printf.sprintf "Rate limited. Retry after %d seconds" retry_after)
  | Stream_error msg -> msg

(** Get HTTP status code if applicable. *)
let status = function
  | Api_error { status; _ } -> Some status
  | Rate_limit_error _ -> Some 429
  | _ -> None

(** Get error classification. *)
let classify = function
  | Api_error { status = 400; _ } -> Bad_request
  | Api_error { status = 401; _ } -> Unauthorized
  | Api_error { status = 403; _ } -> Forbidden
  | Api_error { status = 404; _ } -> Not_found
  | Api_error { status = 422; _ } -> Unprocessable_entity
  | Api_error { status; _ } when status >= 500 -> Server_error
  | Api_error _ -> Bad_request
  | Connection_error _ -> Network_error
  | Timeout_error _ -> Timeout_error_type
  | Parse_error _ -> Parse_error_type
  | Rate_limit_error _ -> Rate_limited
  | Stream_error _ -> Stream_error_type
{{end}}