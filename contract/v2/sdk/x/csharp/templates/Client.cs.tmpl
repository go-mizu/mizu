// <auto-generated>
// This file was generated by Mizu SDK Generator. Do not edit manually.
// </auto-generated>

using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;
using System.Text.Json.Serialization;
using {{.Namespace}}.Models;
using {{.Namespace}}.Resources;

namespace {{.Namespace}};

/// <summary>
/// Authentication mode for API requests.
/// </summary>
public enum AuthMode
{
    /// <summary>Bearer token authentication.</summary>
    Bearer,
    /// <summary>Basic authentication.</summary>
    Basic,
    /// <summary>No authentication.</summary>
    None
}

/// <summary>
/// Configuration options for the SDK client.
/// </summary>
public sealed record ClientOptions
{
    /// <summary>
    /// API key for authentication.
    /// </summary>
    public string? ApiKey { get; init; }

    /// <summary>
    /// Base URL for API requests.
    /// </summary>
    public string BaseUrl { get; init; } = {{csharpQuote .Defaults.BaseURL}};

    /// <summary>
    /// Request timeout. Default: 60 seconds.
    /// </summary>
    public TimeSpan Timeout { get; init; } = TimeSpan.FromSeconds(60);

    /// <summary>
    /// Maximum number of retry attempts for failed requests. Default: 2.
    /// </summary>
    public int MaxRetries { get; init; } = 2;

    /// <summary>
    /// Default headers to include in all requests.
    /// </summary>
    public IReadOnlyDictionary<string, string> DefaultHeaders { get; init; } =
        new Dictionary<string, string>
        {
{{- range .Defaults.Headers}}
            [{{csharpQuote .K}}] = {{csharpQuote .V}},
{{- end}}
        };

    /// <summary>
    /// Authentication mode for API requests.
    /// </summary>
{{- if eq .Defaults.Auth "basic"}}
    public AuthMode AuthMode { get; init; } = AuthMode.Basic;
{{- else if eq .Defaults.Auth "none"}}
    public AuthMode AuthMode { get; init; } = AuthMode.None;
{{- else}}
    public AuthMode AuthMode { get; init; } = AuthMode.Bearer;
{{- end}}

    /// <summary>
    /// Optional HttpClient to use instead of creating a new one.
    /// </summary>
    public HttpClient? HttpClient { get; init; }
}

{{- if .Service.Description}}

/// <summary>
/// {{.Service.Description}}
/// </summary>
{{- end}}
public sealed class {{.Service.Sanitized}}Client : IDisposable
{
    private readonly HttpClient _httpClient;
    private readonly bool _ownsHttpClient;
    private readonly ClientOptions _options;
    private readonly HttpClientWrapper _wrapper;
    private bool _disposed;

{{- range .Resources}}

    /// <summary>
    /// Access to {{.Name}} operations.
    /// </summary>
    public {{.ClassName}} {{.CSharpName}} { get; }
{{- end}}

    /// <summary>
    /// Creates a new client with the specified options.
    /// </summary>
    /// <param name="options">Client configuration options.</param>
    public {{.Service.Sanitized}}Client(ClientOptions? options = null)
    {
        _options = options ?? new ClientOptions();

        if (_options.HttpClient is not null)
        {
            _httpClient = _options.HttpClient;
            _ownsHttpClient = false;
        }
        else
        {
            _httpClient = new HttpClient { Timeout = _options.Timeout };
            _ownsHttpClient = true;
        }

        _wrapper = new HttpClientWrapper(_httpClient, _options);
{{- range .Resources}}
        {{.CSharpName}} = new {{.ClassName}}(_wrapper);
{{- end}}
    }

    /// <summary>
    /// Creates a new client with modified configuration.
    /// </summary>
    /// <param name="configure">A function to modify the client options.</param>
    /// <returns>A new client with the modified configuration.</returns>
    public {{.Service.Sanitized}}Client WithOptions(Func<ClientOptions, ClientOptions> configure)
    {
        return new {{.Service.Sanitized}}Client(configure(_options));
    }

    /// <inheritdoc />
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        if (_ownsHttpClient)
        {
            _httpClient.Dispose();
        }
    }
}

internal sealed class HttpClientWrapper
{
    private readonly HttpClient _httpClient;
    private readonly ClientOptions _options;
    private static readonly Random _jitter = new();

    internal static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        Converters = { new JsonStringEnumConverter(JsonNamingPolicy.SnakeCaseLower) }
    };

    public HttpClientWrapper(HttpClient httpClient, ClientOptions options)
    {
        _httpClient = httpClient;
        _options = options;
    }

    public async Task<T> RequestAsync<T>(
        HttpMethod method,
        string path,
        object? body = null,
        CancellationToken cancellationToken = default)
    {
        Exception? lastException = null;

        for (var attempt = 0; attempt <= _options.MaxRetries; attempt++)
        {
            try
            {
                using var request = new HttpRequestMessage(method, BuildUri(path));
                ApplyHeaders(request);

                if (body is not null)
                {
                    request.Content = JsonContent.Create(body, options: JsonOptions);
                }

                using var response = await _httpClient
                    .SendAsync(request, cancellationToken)
                    .ConfigureAwait(false);

                if (!response.IsSuccessStatusCode)
                {
                    var responseBody = await response.Content
                        .ReadAsStringAsync(cancellationToken)
                        .ConfigureAwait(false);

                    throw new ApiException(
                        (int)response.StatusCode,
                        $"API error: {response.StatusCode}",
                        responseBody);
                }

                var result = await response.Content
                    .ReadFromJsonAsync<T>(JsonOptions, cancellationToken)
                    .ConfigureAwait(false);

                return result ?? throw new DeserializationException(
                    new InvalidOperationException("Response was null"));
            }
            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
            {
                throw new CancelledException();
            }
            catch (TaskCanceledException ex) when (!cancellationToken.IsCancellationRequested)
            {
                lastException = new SdkTimeoutException(ex);
                if (attempt < _options.MaxRetries)
                {
                    await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
                }
            }
            catch (HttpRequestException ex)
            {
                lastException = new ConnectionException(ex);
                if (attempt < _options.MaxRetries)
                {
                    await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
                }
            }
            catch (ApiException ex) when (ex.IsRetriable && attempt < _options.MaxRetries)
            {
                lastException = ex;
                await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
            }
        }

        throw lastException ?? new ConnectionException(new Exception("Unknown error"));
    }

    public async Task RequestAsync(
        HttpMethod method,
        string path,
        object? body = null,
        CancellationToken cancellationToken = default)
    {
        Exception? lastException = null;

        for (var attempt = 0; attempt <= _options.MaxRetries; attempt++)
        {
            try
            {
                using var request = new HttpRequestMessage(method, BuildUri(path));
                ApplyHeaders(request);

                if (body is not null)
                {
                    request.Content = JsonContent.Create(body, options: JsonOptions);
                }

                using var response = await _httpClient
                    .SendAsync(request, cancellationToken)
                    .ConfigureAwait(false);

                if (!response.IsSuccessStatusCode)
                {
                    var responseBody = await response.Content
                        .ReadAsStringAsync(cancellationToken)
                        .ConfigureAwait(false);

                    throw new ApiException(
                        (int)response.StatusCode,
                        $"API error: {response.StatusCode}",
                        responseBody);
                }

                return;
            }
            catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
            {
                throw new CancelledException();
            }
            catch (TaskCanceledException ex) when (!cancellationToken.IsCancellationRequested)
            {
                lastException = new SdkTimeoutException(ex);
                if (attempt < _options.MaxRetries)
                {
                    await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
                }
            }
            catch (HttpRequestException ex)
            {
                lastException = new ConnectionException(ex);
                if (attempt < _options.MaxRetries)
                {
                    await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
                }
            }
            catch (ApiException ex) when (ex.IsRetriable && attempt < _options.MaxRetries)
            {
                lastException = ex;
                await Task.Delay(GetBackoff(attempt), cancellationToken).ConfigureAwait(false);
            }
        }

        throw lastException ?? new ConnectionException(new Exception("Unknown error"));
    }

{{- if .HasSSE}}

    public async IAsyncEnumerable<T> StreamAsync<T>(
        HttpMethod method,
        string path,
        object? body = null,
        [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken = default)
    {
        using var request = new HttpRequestMessage(method, BuildUri(path));
        ApplyHeaders(request);
        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue("text/event-stream"));

        if (body is not null)
        {
            request.Content = JsonContent.Create(body, options: JsonOptions);
        }

        HttpResponseMessage response;
        try
        {
            response = await _httpClient
                .SendAsync(request, HttpCompletionOption.ResponseHeadersRead, cancellationToken)
                .ConfigureAwait(false);
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {
            throw new CancelledException();
        }
        catch (TaskCanceledException ex) when (!cancellationToken.IsCancellationRequested)
        {
            throw new SdkTimeoutException(ex);
        }
        catch (HttpRequestException ex)
        {
            throw new ConnectionException(ex);
        }

        using (response)
        {
            if (!response.IsSuccessStatusCode)
            {
                var responseBody = await response.Content
                    .ReadAsStringAsync(cancellationToken)
                    .ConfigureAwait(false);

                throw new ApiException(
                    (int)response.StatusCode,
                    $"API error: {response.StatusCode}",
                    responseBody);
            }

            await using var stream = await response.Content
                .ReadAsStreamAsync(cancellationToken)
                .ConfigureAwait(false);

            await foreach (var item in SseParser.ParseAsync<T>(stream, JsonOptions, cancellationToken))
            {
                yield return item;
            }
        }
    }
{{- end}}

    private Uri BuildUri(string path) => new($"{_options.BaseUrl.TrimEnd('/')}{path}");

    private void ApplyHeaders(HttpRequestMessage request)
    {
        foreach (var header in _options.DefaultHeaders)
        {
            request.Headers.TryAddWithoutValidation(header.Key, header.Value);
        }

        if (_options.ApiKey is not null)
        {
            switch (_options.AuthMode)
            {
                case AuthMode.Bearer:
                    request.Headers.Authorization =
                        new AuthenticationHeaderValue("Bearer", _options.ApiKey);
                    break;
                case AuthMode.Basic:
                    request.Headers.Authorization =
                        new AuthenticationHeaderValue("Basic", _options.ApiKey);
                    break;
            }
        }
    }

    private static TimeSpan GetBackoff(int attempt)
    {
        var baseDelay = TimeSpan.FromMilliseconds(500);
        var exponential = baseDelay * (1 << attempt);
        var jitter = TimeSpan.FromMilliseconds(_jitter.Next(0, 100));
        return exponential + jitter;
    }
}
