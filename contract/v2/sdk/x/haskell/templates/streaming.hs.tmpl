{{define "streaming.hs.tmpl"}}{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | Code generated by sdkhaskell. DO NOT EDIT.
--
-- Server-Sent Events (SSE) streaming support.
module {{.ModuleName}}.Streaming
    ( -- * Types
      Event(..)

      -- * Parsing
    , parseSSE
    , sseConduit

      -- * Utilities
    , collectEvents
    ) where

import Control.Monad (void)
import Data.Aeson (FromJSON, eitherDecode)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as LBS
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Conduit

-- | A parsed SSE event.
data Event a
    = DataEvent !a           -- ^ A data event with parsed payload
    | DoneEvent              -- ^ Stream completion marker (@[DONE]@)
    | HeartbeatEvent         -- ^ Keep-alive ping (empty event)
    deriving (Show, Eq, Functor)

-- | Conduit that parses raw bytes into SSE events.
--
-- @
-- runConduit $ sourceByteString rawData
--     .| sseConduit
--     .| mapM_C handleEvent
-- @
sseConduit :: (MonadIO m, FromJSON a) => ConduitT BS.ByteString (Event a) m ()
sseConduit = loop BS.empty
  where
    loop buffer = do
        mChunk <- await
        case mChunk of
            Nothing ->
                -- End of stream, try to parse remaining buffer
                unless (BS.null buffer) $
                    case parseSSE buffer of
                        Just evt -> yield evt
                        Nothing -> pure ()
            Just chunk -> do
                let newBuffer = buffer <> chunk
                processBuffer newBuffer

    processBuffer buffer =
        case BS.breakSubstring "\n\n" buffer of
            (_, rest) | BS.null rest ->
                -- No complete event yet, continue accumulating
                loop buffer
            (event, rest) -> do
                -- Found complete event
                case parseSSE event of
                    Just evt -> yield evt
                    Nothing -> pure ()
                -- Continue with remaining data (skip the "\n\n")
                let remaining = BS.drop 2 rest
                if BS.null remaining
                    then loop BS.empty
                    else processBuffer remaining

-- | Parse a single SSE event from bytes.
--
-- @
-- parseSSE \"data: {\\\"text\\\": \\\"hello\\\"}\"
-- -- => Just (DataEvent {...})
--
-- parseSSE \"data: [DONE]\"
-- -- => Just DoneEvent
-- @
parseSSE :: FromJSON a => BS.ByteString -> Maybe (Event a)
parseSSE bs =
    let lines' = BS.split (fromIntegral (fromEnum '\n')) bs
        dataLines = [d | line <- lines'
                       , Just d <- [BS.stripPrefix "data:" line]
                       , not (BS.null $ BS.dropWhile (== 32) d)]  -- 32 = space
        dataContent = BS.intercalate "\n" $ map (BS.dropWhile (== 32)) dataLines
    in case dataContent of
        "" -> Just HeartbeatEvent
        "[DONE]" -> Just DoneEvent
        _ -> case eitherDecode (LBS.fromStrict dataContent) of
            Left _err -> Nothing  -- Skip malformed data
            Right v -> Just (DataEvent v)

-- | Collect all data events from a conduit source.
--
-- @
-- events <- runConduit $ source .| collectEvents
-- @
collectEvents :: (Monad m, FromJSON a) => ConduitT (Event a) Void m [a]
collectEvents = loop []
  where
    loop acc = do
        mEvent <- await
        case mEvent of
            Nothing -> pure (reverse acc)
            Just DoneEvent -> pure (reverse acc)
            Just HeartbeatEvent -> loop acc
            Just (DataEvent e) -> loop (e : acc)
{{end}}