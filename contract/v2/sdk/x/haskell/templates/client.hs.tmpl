{{define "client.hs.tmpl"}}{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | Code generated by sdkhaskell. DO NOT EDIT.
--
-- HTTP client for {{.ModuleName}} API.
module {{.ModuleName}}.Client
    ( -- * Client
      Client(..)
    , newClient
    , newClientWith

      -- * Requests
    , request
    , requestJSON
{{- if .HasSSE}}
    , stream
{{- end}}
    ) where

import Control.Exception (try, SomeException)
import Data.Aeson (FromJSON, ToJSON, eitherDecode, encode)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy as LBS
import qualified Data.ByteString.Base64 as B64
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Network.HTTP.Client
    ( Manager, newManager, Request(..), Response(..)
    , httpLbs, parseRequest_, responseStatus, responseBody
    , requestHeaders, requestBody, RequestBody(..)
    )
import Network.HTTP.Client.TLS (tlsManagerSettings)
import Network.HTTP.Types
    ( Status(..), hContentType, hAccept, hAuthorization
    , Method, methodGet, methodPost, methodPut, methodDelete, methodPatch
    )
{{- if .HasSSE}}
import Network.HTTP.Client.Conduit (responseOpen, responseClose)
import Conduit (ConduitT, (.|), runConduit, yield, await)
import qualified Data.Conduit.List as CL
{{- end}}

import {{.ModuleName}}.Config
import {{.ModuleName}}.Errors

-- | API client handle.
data Client = Client
    { clientConfig  :: !Config
    , clientManager :: !Manager
    } deriving (Show)

instance Show Manager where
    show _ = "<Manager>"

-- | Create a new client with default configuration.
--
-- Configuration is loaded from environment variables.
--
-- @
-- client <- newClient
-- @
newClient :: IO Client
newClient = do
    config <- configFromEnv
    newClientWith config

-- | Create a new client with custom configuration.
--
-- @
-- client <- newClientWith $ defaultConfig { apiKey = Just \"sk-...\" }
-- @
newClientWith :: Config -> IO Client
newClientWith config = do
    manager <- newManager tlsManagerSettings
    pure $ Client config manager

-- | Perform an HTTP request.
--
-- Returns the raw response body on success, or an 'SDKError' on failure.
request
    :: Client
    -> Method                -- ^ HTTP method
    -> Text                  -- ^ Path
    -> Maybe LBS.ByteString  -- ^ Request body
    -> [(Text, Text)]        -- ^ Extra headers
    -> IO (Either SDKError LBS.ByteString)
request Client{..} method path mBody extraHeaders = do
    let Config{..} = clientConfig
        url = T.unpack baseUrl <> T.unpack path
        baseReq = parseRequest_ url
        authHdrs = buildAuthHeaders clientConfig
        allHeaders =
            [ (hContentType, "application/json")
            , (hAccept, "application/json")
            ]
            ++ authHdrs
            ++ [(TE.encodeUtf8 k, TE.encodeUtf8 v) | (k, v) <- headers]
            ++ [(TE.encodeUtf8 k, TE.encodeUtf8 v) | (k, v) <- extraHeaders]
        req = baseReq
            { method = method
            , requestHeaders = allHeaders
            , requestBody = maybe mempty RequestBodyLBS mBody
            }

    result <- try $ httpLbs req clientManager
    case result of
        Left (e :: SomeException) ->
            pure $ Left $ ConnectionError $ T.pack $ show e
        Right response ->
            let status = responseStatus response
                body = responseBody response
            in if statusCode status >= 200 && statusCode status < 300
                then pure $ Right body
                else pure $ Left $ fromResponse status body

-- | Perform an HTTP request and decode JSON response.
--
-- @
-- result <- requestJSON client methodPost \"\/v1\/messages\" (Just body)
-- case result of
--     Left err -> handleError err
--     Right response -> handleResponse response
-- @
requestJSON
    :: (ToJSON req, FromJSON resp)
    => Client
    -> Method
    -> Text
    -> Maybe req
    -> IO (Either SDKError resp)
requestJSON client method path mBody = do
    let body = encode <$> mBody
    result <- request client method path body []
    pure $ result >>= \bs ->
        case eitherDecode bs of
            Left err -> Left $ ParseError $ T.pack err
            Right v  -> Right v
{{if .HasSSE}}

-- | Perform a streaming SSE request.
--
-- Returns a conduit source of raw SSE chunks.
stream
    :: ToJSON req
    => Client
    -> Method
    -> Text
    -> req
    -> IO (Either SDKError (ConduitT () BS.ByteString IO ()))
stream Client{..} method path body = do
    let Config{..} = clientConfig
        url = T.unpack baseUrl <> T.unpack path
        baseReq = parseRequest_ url
        authHdrs = buildAuthHeaders clientConfig
        allHeaders =
            [ (hContentType, "application/json")
            , (hAccept, "text/event-stream")
            ]
            ++ authHdrs
            ++ [(TE.encodeUtf8 k, TE.encodeUtf8 v) | (k, v) <- headers]
        req = baseReq
            { method = method
            , requestHeaders = allHeaders
            , requestBody = RequestBodyLBS $ encode body
            }

    result <- try $ responseOpen req clientManager
    case result of
        Left (e :: SomeException) ->
            pure $ Left $ ConnectionError $ T.pack $ show e
        Right response ->
            let status = responseStatus response
            in if statusCode status >= 200 && statusCode status < 300
                then pure $ Right $ responseBodySource response
                else do
                    body' <- LBS.fromStrict <$> responseBody response
                    responseClose response
                    pure $ Left $ fromResponse status body'
  where
    responseBodySource response = do
        chunk <- liftIO $ responseBody response
        if BS.null chunk
            then liftIO $ responseClose response
            else do
                yield chunk
                responseBodySource response
{{end}}

-- | Build authentication headers.
buildAuthHeaders :: Config -> [(BS.ByteString, BS.ByteString)]
buildAuthHeaders Config{..} = case (authMode, apiKey) of
    (BearerAuth, Just key) ->
        [(hAuthorization, "Bearer " <> TE.encodeUtf8 key)]
    (BasicAuth, Just key) ->
        [(hAuthorization, "Basic " <> B64.encode (TE.encodeUtf8 key))]
    (HeaderAuth, Just key) ->
        [("X-Api-Key", TE.encodeUtf8 key)]
    _ -> []
{{end}}