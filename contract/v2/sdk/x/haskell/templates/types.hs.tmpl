{{define "types.hs.tmpl"}}{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Code generated by sdkhaskell. DO NOT EDIT.
--
-- Type definitions for {{.ModuleName}} API.
--
-- All types derive 'Generic' and have Aeson instances for JSON serialization.
module {{.ModuleName}}.Types
    ( -- * Types
{{- range $i, $type := .Types}}
{{- if eq $type.Kind "struct"}}
      {{if $i}},{{else}} {{end}} {{$type.HaskellName}}(..)
{{- else if eq $type.Kind "union"}}
      {{if $i}},{{else}} {{end}} {{$type.HaskellName}}(..)
{{- range $var := $type.Variants}}
      , {{$var.HaskellName}}(..)
{{- end}}
{{- end}}
{{- end}}
{{- range $type := .Types}}
{{- range $field := $type.Fields}}
{{- if $field.Enum}}
      , {{$type.HaskellName}}{{$field.HaskellName | pascal}}(..)
{{- end}}
{{- end}}
{{- end}}
    ) where

import Data.Aeson
    ( FromJSON(..), ToJSON(..)
    , genericParseJSON, genericToJSON
    , defaultOptions, fieldLabelModifier
    , omitNothingFields, withObject, withText
    , object, (.:), (.:?), (.=)
    )
import Data.Aeson.Types (Parser, Options(..))
import Data.Char (toLower, isUpper)
import Data.Text (Text)
import qualified Data.Text as T
{{- if .HasDate}}
import Data.Time (UTCTime)
{{- end}}
{{- if .HasAny}}
import Data.Aeson (Value)
{{- end}}
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Int (Int8, Int16, Int32, Int64)
import Data.Word (Word, Word8, Word16, Word32, Word64)
import GHC.Generics (Generic)

-- | JSON options for snake_case field names
jsonOptions :: Int -> Options
jsonOptions prefixLen = defaultOptions
    { fieldLabelModifier = camelToSnake . drop prefixLen
    , omitNothingFields = True
    }

-- | Convert camelCase to snake_case
camelToSnake :: String -> String
camelToSnake = concatMap go
  where
    go c
        | isUpper c = ['_', toLower c]
        | otherwise = [c]
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

-- | {{if $type.Description}}{{$type.Description}}{{else}}{{$type.HaskellName}} type.{{end}}
data {{$type.HaskellName}} = {{$type.HaskellName}}
    { {{- $fields := $type.Fields}}
{{- $lastIdx := len $fields | add -1}}
{{- range $i, $field := $fields}}
      {{if eq $i 0}} {{else}},{{end}} {{$field.PrefixedName}} :: {{if $field.Optional}}Maybe {{end}}{{if not $field.Optional}}!{{end}}{{$field.HaskellType}}
      -- ^ {{if $field.Description}}{{$field.Description}}{{else}}{{$field.JSONName}}{{end}}
{{- end}}
    } deriving (Show, Eq, Generic)

instance FromJSON {{$type.HaskellName}} where
    parseJSON = withObject "{{$type.HaskellName}}" $ \o ->
        {{$type.HaskellName}}
{{- range $i, $field := $type.Fields}}
            {{if eq $i 0}}<$>{{else}}<*>{{end}} o {{if $field.Optional}}.:?{{else}}.:{{end}} "{{$field.JSONName}}"
{{- end}}

instance ToJSON {{$type.HaskellName}} where
    toJSON {{$type.HaskellName}}{..} = object
        [ {{- range $i, $field := $type.Fields}}
{{if $i}}        , {{else}}          {{end}}"{{$field.JSONName}}" .= {{$field.PrefixedName}}
{{- end}}
        ]
{{- range $field := $type.Fields}}
{{- if $field.Enum}}

-- | Valid values for '{{$field.HaskellName}}' field.
data {{$type.HaskellName}}{{$field.HaskellName | pascal}}
{{- range $i, $e := $field.Enum}}
    {{if eq $i 0}}={{else}}|{{end}} {{$e.Name}}  -- ^ @{{$e.Value}}@
{{- end}}
    deriving (Show, Eq, Ord, Bounded, Enum, Generic)

instance FromJSON {{$type.HaskellName}}{{$field.HaskellName | pascal}} where
    parseJSON = withText "{{$type.HaskellName}}{{$field.HaskellName | pascal}}" $ \case
{{- range $e := $field.Enum}}
        "{{$e.Value}}" -> pure {{$e.Name}}
{{- end}}
        other -> fail $ "Unknown {{$type.HaskellName}}{{$field.HaskellName | pascal}}: " <> T.unpack other

instance ToJSON {{$type.HaskellName}}{{$field.HaskellName | pascal}} where
{{- range $e := $field.Enum}}
    toJSON {{$e.Name}} = "{{$e.Value}}"
{{- end}}
{{- end}}
{{- end}}
{{- end}}
{{- if eq $type.Kind "union"}}

-- | {{if $type.Description}}{{$type.Description}}{{else}}Discriminated union (tag: "{{$type.Tag}}").{{end}}
--
-- Pattern match to access variants:
--
-- @
-- case block of
{{- range $var := $type.Variants}}
--     {{$var.VariantName}} v -> handle{{$var.HaskellName}} v
{{- end}}
-- @
data {{$type.HaskellName}}
{{- range $i, $var := $type.Variants}}
    {{if eq $i 0}}={{else}}|{{end}} {{$var.VariantName}} !{{$var.HaskellName}}
    -- ^ {{if $var.Description}}{{$var.Description}}{{else}}{{$var.HaskellName}} variant{{end}}
{{- end}}
    deriving (Show, Eq, Generic)

instance FromJSON {{$type.HaskellName}} where
    parseJSON = withObject "{{$type.HaskellName}}" $ \o -> do
        tag <- o .: "{{$type.Tag}}" :: Parser Text
        case tag of
{{- range $var := $type.Variants}}
            "{{$var.Value}}" -> {{$var.VariantName}} <$> parseJSON (Object o)
{{- end}}
            other -> fail $ "Unknown {{$type.HaskellName}} type: " <> T.unpack other

instance ToJSON {{$type.HaskellName}} where
{{- range $i, $var := $type.Variants}}
    toJSON ({{$var.VariantName}} v) = toJSON v
{{- end}}
{{- range $var := $type.Variants}}

-- | {{if $var.Description}}{{$var.Description}}{{else}}{{$var.HaskellName}} variant of {{$type.HaskellName}}.{{end}}
data {{$var.HaskellName}} = {{$var.HaskellName}}
    { {{camel $var.HaskellName}}Type :: !Text
      -- ^ Discriminator field (always "{{$var.Value}}")
    } deriving (Show, Eq, Generic)

instance FromJSON {{$var.HaskellName}} where
    parseJSON = withObject "{{$var.HaskellName}}" $ \o ->
        {{$var.HaskellName}}
            <$> o .: "{{$type.Tag}}"

instance ToJSON {{$var.HaskellName}} where
    toJSON {{$var.HaskellName}}{..} = object
        [ "{{$type.Tag}}" .= {{camel $var.HaskellName}}Type
        ]
{{- end}}
{{- end}}
{{- end}}
{{end}}