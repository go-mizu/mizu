{{define "resources.hs.tmpl"}}{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- | Code generated by sdkhaskell. DO NOT EDIT.
--
-- Resource operations for {{.ModuleName}} API.
module {{.ModuleName}}.Resources
    ( -- * Resources
{{- range $i, $r := .Resources}}
{{- range $j, $m := $r.Methods}}
      {{if and (eq $i 0) (eq $j 0)}} {{else}},{{end}} {{$m.HaskellName}}
      , {{$m.HaskellName}}_
{{- if $m.IsStreaming}}
      , {{$m.HaskellName}}Stream
{{- end}}
{{- end}}
{{- end}}
    ) where

import Control.Exception (throwIO)
import Data.Text (Text)
import qualified Data.ByteString as BS
import Network.HTTP.Types (methodGet, methodPost, methodPut, methodDelete, methodPatch)
{{- if .HasSSE}}
import Conduit (ConduitT)
{{- end}}

import {{.ModuleName}}.Client (Client, requestJSON{{if .HasSSE}}, stream{{end}})
import {{.ModuleName}}.Types
import {{.ModuleName}}.Errors (SDKError, toException)
{{range $r := .Resources}}
-- -----------------------------------------------------------------------------
-- {{$r.ModuleName}} Resource
-- -----------------------------------------------------------------------------
{{- if $r.Description}}
-- {{$r.Description}}
{{- end}}
{{range $m := $r.Methods}}

-- | {{if $m.Description}}{{$m.Description}}{{else}}{{$m.Name}} operation for {{$r.Name}}.{{end}}
--
{{- if $m.HasInput}}
-- Takes a '{{$m.InputType}}' and returns{{if $m.HasOutput}} a '{{$m.OutputType}}'{{else}} nothing{{end}}.
{{- else}}
-- Returns{{if $m.HasOutput}} a '{{$m.OutputType}}'{{else}} nothing{{end}}.
{{- end}}
--
-- @
-- result <- {{$m.HaskellName}} client{{if $m.HasInput}} params{{end}}
-- case result of
--     Left err -> handleError err
--     Right response -> handleResponse response
-- @
{{$m.HaskellName}}
    :: Client
{{- if $m.HasInput}}
    -> {{$m.InputType}}
{{- end}}
{{- if $m.HasOutput}}
    -> IO (Either SDKError {{$m.OutputType}})
{{- else}}
    -> IO (Either SDKError ())
{{- end}}
{{$m.HaskellName}} client{{if $m.HasInput}} params{{end}} =
    requestJSON client method{{$m.HTTPMethod | pascal}} {{haskellQuote $m.HTTPPath}} {{if $m.HasInput}}(Just params){{else}}(Nothing :: Maybe ()){{end}}

-- | Same as '{{$m.HaskellName}}' but throws on error.
--
-- @
-- response <- {{$m.HaskellName}}_ client{{if $m.HasInput}} params{{end}}
-- @
{{$m.HaskellName}}_
    :: Client
{{- if $m.HasInput}}
    -> {{$m.InputType}}
{{- end}}
{{- if $m.HasOutput}}
    -> IO {{$m.OutputType}}
{{- else}}
    -> IO ()
{{- end}}
{{$m.HaskellName}}_ client{{if $m.HasInput}} params{{end}} = do
    result <- {{$m.HaskellName}} client{{if $m.HasInput}} params{{end}}
    case result of
        Left err -> throwIO $ toException err
        Right v  -> pure v
{{- if $m.IsStreaming}}

-- | Streaming version of '{{$m.HaskellName}}'.
--
-- Returns a conduit source of '{{$m.StreamItemType}}' events.
--
-- @
-- result <- {{$m.HaskellName}}Stream client params
-- case result of
--     Left err -> handleError err
--     Right source -> runConduit $ source .| mapM_C handleEvent
-- @
{{$m.HaskellName}}Stream
    :: Client
{{- if $m.HasInput}}
    -> {{$m.InputType}}
{{- end}}
    -> IO (Either SDKError (ConduitT () BS.ByteString IO ()))
{{$m.HaskellName}}Stream client{{if $m.HasInput}} params{{end}} =
    stream client method{{$m.HTTPMethod | pascal}} {{haskellQuote $m.HTTPPath}} {{if $m.HasInput}}params{{else}}(){{end}}
{{- end}}
{{- end}}
{{- end}}
{{end}}