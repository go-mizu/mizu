{{define "errors.hs.tmpl"}}{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}

-- | Code generated by sdkhaskell. DO NOT EDIT.
--
-- Error types for {{.ModuleName}} API.
module {{.ModuleName}}.Errors
    ( -- * Error Types
      SDKError(..)
    , APIError(..)
    , ErrorType(..)

      -- * Error Construction
    , fromResponse
    , fromException

      -- * Error Inspection
    , isRetryable
    , errorMessage
    , errorStatus
    , toException
    ) where

import Control.Exception (Exception, SomeException)
import Data.Aeson (FromJSON(..), withObject, (.:), (.:?), decode)
import qualified Data.ByteString.Lazy as LBS
import Data.Text (Text)
import qualified Data.Text as T
import GHC.Generics (Generic)
import Network.HTTP.Types (Status(..))

-- | Error type classification.
data ErrorType
    = BadRequest           -- ^ HTTP 400
    | Unauthorized         -- ^ HTTP 401
    | Forbidden            -- ^ HTTP 403
    | NotFound             -- ^ HTTP 404
    | UnprocessableEntity  -- ^ HTTP 422
    | RateLimited          -- ^ HTTP 429
    | ServerError          -- ^ HTTP 5xx
    | NetworkError         -- ^ Connection/network errors
    | ParseErrorType       -- ^ JSON parsing errors
    | TimeoutError         -- ^ Request timeout
    | StreamError          -- ^ SSE parsing errors
    deriving (Show, Eq, Ord, Bounded, Enum, Generic)

-- | API error details from server response.
data APIError = APIError
    { apiErrorType    :: !Text
    , apiErrorMessage :: !Text
    , apiErrorParam   :: !(Maybe Text)
    , apiErrorCode    :: !(Maybe Text)
    } deriving (Show, Eq, Generic)

instance FromJSON APIError where
    parseJSON = withObject "APIError" $ \o -> do
        err <- o .: "error"
        APIError
            <$> err .: "type"
            <*> err .: "message"
            <*> err .:? "param"
            <*> err .:? "code"

-- | SDK error type.
--
-- Pattern match to handle different error cases:
--
-- @
-- case err of
--     APIError' status apiErr ->
--         putStrLn $ \"API error: \" <> apiErrorMessage apiErr
--     ConnectionError msg ->
--         putStrLn $ \"Network error: \" <> msg
--     RateLimitError retryAfter _ ->
--         threadDelay (retryAfter * 1000000)
--     _ -> putStrLn $ \"Error: \" <> errorMessage err
-- @
data SDKError
    = APIError' !Int !APIError
      -- ^ API returned an error response
    | ConnectionError !Text
      -- ^ Network/connection error
    | TimeoutError' !Text
      -- ^ Request timed out
    | ParseError !Text
      -- ^ Failed to parse response
    | RateLimitError !Int !(Maybe APIError)
      -- ^ Rate limited (retry after N seconds)
    | StreamError' !Text
      -- ^ Error in SSE stream
    deriving (Show, Eq, Generic)

instance Exception SDKError

-- | Convert to a generic exception.
toException :: SDKError -> SomeException
toException = Control.Exception.toException

-- | Create an error from an HTTP response.
fromResponse :: Status -> LBS.ByteString -> SDKError
fromResponse status body =
    let code = statusCode status
        apiErr = decode body :: Maybe APIError
    in case code of
        400 -> APIError' code (maybe defaultErr id apiErr)
        401 -> APIError' code (maybe defaultErr id apiErr)
        403 -> APIError' code (maybe defaultErr id apiErr)
        404 -> APIError' code (maybe defaultErr id apiErr)
        422 -> APIError' code (maybe defaultErr id apiErr)
        429 -> RateLimitError (extractRetryAfter body) apiErr
        _ | code >= 500 -> APIError' code (maybe serverErr id apiErr)
          | otherwise -> APIError' code (maybe defaultErr id apiErr)
  where
    defaultErr = APIError "unknown_error" "Unknown error" Nothing Nothing
    serverErr = APIError "server_error" "Internal server error" Nothing Nothing

    extractRetryAfter :: LBS.ByteString -> Int
    extractRetryAfter _ = 60  -- Default retry after 60s

-- | Create an error from an exception.
fromException :: SomeException -> SDKError
fromException e = ConnectionError $ T.pack $ show e

-- | Check if an error is retryable.
--
-- @
-- when (isRetryable err) $ do
--     threadDelay 1000000
--     retry
-- @
isRetryable :: SDKError -> Bool
isRetryable (RateLimitError _ _) = True
isRetryable (ConnectionError _) = True
isRetryable (TimeoutError' _) = True
isRetryable (APIError' code _) = code >= 500
isRetryable _ = False

-- | Get human-readable error message.
errorMessage :: SDKError -> Text
errorMessage (APIError' _ err) = apiErrorMessage err
errorMessage (ConnectionError msg) = msg
errorMessage (TimeoutError' msg) = msg
errorMessage (ParseError msg) = msg
errorMessage (RateLimitError _ (Just err)) = apiErrorMessage err
errorMessage (RateLimitError secs Nothing) =
    "Rate limited. Retry after " <> T.pack (show secs) <> " seconds"
errorMessage (StreamError' msg) = msg

-- | Get HTTP status code if applicable.
errorStatus :: SDKError -> Maybe Int
errorStatus (APIError' code _) = Just code
errorStatus (RateLimitError _ _) = Just 429
errorStatus _ = Nothing
{{end}}