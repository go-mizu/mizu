{{define "client.dart.tmpl"}}// Code generated by sdkdart. DO NOT EDIT.

import 'dart:async';
import 'dart:convert';

import 'package:http/http.dart' as http;

import 'errors.dart';
import 'resources.dart';
import 'types.dart';
{{- if .HasSSE}}
import 'streaming.dart';
{{- end}}

// MARK: - Client Options

/// Authentication mode for API requests.
enum AuthMode {
  /// Bearer token authentication.
  bearer,

  /// Basic authentication.
  basic,

  /// No authentication.
  none,
}

/// Configuration options for the SDK client.
class ClientOptions {
  /// API key for authentication.
  final String? apiKey;

  /// Base URL for API requests.
  final String baseUrl;

  /// Request timeout.
  final Duration timeout;

  /// Maximum number of retry attempts for failed requests.
  final int maxRetries;

  /// Default headers to include in all requests.
  final Map<String, String> defaultHeaders;

  /// Authentication mode.
  final AuthMode authMode;

  const ClientOptions({
    this.apiKey,
    this.baseUrl = {{dartString .Client.BaseURL}},
    this.timeout = const Duration(seconds: 60),
    this.maxRetries = 2,
    this.defaultHeaders = {{if .Client.Headers}}const {
{{- range $i, $h := .Client.Headers}}
      {{dartString $h.K}}: {{dartString $h.V}},
{{- end}}
    }{{else}}const {}{{end}},
    this.authMode = AuthMode.bearer,
  });

  /// Creates a copy with modified fields.
  ClientOptions copyWith({
    String? apiKey,
    String? baseUrl,
    Duration? timeout,
    int? maxRetries,
    Map<String, String>? defaultHeaders,
    AuthMode? authMode,
  }) {
    return ClientOptions(
      apiKey: apiKey ?? this.apiKey,
      baseUrl: baseUrl ?? this.baseUrl,
      timeout: timeout ?? this.timeout,
      maxRetries: maxRetries ?? this.maxRetries,
      defaultHeaders: defaultHeaders ?? this.defaultHeaders,
      authMode: authMode ?? this.authMode,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientOptions &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          baseUrl == other.baseUrl &&
          timeout == other.timeout &&
          maxRetries == other.maxRetries &&
          authMode == other.authMode;

  @override
  int get hashCode => Object.hash(
        apiKey,
        baseUrl,
        timeout,
        maxRetries,
        authMode,
      );
}

// MARK: - Main Client
{{if .Service.Description}}
/// {{.Service.Description}}
{{end -}}
class {{.Service.Sanitized}} {
  /// Client configuration options.
  final ClientOptions options;

  final HttpClientWrapper _client;

{{- range .Resources}}
  /// Access to {{.Name}} operations.
  late final {{.ClassName}} {{.DartName}};
{{- end}}

  {{.Service.Sanitized}}({ClientOptions? options})
      : options = options ?? const ClientOptions(),
        _client = HttpClientWrapper(options ?? const ClientOptions()) {
{{- range .Resources}}
    {{.DartName}} = {{.ClassName}}(_client);
{{- end}}
  }

  /// Creates a new client with modified configuration.
  {{.Service.Sanitized}} copyWith({
    String? apiKey,
    String? baseUrl,
    Duration? timeout,
    int? maxRetries,
    Map<String, String>? defaultHeaders,
    AuthMode? authMode,
  }) {
    return {{.Service.Sanitized}}(
      options: options.copyWith(
        apiKey: apiKey,
        baseUrl: baseUrl,
        timeout: timeout,
        maxRetries: maxRetries,
        defaultHeaders: defaultHeaders,
        authMode: authMode,
      ),
    );
  }

  /// Closes the HTTP client and releases resources.
  void close() {
    _client.close();
  }
}

// MARK: - HTTP Client Wrapper

class HttpClientWrapper {
  final ClientOptions options;
  final http.Client _client;

  HttpClientWrapper(this.options) : _client = http.Client();

  Future<T> request<T>(
    String method,
    String path,
    T Function(Map<String, dynamic>) fromJson, {
    Object? body,
  }) async {
    Object? lastException;

    for (var attempt = 0; attempt <= options.maxRetries; attempt++) {
      try {
        final uri = Uri.parse('${options.baseUrl}$path');

        final request = http.Request(method, uri);
        _applyHeaders(request);
        _applyAuth(request);

        if (body != null) {
          request.headers['Content-Type'] = 'application/json';
          request.body = jsonEncode(body);
        }

        final streamedResponse = await _client
            .send(request)
            .timeout(options.timeout);

        final response = await http.Response.fromStream(streamedResponse);

        if (response.statusCode >= 400) {
          throw _parseErrorResponse(response);
        }

        final jsonBody = jsonDecode(response.body) as Map<String, dynamic>;
        return fromJson(jsonBody);
      } on SDKException {
        rethrow; // Don't retry SDK errors
      } on TimeoutException {
        throw const SDKTimeoutException();
      } catch (e) {
        lastException = e;
        if (attempt < options.maxRetries) {
          await Future.delayed(_backoff(attempt));
        }
      }
    }

    throw ConnectionException(lastException);
  }

  Future<void> requestVoid(
    String method,
    String path, {
    Object? body,
  }) async {
    Object? lastException;

    for (var attempt = 0; attempt <= options.maxRetries; attempt++) {
      try {
        final uri = Uri.parse('${options.baseUrl}$path');

        final request = http.Request(method, uri);
        _applyHeaders(request);
        _applyAuth(request);

        if (body != null) {
          request.headers['Content-Type'] = 'application/json';
          request.body = jsonEncode(body);
        }

        final streamedResponse = await _client
            .send(request)
            .timeout(options.timeout);

        final response = await http.Response.fromStream(streamedResponse);

        if (response.statusCode >= 400) {
          throw _parseErrorResponse(response);
        }

        return;
      } on SDKException {
        rethrow;
      } on TimeoutException {
        throw const SDKTimeoutException();
      } catch (e) {
        lastException = e;
        if (attempt < options.maxRetries) {
          await Future.delayed(_backoff(attempt));
        }
      }
    }

    throw ConnectionException(lastException);
  }

{{- if .HasSSE}}

  Stream<T> stream<T>(
    String method,
    String path,
    T Function(Map<String, dynamic>) fromJson, {
    Object? body,
  }) async* {
    final uri = Uri.parse('${options.baseUrl}$path');

    final request = http.Request(method, uri);
    _applyHeaders(request);
    _applyAuth(request);
    request.headers['Accept'] = 'text/event-stream';

    if (body != null) {
      request.headers['Content-Type'] = 'application/json';
      request.body = jsonEncode(body);
    }

    final response = await _client.send(request).timeout(options.timeout);

    if (response.statusCode >= 400) {
      final bodyText = await response.stream.bytesToString();
      throw _parseErrorFromBody(response.statusCode, bodyText);
    }

    yield* parseSSEStream(response.stream, fromJson);
  }
{{- end}}

  void _applyHeaders(http.Request request) {
    options.defaultHeaders.forEach((key, value) {
      request.headers[key] = value;
    });
  }

  void _applyAuth(http.Request request) {
    final apiKey = options.apiKey;
    if (apiKey != null) {
      switch (options.authMode) {
        case AuthMode.bearer:
          request.headers['Authorization'] = 'Bearer $apiKey';
        case AuthMode.basic:
          request.headers['Authorization'] = 'Basic $apiKey';
        case AuthMode.none:
          break;
      }
    }
  }

  SDKException _parseErrorResponse(http.Response response) {
    return _parseErrorFromBody(response.statusCode, response.body);
  }

  SDKException _parseErrorFromBody(int statusCode, String body) {
    String message;
    try {
      final jsonBody = jsonDecode(body);
      if (jsonBody is Map<String, dynamic>) {
        message = (jsonBody['message'] as String?) ??
            (jsonBody['error'] as String?) ??
            'HTTP $statusCode';
      } else {
        message = body.isNotEmpty ? body : 'HTTP $statusCode';
      }
    } catch (_) {
      message = body.isNotEmpty ? body : 'HTTP $statusCode';
    }

    return ApiException(
      statusCode: statusCode,
      message: message,
      body: body,
    );
  }

  Duration _backoff(int attempt) {
    const baseDelay = Duration(milliseconds: 500);
    return baseDelay * (1 << attempt); // Exponential backoff
  }

  void close() {
    _client.close();
  }
}
{{end}}
