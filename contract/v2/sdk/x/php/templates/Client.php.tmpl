{{define "Client.php.tmpl"}}<?php

declare(strict_types=1);

// Code generated by sdkphp. DO NOT EDIT.

namespace {{.Namespace}};

use {{.Namespace}}\Exceptions\ApiException;
use {{.Namespace}}\Exceptions\AuthenticationException;
use {{.Namespace}}\Exceptions\BadRequestException;
use {{.Namespace}}\Exceptions\ConnectionException;
use {{.Namespace}}\Exceptions\NotFoundException;
use {{.Namespace}}\Exceptions\PermissionDeniedException;
use {{.Namespace}}\Exceptions\RateLimitException;
use {{.Namespace}}\Exceptions\ServerException;
use {{.Namespace}}\Exceptions\UnprocessableEntityException;
{{- range .Resources}}
use {{$.Namespace}}\Resources\{{.ClassName}};
{{- end}}
use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
{{- if .Service.Description}}
 * {{.Service.Description}}
{{- else}}
 * SDK client for {{.Service.Name}}.
{{- end}}
 *
{{- range .Resources}}
 * @property-read {{.ClassName}} ${{.PHPName}}
{{- end}}
 */
final class Client
{
    private HttpClient $http;
    private ClientOptions $options;

    /** @var array<string, object> */
    private array $resources = [];

    /**
     * Creates a new SDK client.
     *
     * @param string|null $apiKey API key for authentication
     * @param ClientOptions|null $options Configuration options
     */
    public function __construct(
        ?string $apiKey = null,
        ?ClientOptions $options = null,
    ) {
        $this->options = $options ?? new ClientOptions();

        if ($apiKey !== null) {
            $this->options = $this->options->withApiKey($apiKey);
        }

        $this->http = $this->createHttpClient();
    }

    /**
     * Creates a new client with modified configuration.
     */
    public function withOptions(ClientOptions $options): self
    {
        return new self(null, $options);
    }

    /**
     * Magic getter for resource access.
     *
     * @param string $name Resource name
     * @return object Resource instance
     * @throws \InvalidArgumentException If resource doesn't exist
     */
    public function __get(string $name): object
    {
        if (!isset($this->resources[$name])) {
            $this->resources[$name] = match ($name) {
{{- range .Resources}}
                {{phpQuote .PHPName}} => new {{.ClassName}}($this),
{{- end}}
                default => throw new \InvalidArgumentException("Unknown resource: $name"),
            };
        }

        return $this->resources[$name];
    }

    /**
     * Performs an HTTP request.
     *
     * @internal
     * @template T
     * @param string $method HTTP method
     * @param string $path Request path
     * @param object|null $body Request body
     * @param class-string<T>|'array' $responseType Response type class or 'array'
     * @return T|array<string, mixed>|null
     * @throws ApiException
     */
    public function request(
        string $method,
        string $path,
        ?object $body = null,
        string $responseType = 'array',
    ): mixed {
        $options = [
            'headers' => [
                'Content-Type' => 'application/json',
                'Accept' => 'application/json',
            ],
        ];

        if ($body !== null) {
            $options['json'] = method_exists($body, 'toArray') ? $body->toArray() : $body;
        }

        try {
            $response = $this->http->request($method, $path, $options);
        } catch (ConnectException $e) {
            throw new ConnectionException("Connection failed: {$e->getMessage()}", $e);
        } catch (RequestException $e) {
            if ($e->hasResponse()) {
                $this->throwApiException($e->getResponse());
            }
            throw new ConnectionException("Request failed: {$e->getMessage()}", $e);
        }

        $statusCode = $response->getStatusCode();
        if ($statusCode >= 400) {
            $this->throwApiException($response);
        }

        if ($statusCode === 204) {
            return null;
        }

        $contents = $response->getBody()->getContents();
        if (empty($contents)) {
            return null;
        }

        $data = json_decode($contents, true);
        if ($data === null && json_last_error() !== JSON_ERROR_NONE) {
            return null;
        }

        if ($responseType === 'array') {
            return $data;
        }

        if (!method_exists($responseType, 'fromArray')) {
            return $data;
        }

        return $responseType::fromArray($data);
    }
{{- if .HasSSE}}

    /**
     * Performs a streaming HTTP request.
     *
     * @internal
     * @template T
     * @param string $method HTTP method
     * @param string $path Request path
     * @param object|null $body Request body
     * @param class-string<T>|'array' $itemType Item type class or 'array'
     * @return \Generator<int, T|array<string, mixed>>
     * @throws ApiException
     */
    public function stream(
        string $method,
        string $path,
        ?object $body = null,
        string $itemType = 'array',
    ): \Generator {
        $options = [
            'headers' => [
                'Content-Type' => 'application/json',
                'Accept' => 'text/event-stream',
                'Cache-Control' => 'no-cache',
            ],
            'stream' => true,
        ];

        if ($body !== null) {
            $options['json'] = method_exists($body, 'toArray') ? $body->toArray() : $body;
        }

        try {
            $response = $this->http->request($method, $path, $options);
        } catch (ConnectException $e) {
            throw new ConnectionException("Connection failed: {$e->getMessage()}", $e);
        } catch (RequestException $e) {
            if ($e->hasResponse()) {
                $this->throwApiException($e->getResponse());
            }
            throw new ConnectionException("Request failed: {$e->getMessage()}", $e);
        }

        if ($response->getStatusCode() >= 400) {
            $this->throwApiException($response);
        }

        $stream = $response->getBody();
        $buffer = '';

        while (!$stream->eof()) {
            $chunk = $stream->read(8192);
            $buffer .= $chunk;

            while (($pos = strpos($buffer, "\n\n")) !== false) {
                $eventText = substr($buffer, 0, $pos);
                $buffer = substr($buffer, $pos + 2);

                $data = $this->parseSSEData($eventText);
                if ($data === null || $data === '[DONE]') {
                    continue;
                }

                $parsed = json_decode($data, true);
                if ($parsed === null) {
                    continue;
                }

                if ($itemType === 'array') {
                    yield $parsed;
                } elseif (method_exists($itemType, 'fromArray')) {
                    yield $itemType::fromArray($parsed);
                } else {
                    yield $parsed;
                }
            }
        }
    }

    /**
     * Parses SSE event data.
     */
    private function parseSSEData(string $eventText): ?string
    {
        $lines = explode("\n", $eventText);
        $dataLines = [];

        foreach ($lines as $line) {
            if (str_starts_with($line, 'data:')) {
                $dataLines[] = ltrim(substr($line, 5));
            }
        }

        if (empty($dataLines)) {
            return null;
        }

        return implode("\n", $dataLines);
    }
{{- end}}

    /**
     * Creates the HTTP client with middleware.
     */
    private function createHttpClient(): HttpClient
    {
        $stack = HandlerStack::create();

        // Retry middleware
        $stack->push(Middleware::retry(
            function (int $retries, RequestInterface $request, ?ResponseInterface $response, ?\Throwable $exception): bool {
                if ($retries >= $this->options->maxRetries) {
                    return false;
                }

                if ($exception !== null) {
                    return true;
                }

                if ($response === null) {
                    return false;
                }

                $status = $response->getStatusCode();
                return $status === 429 || $status >= 500;
            },
            function (int $retries): int {
                return (int) (500 * pow(2, $retries));
            }
        ));

        // Auth middleware
        $stack->push(Middleware::mapRequest(function (RequestInterface $request): RequestInterface {
            $apiKey = $this->options->apiKey;
            if ($apiKey === null) {
                return $request;
            }

            return match ($this->options->authMode) {
                AuthMode::Bearer => $request->withHeader('Authorization', "Bearer $apiKey"),
                AuthMode::Basic => $request->withHeader('Authorization', "Basic " . base64_encode($apiKey)),
                AuthMode::Header => $request->withHeader('X-API-Key', $apiKey),
                AuthMode::None => $request,
            };
        }));

        // Default headers middleware
        $stack->push(Middleware::mapRequest(function (RequestInterface $request): RequestInterface {
            foreach ($this->options->defaultHeaders as $name => $value) {
                $request = $request->withHeader($name, $value);
            }
            return $request;
        }));

        return new HttpClient([
            'handler' => $stack,
            'base_uri' => $this->options->baseUrl,
            'timeout' => $this->options->timeout,
            'connect_timeout' => $this->options->connectTimeout,
            'http_errors' => false,
        ]);
    }

    /**
     * Throws an appropriate API exception based on the response.
     *
     * @throws ApiException
     */
    private function throwApiException(ResponseInterface $response): never
    {
        $statusCode = $response->getStatusCode();
        $body = $response->getBody()->getContents();

        $message = "HTTP $statusCode";
        $decoded = json_decode($body, true);
        if (is_array($decoded)) {
            $message = $decoded['message'] ?? $decoded['error'] ?? $message;
        }

        $headers = [];
        foreach ($response->getHeaders() as $name => $values) {
            $headers[$name] = $values;
        }

        throw match ($statusCode) {
            400 => new BadRequestException($message, $statusCode, $body, $headers),
            401 => new AuthenticationException($message, $statusCode, $body, $headers),
            403 => new PermissionDeniedException($message, $statusCode, $body, $headers),
            404 => new NotFoundException($message, $statusCode, $body, $headers),
            422 => new UnprocessableEntityException($message, $statusCode, $body, $headers),
            429 => new RateLimitException($message, $statusCode, $body, $headers),
            default => $statusCode >= 500
                ? new ServerException($message, $statusCode, $body, $headers)
                : new ApiException($message, $statusCode, $body, $headers),
        };
    }
}
{{end}}