{{define "client.ex.tmpl"}}# Code generated by sdkelixir. DO NOT EDIT.

defmodule {{.ModuleName}}.Client do
  @moduledoc """
  HTTP client for {{.ModuleName}} API.

  This module handles all HTTP communication including authentication,
  retries, and error handling.

  ## Usage

      client = {{.ModuleName}}.Client.new(api_key: "your-api-key")

      # Make a request
      {:ok, response} = {{.ModuleName}}.Client.request(client,
        method: :post,
        path: "/v1/resource",
        body: %{key: "value"}
      )

  ## Streaming

      client
      |> {{.ModuleName}}.Client.stream(method: :post, path: "/v1/resource", body: body)
      |> Enum.each(fn event -> IO.inspect(event) end)
  """

  alias {{.ModuleName}}.Config
  alias {{.ModuleName}}.Errors

  @type t :: %__MODULE__{
          config: Config.t(),
          req: Req.Request.t()
        }

  defstruct [:config, :req]

  @doc """
  Creates a new client with the given options.

  ## Options

  See `{{.ModuleName}}.client/1` for available options.

  ## Examples

      iex> client = Client.new(api_key: "sk-...")
      %Client{...}
  """
  @spec new(keyword()) :: t()
  def new(opts \\ []) do
    config = Config.new(opts)
    req = build_req(config)
    %__MODULE__{config: config, req: req}
  end

  @doc """
  Performs an HTTP request.

  Returns `{:ok, response}` on success or `{:error, exception}` on failure.

  ## Options

    * `:method` - HTTP method (required): `:get`, `:post`, `:put`, `:patch`, `:delete`
    * `:path` - Request path (required)
    * `:body` - Request body (optional)
    * `:headers` - Additional headers (optional)

  ## Examples

      {:ok, response} = Client.request(client,
        method: :post,
        path: "/v1/messages",
        body: %{model: "model-name", messages: [...]}
      )
  """
  @spec request(t(), keyword()) :: {:ok, map() | nil} | {:error, Exception.t()}
  def request(%__MODULE__{req: req}, opts) do
    method = Keyword.fetch!(opts, :method)
    path = Keyword.fetch!(opts, :path)
    body = Keyword.get(opts, :body)
    headers = Keyword.get(opts, :headers, [])

    request_opts =
      [method: method, url: path]
      |> maybe_add_body(body)
      |> Keyword.merge(headers: headers)

    case Req.request(req, request_opts) do
      {:ok, %Req.Response{status: status, body: body}} when status in 200..299 ->
        {:ok, body}

      {:ok, %Req.Response{status: 204}} ->
        {:ok, nil}

      {:ok, %Req.Response{status: status, body: body}} ->
        {:error, Errors.from_response(status, body)}

      {:error, %Req.TransportError{reason: :timeout}} ->
        {:error, %Errors.TimeoutError{message: "Request timed out"}}

      {:error, %Req.TransportError{reason: reason}} ->
        {:error, %Errors.ConnectionError{message: "Connection failed: #{inspect(reason)}"}}

      {:error, exception} ->
        {:error, %Errors.ConnectionError{message: Exception.message(exception)}}
    end
  end

  @doc """
  Performs an HTTP request, raising on error.

  Same as `request/2` but raises the exception on failure.

  ## Examples

      response = Client.request!(client,
        method: :post,
        path: "/v1/messages",
        body: %{...}
      )
  """
  @spec request!(t(), keyword()) :: map() | nil
  def request!(client, opts) do
    case request(client, opts) do
      {:ok, result} -> result
      {:error, exception} -> raise exception
    end
  end
{{if .HasSSE}}

  @doc """
  Performs a streaming SSE request.

  Returns a `Stream` that yields parsed SSE events.

  ## Options

    * `:method` - HTTP method (required)
    * `:path` - Request path (required)
    * `:body` - Request body (optional)

  ## Examples

      client
      |> Client.stream(method: :post, path: "/v1/messages", body: body)
      |> Enum.each(fn event ->
        IO.write(event["delta"]["text"] || "")
      end)
  """
  @spec stream(t(), keyword()) :: Enumerable.t()
  def stream(%__MODULE__{req: req, config: config}, opts) do
    method = Keyword.fetch!(opts, :method)
    path = Keyword.fetch!(opts, :path)
    body = Keyword.get(opts, :body)

    Stream.resource(
      fn -> start_stream(req, config, method, path, body) end,
      &next_event/1,
      &close_stream/1
    )
  end

  defp start_stream(req, _config, method, path, body) do
    request_opts =
      [
        method: method,
        url: path,
        into: :self,
        receive_timeout: :infinity,
        headers: [{"accept", "text/event-stream"}]
      ]
      |> maybe_add_body(body)

    case Req.request(req, request_opts) do
      {:ok, response} ->
        {:streaming, response, ""}

      {:error, reason} ->
        {:error, reason}
    end
  end

  defp next_event({:error, reason}) do
    {:halt, {:error, reason}}
  end

  defp next_event({:done, _}) do
    {:halt, :done}
  end

  defp next_event({:streaming, response, buffer}) do
    ref = response.async.ref

    receive do
      {^ref, {:data, chunk}} ->
        process_sse_chunk(response, buffer <> chunk)

      {^ref, :done} ->
        {:halt, :done}

      {^ref, {:error, reason}} ->
        {:halt, {:error, reason}}
    after
      60_000 ->
        {:halt, {:error, :timeout}}
    end
  end

  defp process_sse_chunk(response, buffer) do
    case String.split(buffer, "\n\n", parts: 2) do
      [event, rest] ->
        case parse_sse_event(event) do
          {:ok, :done} ->
            {:halt, {:done, rest}}

          {:ok, data} ->
            {[data], {:streaming, response, rest}}

          :skip ->
            next_event({:streaming, response, rest})
        end

      [incomplete] ->
        next_event({:streaming, response, incomplete})
    end
  end

  defp parse_sse_event(event) do
    lines = String.split(event, "\n")

    data =
      lines
      |> Enum.filter(&String.starts_with?(&1, "data:"))
      |> Enum.map(&String.trim_leading(&1, "data:"))
      |> Enum.map(&String.trim/1)
      |> Enum.join("\n")

    cond do
      data == "" -> :skip
      data == "[DONE]" -> {:ok, :done}
      true -> {:ok, Jason.decode!(data)}
    end
  rescue
    e in Jason.DecodeError ->
      {:error, %Errors.StreamError{message: "Failed to parse SSE event", data: e}}
  end

  defp close_stream(:done), do: :ok
  defp close_stream({:done, _}), do: :ok
  defp close_stream({:error, _}), do: :ok
  defp close_stream({:streaming, response, _buffer}) do
    Req.cancel_async_response(response)
    :ok
  rescue
    _ -> :ok
  end
{{end}}

  # Private functions

  defp build_req(config) do
    Req.new(
      base_url: config.base_url,
      headers: build_headers(config),
      receive_timeout: config.timeout,
      retry: :transient,
      max_retries: config.max_retries
    )
  end

  defp build_headers(config) do
    headers = [
      {"content-type", "application/json"},
      {"accept", "application/json"}
    ]

    headers = headers ++ Enum.map(config.headers, fn {k, v} -> {k, v} end)
    apply_auth(headers, config)
  end

  defp apply_auth(headers, %{api_key: nil}), do: headers

  defp apply_auth(headers, %{api_key: key, auth_mode: :bearer}) do
    [{"authorization", "Bearer #{key}"} | headers]
  end

  defp apply_auth(headers, %{api_key: key, auth_mode: :basic}) do
    encoded = Base.encode64(key)
    [{"authorization", "Basic #{encoded}"} | headers]
  end

  defp apply_auth(headers, %{api_key: key, auth_mode: :header}) do
    [{"x-api-key", key} | headers]
  end

  defp apply_auth(headers, %{auth_mode: :none}), do: headers

  defp maybe_add_body(opts, nil), do: opts
  defp maybe_add_body(opts, body), do: Keyword.put(opts, :json, body)
end
{{end}}