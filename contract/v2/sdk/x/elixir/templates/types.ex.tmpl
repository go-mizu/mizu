{{define "types.ex.tmpl"}}# Code generated by sdkelixir. DO NOT EDIT.

defmodule {{.ModuleName}}.Types do
  @moduledoc """
  Type definitions for {{.ModuleName}} API.

  All types are defined as structs with full typespecs for Dialyzer compatibility.
  """
{{- if .HasDate}}

  @doc false
  def parse_datetime(nil), do: nil

  def parse_datetime(str) when is_binary(str) do
    case DateTime.from_iso8601(str) do
      {:ok, dt, _offset} -> dt
      {:error, _} -> str
    end
  end

  def parse_datetime(other), do: other
{{- end}}

  @doc false
  def from_map(module, nil), do: nil

  def from_map(module, map) when is_map(map) do
    # Convert string keys to atoms safely
    map =
      map
      |> Enum.map(fn
        {k, v} when is_binary(k) ->
          try do
            {String.to_existing_atom(k), v}
          rescue
            ArgumentError -> {String.to_atom(k), v}
          end

        kv ->
          kv
      end)
      |> Map.new()

    struct(module, map)
  end

  @doc false
  def to_map(nil), do: nil

  def to_map(%{__struct__: _} = struct) do
    struct
    |> Map.from_struct()
    |> Enum.reject(fn {_k, v} -> is_nil(v) end)
    |> Enum.map(fn {k, v} -> {k, serialize_value(v)} end)
    |> Map.new()
  end

  defp serialize_value(%{__struct__: _} = struct), do: to_map(struct)
  defp serialize_value(list) when is_list(list), do: Enum.map(list, &serialize_value/1)
  defp serialize_value(%DateTime{} = dt), do: DateTime.to_iso8601(dt)
  defp serialize_value(%NaiveDateTime{} = dt), do: NaiveDateTime.to_iso8601(dt)
  defp serialize_value(value), do: value
end
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}

defmodule {{$.ModuleName}}.Types.{{$type.ElixirName}} do
  @moduledoc """
{{- if $type.Description}}
  {{$type.Description}}
{{- else}}
  {{$type.ElixirName}} type.
{{- end}}
  """

  @type t :: %__MODULE__{
{{- $fields := $type.Fields}}
{{- $lastIdx := len $fields | add -1}}
{{- range $i, $field := $fields}}
          {{$field.ElixirName}}: {{$field.TypeSpec}}{{if lt $i $lastIdx}},{{end}}
{{- end}}
        }

  @derive Jason.Encoder
  defstruct [
{{- range $i, $field := $fields}}
    :{{$field.ElixirName}}{{if lt $i $lastIdx}},{{end}}
{{- end}}
  ]
{{range $field := $type.Fields}}
{{- if $field.Enum}}

  @doc "Valid values for `{{$field.ElixirName}}`."
  defmodule {{$field.ElixirName | pascal}} do
    @moduledoc false
{{- range $e := $field.Enum}}
    @{{$e.Name}} {{elixirQuote $e.Value}}
    def {{$e.Name}}, do: @{{$e.Name}}
{{- end}}

    @all [
{{- range $i, $e := $field.Enum}}
      @{{$e.Name}}{{if lt $i (sub (len $field.Enum) 1)}},{{end}}
{{- end}}
    ]

    @spec all() :: [String.t()]
    def all, do: @all

    @spec valid?(String.t()) :: boolean()
    def valid?(value), do: value in @all
  end
{{- end}}
{{- end}}

  @doc """
  Creates a new {{$type.ElixirName}} from a map.
  """
  @spec from_map(map() | nil) :: t() | nil
  def from_map(nil), do: nil

  def from_map(map) when is_map(map) do
    {{$.ModuleName}}.Types.from_map(__MODULE__, map)
  end

  @doc """
  Converts to a map for JSON encoding.
  """
  @spec to_map(t()) :: map()
  def to_map(struct), do: {{$.ModuleName}}.Types.to_map(struct)
end
{{- end}}
{{- if eq $type.Kind "slice"}}

defmodule {{$.ModuleName}}.Types.{{$type.ElixirName}} do
  @moduledoc """
{{- if $type.Description}}
  {{$type.Description}}
{{- else}}
  List type alias for {{$type.Name}}.
{{- end}}
  """

  @type t :: [{{$type.Elem}}]

  @doc "Creates a list from raw data."
  @spec from_list(list() | nil) :: t() | nil
  def from_list(nil), do: nil
  def from_list(list) when is_list(list), do: list
end
{{- end}}
{{- if eq $type.Kind "map"}}

defmodule {{$.ModuleName}}.Types.{{$type.ElixirName}} do
  @moduledoc """
{{- if $type.Description}}
  {{$type.Description}}
{{- else}}
  Map type alias for {{$type.Name}}.
{{- end}}
  """

  @type t :: %{String.t() => {{$type.Elem}}}

  @doc "Creates a map from raw data."
  @spec from_map(map() | nil) :: t() | nil
  def from_map(nil), do: nil
  def from_map(map) when is_map(map), do: map
end
{{- end}}
{{- if eq $type.Kind "union"}}

defmodule {{$.ModuleName}}.Types.{{$type.ElixirName}} do
  @moduledoc """
{{- if $type.Description}}
  {{$type.Description}}
{{- else}}
  Discriminated union type (tag: "{{$type.Tag}}").
{{- end}}
  """

  alias {{$.ModuleName}}.Types.{
{{- range $i, $var := $type.Variants}}
    {{$var.ElixirName}}{{if lt $i (sub (len $type.Variants) 1)}},{{end}}
{{- end}}
  }

  @type t ::
{{- range $i, $var := $type.Variants}}
          {{$var.ElixirName}}.t(){{if lt $i (sub (len $type.Variants) 1)}} |{{end}}
{{- end}}

  @doc """
  Creates the appropriate variant from a map.

  Dispatches based on the "{{$type.Tag}}" field.

  ## Examples

      iex> {{$type.ElixirName}}.from_map(%{"{{$type.Tag}}" => "{{(index $type.Variants 0).Value}}", ...})
      %{{(index $type.Variants 0).ElixirName}}{...}
  """
  @spec from_map(map() | nil) :: t() | nil
  def from_map(nil), do: nil
{{- range $var := $type.Variants}}

  def from_map(%{"{{$type.Tag}}" => {{elixirQuote $var.Value}}} = map) do
    {{$var.ElixirName}}.from_map(map)
  end

  def from_map(%{{"{"}}{{$type.Tag}}: {{elixirQuote $var.Value}}{{"}"}} = map) do
    {{$var.ElixirName}}.from_map(map)
  end
{{- end}}

  def from_map(map) do
    raise ArgumentError, "Unknown {{$type.ElixirName}} type: #{inspect(map)}"
  end
end
{{- range $var := $type.Variants}}

defmodule {{$.ModuleName}}.Types.{{$var.ElixirName}} do
  @moduledoc """
{{- if $var.Description}}
  {{$var.Description}}
{{- else}}
  {{$var.ElixirName}} variant of {{$type.ElixirName}}.
{{- end}}
  """

  @type t :: %__MODULE__{
          {{$type.Tag}}: String.t()
        }

  @derive Jason.Encoder
  defstruct {{$type.Tag}}: {{elixirQuote $var.Value}}

  @doc "Creates from a map."
  @spec from_map(map() | nil) :: t() | nil
  def from_map(nil), do: nil

  def from_map(map) when is_map(map) do
    {{$.ModuleName}}.Types.from_map(__MODULE__, map)
  end

  @doc "Converts to a map."
  @spec to_map(t()) :: map()
  def to_map(struct), do: {{$.ModuleName}}.Types.to_map(struct)
end
{{- end}}
{{- end}}
{{- end}}
{{end}}