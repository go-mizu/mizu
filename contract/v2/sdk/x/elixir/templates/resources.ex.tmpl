{{define "resources.ex.tmpl"}}# Code generated by sdkelixir. DO NOT EDIT.
{{range $res := .Resources}}
defmodule {{$.ModuleName}}.Resources.{{$res.ModuleName}} do
  @moduledoc """
{{- if $res.Description}}
  {{$res.Description}}
{{- else}}
  Operations for {{$res.Name}}.
{{- end}}
  """

  alias {{$.ModuleName}}.Client
  alias {{$.ModuleName}}.Types
{{range $method := $res.Methods}}

  @doc """
{{- if $method.Description}}
  {{$method.Description}}
{{- else}}
  Performs the {{$method.Name}} operation.
{{- end}}

  ## Parameters

    * `client` - The API client
{{- if $method.InputIsStruct}}
    * `params` - Request parameters (keyword list or map):
{{- range $field := $method.InputFields}}
      * `{{$field.AtomName}}` - {{if $field.Description}}{{$field.Description}}{{else}}{{$field.ElixirType}}{{end}}{{if $field.Optional}} (optional){{end}}
{{- end}}
{{- else if $method.HasInput}}
    * `params` - Request parameters
{{- end}}

  ## Returns

{{- if $method.HasOutput}}
    * `{:ok, %Types.{{$method.OutputType}}{}}` - Success
{{- else}}
    * `{:ok, nil}` - Success
{{- end}}
    * `{:error, exception}` - Failure

  ## Examples

{{- if $method.InputIsStruct}}
{{- $firstRequired := ""}}
{{- range $field := $method.InputFields}}
{{- if not $field.Optional}}
{{- if eq $firstRequired ""}}
{{- $firstRequired = $field.ElixirName}}
{{- end}}
{{- end}}
{{- end}}

      {:ok, response} = {{$.ModuleName}}.Resources.{{$res.ModuleName}}.{{$method.ElixirName}}(client,
{{- if ne $firstRequired ""}}
        {{$firstRequired}}: "value"
{{- end}}
      )
{{- else}}

      {:ok, response} = {{$.ModuleName}}.Resources.{{$res.ModuleName}}.{{$method.ElixirName}}(client, params)
{{- end}}
  """
{{- if $method.HasInput}}
  @spec {{$method.ElixirName}}(Client.t(), keyword() | map()) :: {:ok, {{if $method.HasOutput}}Types.{{$method.OutputType}}.t(){{else}}nil{{end}}} | {:error, Exception.t()}
  def {{$method.ElixirName}}(client, params) do
    body = build_body(params)

    case Client.request(client, method: {{elixirAtom (lower $method.HTTPMethod)}}, path: {{elixirQuote $method.HTTPPath}}, body: body) do
{{- if $method.HasOutput}}
      {:ok, response} -> {:ok, Types.{{$method.OutputType}}.from_map(response)}
{{- else}}
      {:ok, _response} -> {:ok, nil}
{{- end}}
      {:error, _} = error -> error
    end
  end
{{- else}}
  @spec {{$method.ElixirName}}(Client.t()) :: {:ok, {{if $method.HasOutput}}Types.{{$method.OutputType}}.t(){{else}}nil{{end}}} | {:error, Exception.t()}
  def {{$method.ElixirName}}(client) do
    case Client.request(client, method: {{elixirAtom (lower $method.HTTPMethod)}}, path: {{elixirQuote $method.HTTPPath}}) do
{{- if $method.HasOutput}}
      {:ok, response} -> {:ok, Types.{{$method.OutputType}}.from_map(response)}
{{- else}}
      {:ok, _response} -> {:ok, nil}
{{- end}}
      {:error, _} = error -> error
    end
  end
{{- end}}

  @doc """
  Same as `{{$method.ElixirName}}/{{if $method.HasInput}}2{{else}}1{{end}}` but raises on error.
  """
{{- if $method.HasInput}}
  @spec {{$method.ElixirName}}!(Client.t(), keyword() | map()) :: {{if $method.HasOutput}}Types.{{$method.OutputType}}.t(){{else}}nil{{end}}
  def {{$method.ElixirName}}!(client, params) do
    case {{$method.ElixirName}}(client, params) do
      {:ok, result} -> result
      {:error, exception} -> raise exception
    end
  end
{{- else}}
  @spec {{$method.ElixirName}}!(Client.t()) :: {{if $method.HasOutput}}Types.{{$method.OutputType}}.t(){{else}}nil{{end}}
  def {{$method.ElixirName}}!(client) do
    case {{$method.ElixirName}}(client) do
      {:ok, result} -> result
      {:error, exception} -> raise exception
    end
  end
{{- end}}
{{- if $method.IsStreaming}}

  @doc """
  Streaming version of `{{$method.ElixirName}}/{{if $method.HasInput}}2{{else}}1{{end}}`.

  Returns a `Stream` of events.

  ## Examples

      # With Enum
      client
      |> {{$.ModuleName}}.Resources.{{$res.ModuleName}}.{{$method.ElixirName}}_stream(params)
      |> Enum.each(fn event ->
        IO.inspect(event)
      end)

      # With Stream (lazy)
      client
      |> {{$.ModuleName}}.Resources.{{$res.ModuleName}}.{{$method.ElixirName}}_stream(params)
      |> Stream.take_while(fn event -> event.type != "done" end)
      |> Enum.to_list()
  """
{{- if $method.HasInput}}
  @spec {{$method.ElixirName}}_stream(Client.t(), keyword() | map()) :: Enumerable.t()
  def {{$method.ElixirName}}_stream(client, params) do
    body = build_body(params) |> Map.put(:stream, true)

    client
    |> Client.stream(method: {{elixirAtom (lower $method.HTTPMethod)}}, path: {{elixirQuote $method.HTTPPath}}, body: body)
{{- if $method.StreamItemType}}
    |> Stream.map(&Types.{{$method.StreamItemType}}.from_map/1)
{{- end}}
  end
{{- else}}
  @spec {{$method.ElixirName}}_stream(Client.t()) :: Enumerable.t()
  def {{$method.ElixirName}}_stream(client) do
    body = %{stream: true}

    client
    |> Client.stream(method: {{elixirAtom (lower $method.HTTPMethod)}}, path: {{elixirQuote $method.HTTPPath}}, body: body)
{{- if $method.StreamItemType}}
    |> Stream.map(&Types.{{$method.StreamItemType}}.from_map/1)
{{- end}}
  end
{{- end}}
{{- end}}
{{- end}}

  # Private helpers

  defp build_body(params) when is_list(params), do: Map.new(params)
  defp build_body(params) when is_map(params), do: params
end
{{end}}
{{end}}