{{define "errors.ex.tmpl"}}# Code generated by sdkelixir. DO NOT EDIT.

defmodule {{.ModuleName}}.Errors do
  @moduledoc """
  Error types for {{.ModuleName}} API.

  All errors are Elixir exceptions that can be raised or pattern matched.

  ## Error Hierarchy

      SDKError (base error)
      ├── ConnectionError (network issues)
      ├── TimeoutError (request timeout)
      ├── StreamError (SSE parsing error)
      └── APIError (HTTP 4xx/5xx)
          ├── BadRequestError (400)
          ├── AuthenticationError (401)
          ├── PermissionDeniedError (403)
          ├── NotFoundError (404)
          ├── UnprocessableEntityError (422)
          ├── RateLimitError (429)
          └── InternalServerError (5xx)

  ## Usage

      case {{.ModuleName}}.Resources.Messages.create(client, params) do
        {:ok, response} ->
          # Handle success

        {:error, %{{.ModuleName}}.Errors.RateLimitError{retry_after: retry}} ->
          Process.sleep(retry * 1000)
          # Retry...

        {:error, %{{.ModuleName}}.Errors.AuthenticationError{}} ->
          # Handle auth error

        {:error, %{{.ModuleName}}.Errors.APIError{status: status, message: msg}} ->
          # Handle other API errors

        {:error, exception} ->
          # Handle any error
      end
  """

  defmodule SDKError do
    @moduledoc "Base error for all SDK errors."
    defexception [:message]

    @type t :: %__MODULE__{message: String.t()}

    @impl true
    def message(%{message: message}), do: message
  end

  defmodule APIError do
    @moduledoc """
    Base error for API errors (HTTP 4xx/5xx).

    All API errors include:
      * `message` - Human-readable error message
      * `status` - HTTP status code
      * `body` - Raw response body
    """
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "API Error (#{status}): #{msg}"
    end
  end

  defmodule BadRequestError do
    @moduledoc "HTTP 400 Bad Request - Invalid request parameters."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Bad Request (#{status}): #{msg}"
    end
  end

  defmodule AuthenticationError do
    @moduledoc "HTTP 401 Unauthorized - Invalid or missing API key."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Authentication Error (#{status}): #{msg}"
    end
  end

  defmodule PermissionDeniedError do
    @moduledoc "HTTP 403 Forbidden - Insufficient permissions."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Permission Denied (#{status}): #{msg}"
    end
  end

  defmodule NotFoundError do
    @moduledoc "HTTP 404 Not Found - Resource not found."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Not Found (#{status}): #{msg}"
    end
  end

  defmodule UnprocessableEntityError do
    @moduledoc "HTTP 422 Unprocessable Entity - Validation failed."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Unprocessable Entity (#{status}): #{msg}"
    end
  end

  defmodule RateLimitError do
    @moduledoc """
    HTTP 429 Too Many Requests - Rate limit exceeded.

    The `retry_after` field may contain the number of seconds to wait
    before retrying (from the Retry-After header).
    """
    defexception [:message, :status, :body, :retry_after]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term(),
            retry_after: integer() | nil
          }

    @impl true
    def message(%{message: msg, status: status, retry_after: nil}) do
      "Rate Limit Exceeded (#{status}): #{msg}"
    end

    def message(%{message: msg, status: status, retry_after: retry}) do
      "Rate Limit Exceeded (#{status}): #{msg} - retry after #{retry}s"
    end
  end

  defmodule InternalServerError do
    @moduledoc "HTTP 5xx Server Error - Server-side error."
    defexception [:message, :status, :body]

    @type t :: %__MODULE__{
            message: String.t(),
            status: integer(),
            body: term()
          }

    @impl true
    def message(%{message: msg, status: status}) do
      "Internal Server Error (#{status}): #{msg}"
    end
  end

  defmodule ConnectionError do
    @moduledoc "Network/connection error - Failed to connect to API."
    defexception [:message]

    @type t :: %__MODULE__{message: String.t()}

    @impl true
    def message(%{message: msg}), do: "Connection Error: #{msg}"
  end

  defmodule TimeoutError do
    @moduledoc "Request timeout - The request took too long."
    defexception [:message]

    @type t :: %__MODULE__{message: String.t()}

    @impl true
    def message(%{message: msg}), do: "Timeout: #{msg}"
  end

  defmodule StreamError do
    @moduledoc "Error parsing SSE stream."
    defexception [:message, :data]

    @type t :: %__MODULE__{
            message: String.t(),
            data: term()
          }

    @impl true
    def message(%{message: msg}), do: "Stream Error: #{msg}"
  end

  @doc """
  Creates an appropriate error from an HTTP response.

  ## Examples

      iex> Errors.from_response(401, %{"message" => "Invalid API key"})
      %AuthenticationError{message: "Invalid API key", status: 401, ...}
  """
  @spec from_response(integer(), term()) :: Exception.t()
  def from_response(status, body) do
    message = extract_message(body)

    case status do
      400 ->
        %BadRequestError{message: message, status: status, body: body}

      401 ->
        %AuthenticationError{message: message, status: status, body: body}

      403 ->
        %PermissionDeniedError{message: message, status: status, body: body}

      404 ->
        %NotFoundError{message: message, status: status, body: body}

      422 ->
        %UnprocessableEntityError{message: message, status: status, body: body}

      429 ->
        %RateLimitError{message: message, status: status, body: body, retry_after: nil}

      s when s in 500..599 ->
        %InternalServerError{message: message, status: status, body: body}

      _ ->
        %APIError{message: message, status: status, body: body}
    end
  end

  @doc """
  Extracts the error message from a response body.
  """
  @spec extract_message(term()) :: String.t()
  def extract_message(%{"message" => msg}) when is_binary(msg), do: msg
  def extract_message(%{message: msg}) when is_binary(msg), do: msg
  def extract_message(%{"error" => %{"message" => msg}}) when is_binary(msg), do: msg
  def extract_message(%{error: %{message: msg}}) when is_binary(msg), do: msg
  def extract_message(%{"error" => msg}) when is_binary(msg), do: msg
  def extract_message(%{error: msg}) when is_binary(msg), do: msg
  def extract_message(body) when is_binary(body), do: body
  def extract_message(_), do: "Unknown error"
end
{{end}}