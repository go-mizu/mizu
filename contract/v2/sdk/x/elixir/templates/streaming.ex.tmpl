{{define "streaming.ex.tmpl"}}# Code generated by sdkelixir. DO NOT EDIT.

defmodule {{.ModuleName}}.Streaming do
  @moduledoc """
  Server-Sent Events (SSE) streaming utilities.

  This module provides utilities for parsing and handling SSE streams.
  Most users won't need to use this directly - the resource modules
  handle streaming automatically.

  ## SSE Format

  Server-Sent Events are text-based messages in the format:

      data: {"key": "value"}

      data: {"another": "event"}

      data: [DONE]

  Events are separated by double newlines.
  """

  alias {{.ModuleName}}.Errors

  @type event :: %{
          optional(:id) => String.t(),
          optional(:event) => String.t(),
          :data => term()
        }

  @doc """
  Parses an SSE event string into a map.

  ## Examples

      iex> Streaming.parse_event("data: {\\"text\\": \\"hello\\"}")
      {:ok, %{"text" => "hello"}}

      iex> Streaming.parse_event("data: [DONE]")
      {:ok, :done}

      iex> Streaming.parse_event("")
      :skip
  """
  @spec parse_event(String.t()) :: {:ok, term()} | {:error, term()} | :skip
  def parse_event(event_string) do
    lines = String.split(event_string, "\n")

    data =
      lines
      |> Enum.filter(&String.starts_with?(&1, "data:"))
      |> Enum.map(fn line ->
        line
        |> String.trim_leading("data:")
        |> String.trim()
      end)
      |> Enum.join("\n")

    cond do
      data == "" -> :skip
      data == "[DONE]" -> {:ok, :done}
      true -> parse_json(data)
    end
  end

  @doc """
  Transforms a stream of raw chunks into parsed SSE events.

  ## Examples

      raw_stream
      |> Streaming.parse_stream()
      |> Enum.each(&process_event/1)
  """
  @spec parse_stream(Enumerable.t()) :: Enumerable.t()
  def parse_stream(chunk_stream) do
    chunk_stream
    |> Stream.transform("", &accumulate_and_parse/2)
    |> Stream.filter(fn
      {:ok, _} -> true
      _ -> false
    end)
    |> Stream.map(fn {:ok, event} -> event end)
    |> Stream.take_while(fn event -> event != :done end)
  end

  @doc """
  Collects all events from a stream into a list.

  This is a convenience function for when you want all events at once.

  ## Examples

      events = Streaming.collect_all(stream)
  """
  @spec collect_all(Enumerable.t()) :: [map()]
  def collect_all(stream) do
    Enum.to_list(stream)
  end

  @doc """
  Extracts text content from a stream of events.

  Useful for extracting the generated text from streaming responses.

  ## Options

    * `:path` - Path to the text in each event (default: `[:delta, :text]`)

  ## Examples

      client
      |> Resource.stream(params)
      |> Streaming.extract_text()
      |> Enum.join()
  """
  @spec extract_text(Enumerable.t(), keyword()) :: Enumerable.t()
  def extract_text(stream, opts \\ []) do
    path = Keyword.get(opts, :path, [:delta, :text])

    stream
    |> Stream.map(fn event ->
      get_in_path(event, path)
    end)
    |> Stream.filter(& &1)
  end

  # Private functions

  defp parse_json(data) do
    case Jason.decode(data) do
      {:ok, parsed} -> {:ok, parsed}
      {:error, reason} -> {:error, %Errors.StreamError{message: "Failed to parse SSE event", data: {reason, data}}}
    end
  end

  defp accumulate_and_parse(chunk, buffer) do
    buffer = buffer <> chunk
    {events, remaining} = extract_events(buffer, [])
    {events, remaining}
  end

  defp extract_events(buffer, events) do
    case String.split(buffer, "\n\n", parts: 2) do
      [event, rest] ->
        parsed = parse_event(event)
        extract_events(rest, events ++ [parsed])

      [incomplete] ->
        {events, incomplete}
    end
  end

  defp get_in_path(data, []) when is_map(data), do: data

  defp get_in_path(data, [key | rest]) when is_map(data) do
    value =
      cond do
        is_atom(key) -> Map.get(data, key) || Map.get(data, Atom.to_string(key))
        is_binary(key) -> Map.get(data, key) || Map.get(data, String.to_atom(key))
        true -> nil
      end

    case value do
      nil -> nil
      v -> get_in_path(v, rest)
    end
  end

  defp get_in_path(%{__struct__: _} = struct, path) do
    struct
    |> Map.from_struct()
    |> get_in_path(path)
  end

  defp get_in_path(_, _), do: nil
end
{{end}}