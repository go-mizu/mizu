{{define "streaming.erl.tmpl"}}%% Code generated by sdkerlang. DO NOT EDIT.

%% @doc Server-Sent Events (SSE) streaming support.
%%
%% This module provides utilities for parsing and handling SSE streams.
%%
%% == Usage ==
%% ```
%% %% Get stream from client
%% {ok, Stream} = {{.AppName}}_client:stream(Client, [
%%     {method, post},
%%     {path, <<"/v1/messages">>},
%%     {body, Body}
%% ]),
%%
%% %% Process events with foreach
%% ok = {{.AppName}}_streaming:foreach(Stream, fun(Event) ->
%%     io:format("~p~n", [Event])
%% end).
%%
%% %% Or fold over events
%% {ok, Result} = {{.AppName}}_streaming:fold(Stream, [], fun(Event, Acc) ->
%%     [Event | Acc]
%% end).
%% '''
-module({{.AppName}}_streaming).

-export([
    new/1,
    next/1,
    close/1,
    fold/3,
    foreach/2
]).

-record(stream, {
    client_ref :: reference(),
    buffer :: binary(),
    done :: boolean()
}).

-opaque stream() :: #stream{}.
-export_type([stream/0]).

%% @doc Creates a new stream from a hackney client reference.
%%
%% @param ClientRef The hackney client reference
%% @returns A new stream handle
-spec new(reference()) -> stream().
new(ClientRef) ->
    #stream{client_ref = ClientRef, buffer = <<>>, done = false}.

%% @doc Gets the next event from the stream.
%%
%% Returns:
%% <ul>
%%   <li>`{ok, Event, Stream}' - An event was received</li>
%%   <li>`{done, Stream}' - Stream completed normally</li>
%%   <li>`{error, Reason}' - An error occurred</li>
%% </ul>
%%
%% @param Stream The stream handle
%% @returns {ok, Event, Stream} | {done, Stream} | {error, Reason}
-spec next(stream()) ->
    {ok, map(), stream()} | {done, stream()} | {error, term()}.
next(#stream{done = true} = Stream) ->
    {done, Stream};
next(#stream{client_ref = Ref, buffer = Buffer} = Stream) ->
    ok = hackney:stream_next(Ref),
    receive
        {hackney_response, Ref, {status, Status, _Reason}} when Status >= 200, Status < 300 ->
            next(Stream);
        {hackney_response, Ref, {status, Status, _Reason}} ->
            {error, {http_error, Status}};
        {hackney_response, Ref, {headers, _Headers}} ->
            next(Stream);
        {hackney_response, Ref, done} ->
            {done, Stream#stream{done = true}};
        {hackney_response, Ref, {error, Reason}} ->
            {error, Reason};
        {hackney_response, Ref, Chunk} when is_binary(Chunk) ->
            process_chunk(Stream, <<Buffer/binary, Chunk/binary>>)
    after 60000 ->
        {error, timeout}
    end.

%% @doc Closes the stream.
%%
%% @param Stream The stream handle
%% @returns ok
-spec close(stream()) -> ok.
close(#stream{client_ref = Ref}) ->
    hackney:close(Ref),
    ok.

%% @doc Folds over all events in the stream.
%%
%% == Example ==
%% ```
%% {ok, Result} = {{.AppName}}_streaming:fold(Stream, [], fun(Event, Acc) ->
%%     [Event | Acc]
%% end),
%% Events = lists:reverse(Result).
%% '''
%%
%% @param Stream The stream handle
%% @param Acc The initial accumulator
%% @param Fun The fold function
%% @returns {ok, Acc} | {error, Reason}
-spec fold(stream(), Acc, fun((map(), Acc) -> Acc)) ->
    {ok, Acc} | {error, term()} when Acc :: term().
fold(Stream, Acc, Fun) ->
    case next(Stream) of
        {ok, Event, NextStream} ->
            fold(NextStream, Fun(Event, Acc), Fun);
        {done, _} ->
            {ok, Acc};
        {error, Reason} ->
            {error, Reason}
    end.

%% @doc Iterates over all events in the stream.
%%
%% == Example ==
%% ```
%% ok = {{.AppName}}_streaming:foreach(Stream, fun(Event) ->
%%     io:format("~p~n", [Event])
%% end).
%% '''
%%
%% @param Stream The stream handle
%% @param Fun The iteration function
%% @returns ok | {error, Reason}
-spec foreach(stream(), fun((map()) -> term())) -> ok | {error, term()}.
foreach(Stream, Fun) ->
    case next(Stream) of
        {ok, Event, NextStream} ->
            Fun(Event),
            foreach(NextStream, Fun);
        {done, _} ->
            ok;
        {error, Reason} ->
            {error, Reason}
    end.

%% Private functions

process_chunk(Stream, Buffer) ->
    case binary:split(Buffer, <<"\n\n">>) of
        [Event, Rest] ->
            case parse_sse_event(Event) of
                done ->
                    {done, Stream#stream{buffer = Rest, done = true}};
                skip ->
                    next(Stream#stream{buffer = Rest});
                {ok, Data} ->
                    {ok, Data, Stream#stream{buffer = Rest}}
            end;
        [Incomplete] ->
            next(Stream#stream{buffer = Incomplete})
    end.

parse_sse_event(Event) ->
    Lines = binary:split(Event, <<"\n">>, [global]),
    DataLines = [extract_data(L) || L <- Lines, is_data_line(L)],
    Data = iolist_to_binary(lists:join(<<"\n">>, DataLines)),
    case Data of
        <<>> -> skip;
        <<"[DONE]">> -> done;
        _ ->
            try
                {ok, jsx:decode(Data, [return_maps])}
            catch
                _:_ -> skip
            end
    end.

is_data_line(<<"data:", _/binary>>) -> true;
is_data_line(_) -> false.

extract_data(<<"data:", Rest/binary>>) ->
    string:trim(Rest);
extract_data(_) ->
    <<>>.
{{end}}
