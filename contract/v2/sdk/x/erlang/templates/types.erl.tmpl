{{define "types.erl.tmpl"}}%% Code generated by sdkerlang. DO NOT EDIT.

%% @doc Type definitions and conversion utilities for {{.Service.Name}} API.
%%
%% This module provides functions to convert between maps and records,
%% as well as type specifications for Dialyzer.
-module({{.AppName}}_types).

-export([
    from_map/2,
    to_map/1
{{- if .HasDate}},
    parse_datetime/1
{{- end}}
]).

-include("{{.AppName}}.hrl").

%% @doc Creates a record from a map.
%%
%% == Example ==
%% ```
%% Map = #{<<"id">> => <<"123">>, <<"name">> => <<"test">>},
%% Record = {{.AppName}}_types:from_map(my_record, Map).
%% '''
%%
%% @param RecordType The record type atom
%% @param Map The map to convert
%% @returns The record
-spec from_map(atom(), map() | undefined) -> tuple() | undefined.
from_map(_RecordType, undefined) -> undefined;
from_map(RecordType, Map) when is_map(Map) ->
    Fields = record_fields(RecordType),
    Values = [get_field_value(F, Map) || F <- Fields],
    list_to_tuple([RecordType | Values]).

%% @doc Converts a record to a map.
%%
%% Undefined fields are omitted from the result.
%%
%% @param Record The record to convert
%% @returns A map
-spec to_map(tuple() | undefined) -> map() | undefined.
to_map(undefined) -> undefined;
to_map(Record) when is_tuple(Record) ->
    RecordType = element(1, Record),
    Fields = record_fields(RecordType),
    Values = tl(tuple_to_list(Record)),
    Pairs = lists:zip(Fields, Values),
    maps:from_list([{atom_to_binary(K, utf8), serialize_value(V)}
                    || {K, V} <- Pairs, V =/= undefined]).
{{if .HasDate}}

%% @doc Parses an ISO8601 datetime string.
%%
%% @param Bin The binary to parse
%% @returns A datetime tuple or the original binary if parsing fails
-spec parse_datetime(binary() | undefined) -> calendar:datetime() | binary() | undefined.
parse_datetime(undefined) -> undefined;
parse_datetime(<<Y:4/binary, "-", M:2/binary, "-", D:2/binary, "T",
                 H:2/binary, ":", Mi:2/binary, ":", S:2/binary, _/binary>>) ->
    {{ "{{" }}binary_to_integer(Y), binary_to_integer(M), binary_to_integer(D){{ "}" }},
     {{ "{" }}binary_to_integer(H), binary_to_integer(Mi), binary_to_integer(S){{ "}}" }};
parse_datetime(Bin) when is_binary(Bin) -> Bin.
{{end}}

%% Private functions

get_field_value(Field, Map) ->
    FieldBin = atom_to_binary(Field, utf8),
    case maps:find(FieldBin, Map) of
        {ok, Value} -> Value;
        error ->
            %% Try snake_case to camelCase conversion
            FieldCamel = to_camel_case(FieldBin),
            maps:get(FieldCamel, Map, undefined)
    end.

serialize_value(undefined) -> undefined;
serialize_value(V) when is_tuple(V), tuple_size(V) > 0 ->
    case is_record_tuple(V) of
        true -> to_map(V);
        false -> V
    end;
serialize_value(L) when is_list(L) ->
    [serialize_value(E) || E <- L];
serialize_value(M) when is_map(M) ->
    maps:map(fun(_K, V) -> serialize_value(V) end, M);
serialize_value(V) -> V.

is_record_tuple(T) when is_tuple(T), tuple_size(T) > 0 ->
    is_atom(element(1, T)) andalso record_fields(element(1, T)) =/= [];
is_record_tuple(_) -> false.

to_camel_case(Bin) ->
    Parts = binary:split(Bin, <<"_">>, [global]),
    case Parts of
        [First | Rest] ->
            Capitalized = [capitalize(P) || P <- Rest],
            iolist_to_binary([First | Capitalized]);
        _ -> Bin
    end.

capitalize(<<>>) -> <<>>;
capitalize(<<C, Rest/binary>>) when C >= $a, C =< $z ->
    <<(C - 32), Rest/binary>>;
capitalize(Bin) -> Bin.

%% Record field definitions
{{range $type := .Types}}
{{- if eq $type.Kind "struct"}}
record_fields({{$type.RecordName}}) -> [{{range $i, $field := $type.Fields}}{{$field.ErlangName}}{{if lt $i (sub (len $type.Fields) 1)}}, {{end}}{{end}}];
{{- end}}
{{- end}}
record_fields(_) -> [].
{{end}}
