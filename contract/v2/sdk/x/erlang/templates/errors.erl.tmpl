{{define "errors.erl.tmpl"}}%% Code generated by sdkerlang. DO NOT EDIT.

%% @doc Error types and handling for {{.Service.Name}} API.
%%
%% All API errors are returned as tagged tuples:
%% `{ErrorType, #{message := binary(), ...}}'
%%
%% == Error Types ==
%% <ul>
%%   <li>`bad_request' - HTTP 400</li>
%%   <li>`unauthorized' - HTTP 401</li>
%%   <li>`forbidden' - HTTP 403</li>
%%   <li>`not_found' - HTTP 404</li>
%%   <li>`unprocessable_entity' - HTTP 422</li>
%%   <li>`rate_limited' - HTTP 429</li>
%%   <li>`server_error' - HTTP 5xx</li>
%%   <li>`connection_error' - Network errors</li>
%%   <li>`timeout_error' - Request timeout</li>
%% </ul>
%%
%% == Example ==
%% ```
%% case {{.AppName}}_messages:create(Client, Params) of
%%     {ok, Response} ->
%%         handle_response(Response);
%%     {error, {rate_limited, #{retry_after := Retry}}} ->
%%         timer:sleep(Retry * 1000),
%%         retry();
%%     {error, {Type, #{message := Msg}}} ->
%%         io:format("Error ~p: ~s~n", [Type, Msg])
%% end.
%% '''
-module({{.AppName}}_errors).

-export([
    from_response/2,
    connection_error/1,
    format_error/1
]).

-type error_type() ::
    bad_request |
    unauthorized |
    forbidden |
    not_found |
    unprocessable_entity |
    rate_limited |
    server_error |
    connection_error |
    timeout_error |
    stream_error.

-type sdk_error() :: {error_type(), #{
    message := binary(),
    status => integer(),
    body => term(),
    retry_after => integer()
}}.

-export_type([error_type/0, sdk_error/0]).

%% @doc Creates an error from an HTTP response.
%%
%% @param Status The HTTP status code
%% @param Body The response body (binary or map)
%% @returns An SDK error tuple
-spec from_response(integer(), binary() | map()) -> sdk_error().
from_response(Status, Body) when is_binary(Body) ->
    ParsedBody = try jsx:decode(Body, [return_maps]) catch _:_ -> Body end,
    from_response(Status, ParsedBody);
from_response(400, Body) ->
    {bad_request, #{message => extract_message(Body), status => 400, body => Body}};
from_response(401, Body) ->
    {unauthorized, #{message => extract_message(Body), status => 401, body => Body}};
from_response(403, Body) ->
    {forbidden, #{message => extract_message(Body), status => 403, body => Body}};
from_response(404, Body) ->
    {not_found, #{message => extract_message(Body), status => 404, body => Body}};
from_response(422, Body) ->
    {unprocessable_entity, #{message => extract_message(Body), status => 422, body => Body}};
from_response(429, Body) ->
    {rate_limited, #{
        message => extract_message(Body),
        status => 429,
        body => Body,
        retry_after => extract_retry_after(Body)
    }};
from_response(Status, Body) when Status >= 500 ->
    {server_error, #{message => extract_message(Body), status => Status, body => Body}};
from_response(Status, Body) ->
    {server_error, #{message => extract_message(Body), status => Status, body => Body}}.

%% @doc Creates a connection error.
%%
%% @param Reason The error reason
%% @returns An SDK error tuple
-spec connection_error(term()) -> sdk_error().
connection_error(timeout) ->
    {timeout_error, #{message => <<"Request timed out">>}};
connection_error(Reason) ->
    {connection_error, #{message => format_reason(Reason)}}.

%% @doc Formats an error for display.
%%
%% @param Error The SDK error tuple
%% @returns A formatted binary string
-spec format_error(sdk_error()) -> binary().
format_error({Type, #{message := Msg} = Info}) ->
    Status = maps:get(status, Info, undefined),
    case Status of
        undefined ->
            iolist_to_binary(io_lib:format("~s: ~s", [Type, Msg]));
        _ ->
            iolist_to_binary(io_lib:format("~s (~p): ~s", [Type, Status, Msg]))
    end.

%% Private functions

extract_message(#{<<"message">> := Msg}) -> Msg;
extract_message(#{<<"error">> := #{<<"message">> := Msg}}) -> Msg;
extract_message(#{<<"error">> := Msg}) when is_binary(Msg) -> Msg;
extract_message(Msg) when is_binary(Msg) -> Msg;
extract_message(_) -> <<"Unknown error">>.

extract_retry_after(#{<<"retry_after">> := V}) when is_integer(V) -> V;
extract_retry_after(_) -> undefined.

format_reason(Reason) when is_atom(Reason) ->
    atom_to_binary(Reason, utf8);
format_reason(Reason) when is_binary(Reason) ->
    Reason;
format_reason(Reason) ->
    iolist_to_binary(io_lib:format("~p", [Reason])).
{{end}}
