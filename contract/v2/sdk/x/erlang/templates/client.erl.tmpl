{{define "client.erl.tmpl"}}%% Code generated by sdkerlang. DO NOT EDIT.

%% @doc HTTP client for {{.Service.Name}} API.
%%
%% This module handles all HTTP communication including authentication,
%% retries, and error handling.
%%
%% == Usage ==
%% ```
%% Client = {{.AppName}}_client:new([{api_key, <<"sk-...">>}]),
%%
%% %% Make a request
%% {ok, Response} = {{.AppName}}_client:request(Client, [
%%     {method, post},
%%     {path, <<"/v1/resource">>},
%%     {body, #{key => <<"value">>}}
%% ]).
%% '''
-module({{.AppName}}_client).

-export([
    new/0,
    new/1,
    request/2
{{- if .HasSSE}},
    stream/2
{{- end}}
]).

-include("{{.AppName}}.hrl").

-record(client, {
    config :: {{.AppName}}_config:config()
}).

-opaque client() :: #client{}.
-export_type([client/0]).

%% @doc Creates a new client with default options.
-spec new() -> client().
new() ->
    new([]).

%% @doc Creates a new client with the given options.
%%
%% @param Opts Options proplist
%% @returns Client handle
-spec new(proplists:proplist()) -> client().
new(Opts) ->
    _ = ensure_started(),
    Config = {{.AppName}}_config:new(Opts),
    #client{config = Config}.

%% @doc Performs an HTTP request.
%%
%% Returns `{ok, Response}' on success or `{error, Reason}' on failure.
%%
%% == Options ==
%% <ul>
%%   <li>`method' - HTTP method (required): get, post, put, patch, delete</li>
%%   <li>`path' - Request path (required)</li>
%%   <li>`body' - Request body as map (optional)</li>
%%   <li>`headers' - Additional headers (optional)</li>
%% </ul>
%%
%% @param Client The client handle
%% @param Opts Request options
%% @returns {ok, Response} | {error, Reason}
-spec request(client(), proplists:proplist()) ->
    {ok, map() | undefined} | {error, term()}.
request(#client{config = Config}, Opts) ->
    Method = proplists:get_value(method, Opts),
    Path = proplists:get_value(path, Opts),
    Body = proplists:get_value(body, Opts, undefined),
    ExtraHeaders = proplists:get_value(headers, Opts, []),

    URL = build_url(Config, Path),
    Headers = build_headers(Config, ExtraHeaders),
    ReqBody = encode_body(Body),
    HTTPOpts = build_http_opts(Config),

    case hackney:request(Method, URL, Headers, ReqBody, HTTPOpts) of
        {ok, Status, _RespHeaders, ClientRef} when Status >= 200, Status < 300 ->
            {ok, RespBody} = hackney:body(ClientRef),
            case RespBody of
                <<>> -> {ok, undefined};
                _ -> {ok, jsx:decode(RespBody, [return_maps])}
            end;
        {ok, 204, _RespHeaders, ClientRef} ->
            hackney:skip_body(ClientRef),
            {ok, undefined};
        {ok, Status, _RespHeaders, ClientRef} ->
            {ok, RespBody} = hackney:body(ClientRef),
            {error, {{.AppName}}_errors:from_response(Status, RespBody)};
        {error, timeout} ->
            {error, {{.AppName}}_errors:connection_error(timeout)};
        {error, Reason} ->
            {error, {{.AppName}}_errors:connection_error(Reason)}
    end.
{{if .HasSSE}}

%% @doc Performs a streaming SSE request.
%%
%% Returns a stream handle that can be used with {{.AppName}}_streaming functions.
%%
%% == Options ==
%% <ul>
%%   <li>`method' - HTTP method (required)</li>
%%   <li>`path' - Request path (required)</li>
%%   <li>`body' - Request body as map (optional)</li>
%% </ul>
%%
%% == Example ==
%% ```
%% {ok, Stream} = {{.AppName}}_client:stream(Client, [
%%     {method, post},
%%     {path, <<"/v1/messages">>},
%%     {body, Body}
%% ]),
%% ok = {{.AppName}}_streaming:foreach(Stream, fun(Event) ->
%%     io:format("~p~n", [Event])
%% end).
%% '''
%%
%% @param Client The client handle
%% @param Opts Request options
%% @returns {ok, Stream} | {error, Reason}
-spec stream(client(), proplists:proplist()) ->
    {ok, {{.AppName}}_streaming:stream()} | {error, term()}.
stream(#client{config = Config}, Opts) ->
    Method = proplists:get_value(method, Opts),
    Path = proplists:get_value(path, Opts),
    Body = proplists:get_value(body, Opts, undefined),

    URL = build_url(Config, Path),
    Headers = build_headers(Config, [{<<"accept">>, <<"text/event-stream">>}]),
    ReqBody = encode_body(Body),
    HTTPOpts = [{async, once}, {stream_to, self()}] ++ build_http_opts(Config),

    case hackney:request(Method, URL, Headers, ReqBody, HTTPOpts) of
        {ok, ClientRef} ->
            {ok, {{.AppName}}_streaming:new(ClientRef)};
        {error, Reason} ->
            {error, {{.AppName}}_errors:connection_error(Reason)}
    end.
{{end}}

%% Private functions

ensure_started() ->
    case application:ensure_all_started(hackney) of
        {ok, _} -> ok;
        {error, _} = Err -> Err
    end.

build_url(Config, Path) ->
    BaseURL = {{.AppName}}_config:base_url(Config),
    <<BaseURL/binary, Path/binary>>.

build_headers(Config, Extra) ->
    Base = [
        {<<"content-type">>, <<"application/json">>},
        {<<"accept">>, <<"application/json">>}
    ],
    Auth = apply_auth(Config),
    Custom = {{.AppName}}_config:headers(Config),
    lists:usort(Auth ++ Base ++ Custom ++ Extra).

apply_auth(Config) ->
    case {{.AppName}}_config:api_key(Config) of
        undefined -> [];
        Key ->
            case {{.AppName}}_config:auth_mode(Config) of
                bearer -> [{<<"authorization">>, <<"Bearer ", Key/binary>>}];
                basic -> [{<<"authorization">>, <<"Basic ", (base64:encode(Key))/binary>>}];
                header -> [{<<"x-api-key">>, Key}];
                none -> []
            end
    end.

encode_body(undefined) -> <<>>;
encode_body(Body) when is_map(Body) -> jsx:encode(Body);
encode_body(Body) when is_binary(Body) -> Body.

build_http_opts(Config) ->
    Timeout = {{.AppName}}_config:timeout(Config),
    [
        {connect_timeout, Timeout},
        {recv_timeout, Timeout},
        with_body
    ].
{{end}}
