{{define "Client.scala.tmpl"}}// Code generated by sdkscala. DO NOT EDIT.

package {{.Package}}

import scala.concurrent.{ExecutionContext, Future}
import scala.concurrent.duration._
import scala.util.{Failure, Success, Try}

import sttp.client3._
import sttp.client3.asynchttpclient.future.AsyncHttpClientFutureBackend
import sttp.model.{Method, Uri}

import io.circe._
import io.circe.syntax._
import io.circe.parser._
{{- if .HasSSE}}
import fs2.Stream
{{- end}}

// MARK: - Authentication Mode

/** Authentication mode for API requests. */
sealed trait AuthMode

object AuthMode {
  /** Bearer token authentication. */
  case object Bearer extends AuthMode

  /** Basic authentication. */
  case object Basic extends AuthMode

  /** API key in header. */
  case object ApiKey extends AuthMode

  /** No authentication. */
  case object None extends AuthMode
}

// MARK: - Client Configuration

/** Configuration options for the SDK client. */
final case class ClientConfig(
  /** API key for authentication. */
  apiKey: Option[String] = None,

  /** Base URL for API requests. */
  baseUrl: String = {{scalaString .Client.BaseURL}},

  /** Authentication mode. */
  authMode: AuthMode = AuthMode.Bearer,

  /** Request timeout. */
  timeout: FiniteDuration = 60.seconds,

  /** Maximum number of retry attempts for failed requests. */
  maxRetries: Int = 2,

  /** Default headers to include in all requests. */
  defaultHeaders: Map[String, String] = {{if .Client.Headers}}Map(
{{- range $i, $h := .Client.Headers}}
    {{scalaString $h.K}} -> {{scalaString $h.V}}{{if lt $i (sub (len $.Client.Headers) 1)}},{{end}}
{{- end}}
  ){{else}}Map.empty{{end}}
)

object ClientConfig {
  /** Default configuration with standard settings. */
  val default: ClientConfig = ClientConfig()
}

// MARK: - Main Client
{{if .Service.Description}}
/**
 * {{.Service.Description}}
 *
 * Thread-safe client for API interactions.
 */
{{end -}}
final class {{.Service.Sanitized}}(
  val config: ClientConfig = ClientConfig.default
)(implicit ec: ExecutionContext) {

  private val backend: SttpBackend[Future, Any] = AsyncHttpClientFutureBackend()

  private[{{.Package | lower}}] val baseHeaders: Map[String, String] = {
    val authHeader: Map[String, String] = config.apiKey.map { key =>
      config.authMode match {
        case AuthMode.Bearer => Map("Authorization" -> s"Bearer $key")
        case AuthMode.Basic  => Map("Authorization" -> s"Basic $key")
        case AuthMode.ApiKey => Map("X-Api-Key" -> key)
        case AuthMode.None   => Map.empty[String, String]
      }
    }.getOrElse(Map.empty)

    config.defaultHeaders ++ authHeader ++ Map(
      "Content-Type" -> "application/json",
      "Accept" -> "application/json"
    )
  }

{{- range .Resources}}
  /** Access to {{.Name}} operations. */
  lazy val {{.ScalaName}}: {{.ClassName}} = new {{.ClassName}}(this)
{{- end}}

  /** Creates a new client with modified configuration. */
  def withConfig(f: ClientConfig => ClientConfig): {{.Service.Sanitized}} =
    new {{.Service.Sanitized}}(f(config))

  /** Creates a new client with a different API key. */
  def withApiKey(apiKey: String): {{.Service.Sanitized}} =
    withConfig(_.copy(apiKey = Some(apiKey)))

  /** Creates a new client with a different base URL. */
  def withBaseUrl(baseUrl: String): {{.Service.Sanitized}} =
    withConfig(_.copy(baseUrl = baseUrl))

  /** Closes the client and releases resources. */
  def close(): Future[Unit] = backend.close()

  // Internal request method
  private[{{.Package | lower}}] def request[A: Decoder](
    method: Method,
    path: String,
    body: Option[String] = None
  ): Future[SDKResult[A]] = {
    val uri = Uri.parse(s"${config.baseUrl}$path").getOrElse(
      throw new IllegalArgumentException(s"Invalid URL: ${config.baseUrl}$path")
    )

    val baseRequest = basicRequest
      .method(method, uri)
      .headers(baseHeaders)
      .readTimeout(config.timeout)

    val requestWithBody = body.fold(baseRequest)(b => baseRequest.body(b))

    executeWithRetry[A](requestWithBody, config.maxRetries)
  }

  private def executeWithRetry[A: Decoder](
    request: Request[Either[String, String], Any],
    retriesLeft: Int
  ): Future[SDKResult[A]] = {
    request.send(backend).flatMap { response =>
      response.body match {
        case Right(bodyStr) if response.code.isSuccess =>
          decode[A](bodyStr) match {
            case Right(value) => Future.successful(Right(value))
            case Left(error)  => Future.successful(Left(
              SDKError.DecodingError(error, s"Failed to decode response: ${error.getMessage}")
            ))
          }
        case Right(bodyStr) =>
          Future.successful(Left(SDKError.ApiError(
            response.code.code,
            s"HTTP ${response.code.code}",
            Some(bodyStr)
          )))
        case Left(errorBody) if retriesLeft > 0 && isRetriable(response.code.code) =>
          val delay = (500 * math.pow(2, config.maxRetries - retriesLeft)).toLong
          Thread.sleep(delay) // Simple delay; in production use scheduler
          executeWithRetry(request, retriesLeft - 1)
        case Left(errorBody) =>
          Future.successful(Left(SDKError.ApiError(
            response.code.code,
            errorBody,
            Some(errorBody)
          )))
      }
    }.recover {
      case e: java.net.SocketTimeoutException =>
        Left(SDKError.Timeout())
      case e: java.util.concurrent.CancellationException =>
        Left(SDKError.Cancelled())
      case e: Throwable =>
        Left(SDKError.ConnectionError(e))
    }
  }

  private def isRetriable(code: Int): Boolean =
    code >= 500 || code == 429

{{- if .HasSSE}}

  // Internal streaming method
  private[{{.Package | lower}}] def stream[A: Decoder](
    method: Method,
    path: String,
    body: Option[String] = None
  ): Stream[Future, SDKResult[A]] = {
    val uri = Uri.parse(s"${config.baseUrl}$path").getOrElse(
      throw new IllegalArgumentException(s"Invalid URL: ${config.baseUrl}$path")
    )

    val streamHeaders = baseHeaders + ("Accept" -> "text/event-stream")

    val baseRequest = basicRequest
      .method(method, uri)
      .headers(streamHeaders)
      .readTimeout(config.timeout)
      .response(asStreamAlwaysUnsafe(Fs2Streams[Future]))

    val requestWithBody = body.fold(baseRequest)(b => baseRequest.body(b))

    Stream.eval(requestWithBody.send(backend)).flatMap { response =>
      if (response.code.isSuccess) {
        response.body
          .through(Streaming.parseSSE[Future])
          .through(Streaming.decodeSSE[Future, A])
          .map {
            case Right(event) => Right(event)
            case Left(error)  => Left(SDKError.DecodingError(
              new Exception(error.message),
              error.message
            ))
          }
      } else {
        Stream.emit(Left(SDKError.ApiError(
          response.code.code,
          s"HTTP ${response.code.code}",
          None
        )))
      }
    }
  }
{{- end}}
}

object {{.Service.Sanitized}} {
  /** Creates a new client with default configuration. */
  def apply()(implicit ec: ExecutionContext): {{.Service.Sanitized}} =
    new {{.Service.Sanitized}}()

  /** Creates a new client with an API key. */
  def apply(apiKey: String)(implicit ec: ExecutionContext): {{.Service.Sanitized}} =
    new {{.Service.Sanitized}}(ClientConfig(apiKey = Some(apiKey)))

  /** Creates a new client with custom configuration. */
  def apply(config: ClientConfig)(implicit ec: ExecutionContext): {{.Service.Sanitized}} =
    new {{.Service.Sanitized}}(config)
}

// MARK: - sttp Fs2 Streams Backend (for SSE)
{{- if .HasSSE}}

private[{{.Package | lower}}] object Fs2Streams {
  type Streams[F[_]] = fs2.Stream[F, Byte]

  def apply[F[_]]: Fs2Streams[F] = new Fs2Streams[F]
}

private[{{.Package | lower}}] class Fs2Streams[F[_]] extends sttp.capabilities.Streams[fs2.Stream[F, Byte]] {
  override type BinaryStream = fs2.Stream[F, Byte]
  override type Pipe[A, B] = fs2.Pipe[F, A, B]
}
{{- end}}
{{end}}
