{{define "Types.scala.tmpl"}}// Code generated by sdkscala. DO NOT EDIT.

package {{.Package}}

import io.circe._
import io.circe.generic.semiauto._
import io.circe.syntax._
{{- if .HasDate}}
import java.time.Instant
import java.time.format.DateTimeFormatter
{{- end}}

// MARK: - Generated Types
{{range $type := .Types}}
{{- if $type.Description}}
/**
 * {{$type.Description}}
 */
{{- end}}
{{- if eq $type.Kind "struct"}}
final case class {{$type.ScalaName}}(
{{- if not $type.Fields}}
  // Empty case class - acts as a marker type
  _placeholder: Unit = ()
{{- else}}
{{- $fields := $type.Fields}}
{{- $lastIdx := len $fields | add -1}}
{{- range $i, $f := $fields}}
{{- if $f.Description}}
  /** {{$f.Description}} */
{{- end}}
{{- if $f.Enum}}
  {{$f.ScalaName}}: {{$type.ScalaName}}.{{$f.ScalaName | pascal}}{{if or $f.Optional $f.Nullable}} = None{{end}}{{if lt $i $lastIdx}},{{end}}
{{- else}}
  {{$f.ScalaName}}: {{$f.ScalaType}}{{if or $f.Optional $f.Nullable}} = None{{end}}{{if lt $i $lastIdx}},{{end}}
{{- end}}
{{- end}}
{{- end}}
)

object {{$type.ScalaName}} {
{{- range $field := $type.Fields}}
{{- if $field.Enum}}

  /** Valid values for {{$type.ScalaName}}.{{$field.ScalaName}}. */
  sealed trait {{$field.ScalaName | pascal}} {
    def value: String
  }

  object {{$field.ScalaName | pascal}} {
{{- range $e := $field.Enum}}
    case object {{$e.Name}} extends {{$field.ScalaName | pascal}} { val value: String = {{scalaString $e.Value}} }
{{- end}}

    val values: List[{{$field.ScalaName | pascal}}] = List(
{{- range $i, $e := $field.Enum}}
      {{$e.Name}}{{if lt $i (sub (len $field.Enum) 1)}},{{end}}
{{- end}}
    )

    def fromString(s: String): Option[{{$field.ScalaName | pascal}}] = values.find(_.value == s)

    def unsafeFromString(s: String): {{$field.ScalaName | pascal}} =
      fromString(s).getOrElse(throw new IllegalArgumentException(s"Unknown {{$field.ScalaName | pascal}}: $$s"))

    implicit val encoder: Encoder[{{$field.ScalaName | pascal}}] = Encoder.encodeString.contramap(_.value)
    implicit val decoder: Decoder[{{$field.ScalaName | pascal}}] = Decoder.decodeString.emap { s =>
      fromString(s).toRight(s"Unknown {{$field.ScalaName | pascal}}: $$s")
    }
  }
{{- end}}
{{- end}}

  implicit val encoder: Encoder[{{$type.ScalaName}}] = deriveEncoder[{{$type.ScalaName}}]
  implicit val decoder: Decoder[{{$type.ScalaName}}] = deriveDecoder[{{$type.ScalaName}}]
}
{{- end}}

{{- if eq $type.Kind "slice"}}
// Type alias for list type
type {{$type.ScalaName}} = List[{{$type.Elem}}]

object {{$type.ScalaName}} {
  implicit val encoder: Encoder[{{$type.ScalaName}}] = Encoder.encodeList[{{$type.Elem}}]
  implicit val decoder: Decoder[{{$type.ScalaName}}] = Decoder.decodeList[{{$type.Elem}}]
}
{{- end}}

{{- if eq $type.Kind "map"}}
// Type alias for map type
type {{$type.ScalaName}} = Map[String, {{$type.Elem}}]

object {{$type.ScalaName}} {
  implicit val encoder: Encoder[{{$type.ScalaName}}] = Encoder.encodeMap[String, {{$type.Elem}}]
  implicit val decoder: Decoder[{{$type.ScalaName}}] = Decoder.decodeMap[String, {{$type.Elem}}]
}
{{- end}}

{{- if eq $type.Kind "union"}}
/**
 * Discriminated union (tag: "{{$type.Tag}}").
 */
sealed trait {{$type.ScalaName}}

object {{$type.ScalaName}} {
{{range $v := $type.Variants}}
{{- if $v.Description}}
  /** {{$v.Description}} */
{{- end}}
  final case class {{$v.ScalaName}}(
    {{$type.Tag}}: String = {{scalaString $v.Value}}
    // Add variant-specific fields from {{$v.Type}} type
  ) extends {{$type.ScalaName}}

  object {{$v.ScalaName}} {
    implicit val encoder: Encoder[{{$v.ScalaName}}] = deriveEncoder[{{$v.ScalaName}}]
    implicit val decoder: Decoder[{{$v.ScalaName}}] = deriveDecoder[{{$v.ScalaName}}]
  }
{{end}}
  private val discriminator = "{{$type.Tag}}"

  implicit val encoder: Encoder[{{$type.ScalaName}}] = Encoder.instance {
{{- range $v := $type.Variants}}
    case v: {{$v.ScalaName}} => v.asJson
{{- end}}
  }

  implicit val decoder: Decoder[{{$type.ScalaName}}] = Decoder.instance { cursor =>
    cursor.downField(discriminator).as[String].flatMap {
{{- range $v := $type.Variants}}
      case {{scalaString $v.Value}} => cursor.as[{{$v.ScalaName}}]
{{- end}}
      case other => Left(DecodingFailure(s"Unknown $$discriminator: $$other", cursor.history))
    }
  }

  // Pattern matching extensions
  implicit class {{$type.ScalaName}}Ops(private val self: {{$type.ScalaName}}) extends AnyVal {
{{- range $v := $type.Variants}}
    def is{{$v.ScalaName}}: Boolean = self.isInstanceOf[{{$v.ScalaName}}]

    def as{{$v.ScalaName}}: Option[{{$v.ScalaName}}] = self match {
      case v: {{$v.ScalaName}} => Some(v)
      case _ => None
    }
{{- end}}
  }
}
{{- end}}
{{end}}
{{- if .HasDate}}

// MARK: - DateTime Codecs

object DateTimeCodecs {
  implicit val instantEncoder: Encoder[Instant] =
    Encoder.encodeString.contramap[Instant](_.toString)

  implicit val instantDecoder: Decoder[Instant] =
    Decoder.decodeString.emapTry(s => scala.util.Try(Instant.parse(s)))
}
{{- end}}
{{end}}
