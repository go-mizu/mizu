{{define "Errors.scala.tmpl"}}// Code generated by sdkscala. DO NOT EDIT.

package {{.Package}}

/** Base error type for all SDK errors. */
sealed trait SDKError extends Exception {
  def message: String
  override def getMessage: String = message
}

object SDKError {

  /** Network connection failed. */
  final case class ConnectionError(
    cause: Throwable,
    message: String = "Connection failed"
  ) extends SDKError {
    override def getCause: Throwable = cause
  }

  /** Server returned an error status code. */
  final case class ApiError(
    statusCode: Int,
    message: String,
    body: Option[String] = None
  ) extends SDKError

  /** Request timed out. */
  final case class Timeout(
    message: String = "Request timed out"
  ) extends SDKError

  /** Request was cancelled. */
  final case class Cancelled(
    message: String = "Request cancelled"
  ) extends SDKError

  /** Failed to encode request body. */
  final case class EncodingError(
    cause: Throwable,
    message: String = "Failed to encode request"
  ) extends SDKError {
    override def getCause: Throwable = cause
  }

  /** Failed to decode response body. */
  final case class DecodingError(
    cause: Throwable,
    message: String = "Failed to decode response"
  ) extends SDKError {
    override def getCause: Throwable = cause
  }

  /** Invalid configuration. */
  final case class InvalidConfig(
    message: String
  ) extends SDKError

  // Error classification helpers
  implicit class SDKErrorOps(private val self: SDKError) extends AnyVal {

    /** Returns true if this error is potentially retriable. */
    def isRetriable: Boolean = self match {
      case ApiError(code, _, _) => code >= 500 || code == 429
      case _: Timeout           => true
      case _: ConnectionError   => true
      case _                    => false
    }

    /** Returns the HTTP status code, if this is an API error. */
    def statusCode: Option[Int] = self match {
      case ApiError(code, _, _) => Some(code)
      case _                    => None
    }

    /** Returns true if this is a client error (4xx). */
    def isClientError: Boolean = self match {
      case ApiError(code, _, _) => code >= 400 && code < 500
      case _                    => false
    }

    /** Returns true if this is a server error (5xx). */
    def isServerError: Boolean = self match {
      case ApiError(code, _, _) => code >= 500
      case _                    => false
    }

    /** Returns true if this is a rate limit error (429). */
    def isRateLimited: Boolean = self match {
      case ApiError(429, _, _) => true
      case _                   => false
    }
  }
}

/** Type alias for SDK results using Either. */
type SDKResult[A] = Either[SDKError, A]

/** Extension methods for SDKResult. */
object SDKResultOps {
  import scala.concurrent.{ExecutionContext, Future}

  implicit class SDKResultFutureOps[A](private val future: Future[SDKResult[A]]) extends AnyVal {

    /** Maps over successful results. */
    def mapSuccess[B](f: A => B)(implicit ec: ExecutionContext): Future[SDKResult[B]] =
      future.map(_.map(f))

    /** Flat maps over successful results. */
    def flatMapSuccess[B](f: A => Future[SDKResult[B]])(implicit ec: ExecutionContext): Future[SDKResult[B]] =
      future.flatMap {
        case Right(value) => f(value)
        case Left(error)  => Future.successful(Left(error))
      }

    /** Recovers from specific errors. */
    def recoverWith(pf: PartialFunction[SDKError, Future[SDKResult[A]]])(implicit ec: ExecutionContext): Future[SDKResult[A]] =
      future.flatMap {
        case Left(error) if pf.isDefinedAt(error) => pf(error)
        case result => Future.successful(result)
      }

    /** Gets the value or throws the error. */
    def getOrThrow(implicit ec: ExecutionContext): Future[A] =
      future.flatMap {
        case Right(value) => Future.successful(value)
        case Left(error)  => Future.failed(error)
      }

    /** Converts to Option, discarding errors. */
    def toOption(implicit ec: ExecutionContext): Future[Option[A]] =
      future.map(_.toOption)
  }

  implicit class SDKResultOps[A](private val result: SDKResult[A]) extends AnyVal {

    /** Gets the value or throws the error. */
    def getOrThrow: A = result match {
      case Right(value) => value
      case Left(error)  => throw error
    }

    /** Converts error to a different type. */
    def mapError[E](f: SDKError => E): Either[E, A] =
      result.left.map(f)
  }
}
{{end}}
