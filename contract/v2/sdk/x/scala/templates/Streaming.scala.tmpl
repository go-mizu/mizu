{{define "Streaming.scala.tmpl"}}// Code generated by sdkscala. DO NOT EDIT.

package {{.Package}}
{{- if .HasSSE}}

import fs2._
import io.circe._
import io.circe.parser._

/**
 * Server-Sent Events (SSE) streaming support.
 */
object Streaming {

  /** Represents a parsed SSE event. */
  final case class SSEEvent(
    event: Option[String] = None,
    data: Option[String] = None,
    id: Option[String] = None,
    retry: Option[Long] = None
  )

  /**
   * Parses a stream of bytes into SSE events.
   */
  def parseSSE[F[_]]: Pipe[F, Byte, SSEEvent] = { input =>
    input
      .through(text.utf8.decode)
      .through(text.lines)
      .scan((SSEEvent(), false)) { case ((event, _), line) =>
        if (line.isEmpty) {
          (SSEEvent(), true)
        } else if (line.startsWith(":")) {
          // Comment, ignore
          (event, false)
        } else if (line.startsWith("event:")) {
          (event.copy(event = Some(line.stripPrefix("event:").trim)), false)
        } else if (line.startsWith("data:")) {
          val newData = line.stripPrefix("data:").trim
          val data = event.data.fold(newData)(_ + "\n" + newData)
          (event.copy(data = Some(data)), false)
        } else if (line.startsWith("id:")) {
          (event.copy(id = Some(line.stripPrefix("id:").trim)), false)
        } else if (line.startsWith("retry:")) {
          val retry = line.stripPrefix("retry:").trim.toLongOption
          (event.copy(retry = retry), false)
        } else {
          (event, false)
        }
      }
      .collect { case (event, true) if event.data.isDefined => event }
  }

  /**
   * Decodes SSE events into typed values.
   */
  def decodeSSE[F[_], A: Decoder]: Pipe[F, SSEEvent, Either[DecodingFailure, A]] = { input =>
    input
      .filter(_.data.exists(_ != "[DONE]"))
      .map { event =>
        event.data.fold[Either[DecodingFailure, A]](
          Left(DecodingFailure("No data in SSE event", Nil))
        ) { data =>
          decode[A](data).left.map(e => DecodingFailure(e.getMessage, Nil))
        }
      }
  }

  /**
   * Combines SSE parsing and decoding.
   */
  def parseAndDecode[F[_], A: Decoder]: Pipe[F, Byte, Either[DecodingFailure, A]] =
    parseSSE[F].andThen(decodeSSE[F, A])
}

/**
 * Extension methods for streaming operations.
 */
object StreamingOps {
  import scala.concurrent.{ExecutionContext, Future}

  implicit class StreamResultOps[A](private val stream: Stream[Future, SDKResult[A]]) extends AnyVal {

    /** Collects all successful items into a list. */
    def toListResult(implicit ec: ExecutionContext): Future[SDKResult[List[A]]] = {
      stream.compile.toList.map { results =>
        val (errors, successes) = results.partitionMap(identity)
        errors.headOption match {
          case Some(error) => Left(error)
          case None        => Right(successes)
        }
      }
    }

    /** Maps over successful items. */
    def mapSuccess[B](f: A => B): Stream[Future, SDKResult[B]] =
      stream.map(_.map(f))

    /** Filters to only successful items, discarding errors. */
    def collectSuccess: Stream[Future, A] =
      stream.collect { case Right(a) => a }
  }
}
{{- else}}

// Streaming support is not enabled for this SDK.
// To enable, add methods with Stream configuration to the contract.

object Streaming {
  // Placeholder for streaming utilities
}

object StreamingOps {
  // Placeholder for streaming extensions
}
{{- end}}
{{end}}
