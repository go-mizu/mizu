// Package sdkgo generates typed Go SDK clients from contract.Service.
package sdkgo

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"unicode"

	contract "github.com/go-mizu/mizu/contract/v2"
)

// Config controls code generation.
type Config struct {
	Package string // Go package name (default: lowercase service name)
}

// Generate produces Go source code for a typed SDK client.
func Generate(svc *contract.Service, cfg *Config) ([]byte, error) {
	if svc == nil {
		return nil, fmt.Errorf("sdkgo: nil service")
	}

	g := &generator{
		svc:     svc,
		imports: make(map[string]bool),
		types:   make(map[string]*contract.Type),
	}

	// Set package name
	if cfg != nil && cfg.Package != "" {
		g.pkg = cfg.Package
	} else {
		g.pkg = strings.ToLower(sanitizeIdent(svc.Name))
	}
	if g.pkg == "" {
		g.pkg = "sdk"
	}

	// Build type lookup
	for _, t := range svc.Types {
		if t != nil && t.Name != "" {
			g.types[t.Name] = t
		}
	}

	// Check for streaming and time.Time usage
	g.hasStreaming = g.checkHasStreaming()
	g.hasTime = g.checkHasTime()

	// Generate code sections
	g.emitHeader()
	g.emitImports()
	g.emitTypes()
	g.emitClient()
	g.emitResources()
	if g.hasStreaming {
		g.emitStreaming()
	}
	g.emitHelpers()

	return g.buf.Bytes(), nil
}

// generator holds state during code generation.
type generator struct {
	svc          *contract.Service
	pkg          string
	buf          bytes.Buffer
	imports      map[string]bool
	types        map[string]*contract.Type
	hasStreaming bool
	hasTime      bool
}

func (g *generator) emit(format string, args ...any) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *generator) emitln(format string, args ...any) {
	fmt.Fprintf(&g.buf, format+"\n", args...)
}

func (g *generator) nl() {
	g.buf.WriteByte('\n')
}

// checkHasStreaming returns true if any method has streaming.
func (g *generator) checkHasStreaming() bool {
	for _, res := range g.svc.Resources {
		if res == nil {
			continue
		}
		for _, m := range res.Methods {
			if m != nil && m.Stream != nil {
				return true
			}
		}
	}
	return false
}

// checkHasTime returns true if any type uses time.Time.
func (g *generator) checkHasTime() bool {
	for _, t := range g.svc.Types {
		if t == nil {
			continue
		}
		for _, f := range t.Fields {
			if f.Type == "time.Time" {
				return true
			}
		}
		if t.Elem == "time.Time" {
			return true
		}
	}
	return false
}

func (g *generator) emitHeader() {
	g.emitln("// Code generated by sdkgo. DO NOT EDIT.")
	g.nl()
	g.emitln("package %s", g.pkg)
	g.nl()
}

func (g *generator) emitImports() {
	// Collect imports based on what we need
	imports := []string{
		"bytes",
		"context",
		"encoding/json",
		"fmt",
		"io",
		"net/http",
		"strings",
	}
	if g.hasStreaming {
		imports = append(imports, "bufio")
	}
	if g.hasTime {
		imports = append(imports, "time")
	}
	sort.Strings(imports)

	g.emitln("import (")
	for _, imp := range imports {
		g.emitln("\t%q", imp)
	}
	g.emitln(")")
	g.nl()
}

func (g *generator) emitTypes() {
	if len(g.svc.Types) == 0 {
		return
	}

	g.emitln("// ────────────────────────────────────────────────────────────")
	g.emitln("// Types")
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.nl()

	// Sort types for stable output
	names := make([]string, 0, len(g.types))
	for name := range g.types {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		t := g.types[name]
		g.emitType(t)
		g.nl()
	}
}

func (g *generator) emitType(t *contract.Type) {
	if t == nil {
		return
	}

	switch t.Kind {
	case contract.KindStruct:
		g.emitStruct(t)
	case contract.KindSlice:
		g.emitSlice(t)
	case contract.KindMap:
		g.emitMap(t)
	case contract.KindUnion:
		g.emitUnion(t)
	}
}

func (g *generator) emitStruct(t *contract.Type) {
	if t.Description != "" {
		g.emitln("// %s %s", t.Name, t.Description)
	}
	g.emitln("type %s struct {", t.Name)
	for _, f := range t.Fields {
		g.emitField(f)
	}
	g.emitln("}")
}

func (g *generator) emitField(f contract.Field) {
	goName := toGoName(f.Name)
	goType := g.goType(f.Type, f.Optional, f.Nullable)

	// Build JSON tag
	tag := f.Name
	if f.Optional {
		tag += ",omitempty"
	}

	// Build comment
	var comment string
	if f.Const != "" {
		comment = fmt.Sprintf(" // always %q", f.Const)
	} else if len(f.Enum) > 0 {
		comment = fmt.Sprintf(" // one of: %s", strings.Join(f.Enum, ", "))
	} else if f.Description != "" {
		comment = " // " + f.Description
	}

	g.emitln("\t%s %s `json:%q`%s", goName, goType, tag, comment)
}

func (g *generator) emitSlice(t *contract.Type) {
	if t.Description != "" {
		g.emitln("// %s %s", t.Name, t.Description)
	}
	elemType := g.goType(t.Elem, false, false)
	g.emitln("type %s []%s", t.Name, elemType)
}

func (g *generator) emitMap(t *contract.Type) {
	if t.Description != "" {
		g.emitln("// %s %s", t.Name, t.Description)
	}
	elemType := g.goType(t.Elem, false, false)
	g.emitln("type %s map[string]%s", t.Name, elemType)
}

func (g *generator) emitUnion(t *contract.Type) {
	if t.Description != "" {
		g.emitln("// %s %s", t.Name, t.Description)
	} else {
		g.emitln("// %s is a discriminated union (tag: %q).", t.Name, t.Tag)
	}

	// List variants in comment
	var variantNames []string
	for _, v := range t.Variants {
		variantNames = append(variantNames, string(v.Type))
	}
	if len(variantNames) > 0 {
		g.emitln("// Variants: %s", strings.Join(variantNames, ", "))
	}

	g.emitln("type %s struct {", t.Name)
	for _, v := range t.Variants {
		fieldName := variantFieldName(v)
		g.emitln("\t%s *%s `json:\"-\"`", fieldName, v.Type)
	}
	g.emitln("}")
	g.nl()

	// MarshalJSON
	g.emitln("func (u *%s) MarshalJSON() ([]byte, error) {", t.Name)
	for _, v := range t.Variants {
		fieldName := variantFieldName(v)
		g.emitln("\tif u.%s != nil {", fieldName)
		g.emitln("\t\treturn json.Marshal(u.%s)", fieldName)
		g.emitln("\t}")
	}
	g.emitln("\treturn []byte(\"null\"), nil")
	g.emitln("}")
	g.nl()

	// UnmarshalJSON
	g.emitln("func (u *%s) UnmarshalJSON(data []byte) error {", t.Name)
	g.emitln("\tvar disc struct {")
	g.emitln("\t\t%s string `json:%q`", toGoName(t.Tag), t.Tag)
	g.emitln("\t}")
	g.emitln("\tif err := json.Unmarshal(data, &disc); err != nil {")
	g.emitln("\t\treturn err")
	g.emitln("\t}")
	g.emitln("\tswitch disc.%s {", toGoName(t.Tag))
	for _, v := range t.Variants {
		fieldName := variantFieldName(v)
		g.emitln("\tcase %q:", v.Value)
		g.emitln("\t\tu.%s = new(%s)", fieldName, v.Type)
		g.emitln("\t\treturn json.Unmarshal(data, u.%s)", fieldName)
	}
	g.emitln("\t}")
	g.emitln("\treturn fmt.Errorf(\"unknown %s %s: %%q\", disc.%s)", t.Name, t.Tag, toGoName(t.Tag))
	g.emitln("}")
}

func (g *generator) emitClient() {
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.emitln("// Client")
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.nl()

	svcName := sanitizeIdent(g.svc.Name)
	if svcName == "" {
		svcName = "API"
	}

	g.emitln("// Client is the %s API client.", svcName)
	g.emitln("type Client struct {")
	// Resource fields
	for _, res := range g.svc.Resources {
		if res == nil {
			continue
		}
		resName := toGoName(res.Name)
		g.emitln("\t%s *%sResource", resName, resName)
	}
	g.emitln("\t// internal")
	g.emitln("\tbaseURL string")
	g.emitln("\ttoken   string")
	g.emitln("\theaders map[string]string")
	g.emitln("\thttp    *http.Client")
	g.emitln("}")
	g.nl()

	// NewClient
	baseURL := ""
	if g.svc.Defaults != nil && g.svc.Defaults.BaseURL != "" {
		baseURL = strings.TrimRight(g.svc.Defaults.BaseURL, "/")
	}

	g.emitln("// NewClient creates a new %s client.", svcName)
	g.emitln("func NewClient(token string, opts ...Option) *Client {")
	g.emitln("\tc := &Client{")
	g.emitln("\t\tbaseURL: %q,", baseURL)
	g.emitln("\t\ttoken:   token,")
	g.emitln("\t\theaders: make(map[string]string),")
	g.emitln("\t\thttp:    http.DefaultClient,")
	g.emitln("\t}")
	g.emitln("\tfor _, opt := range opts {")
	g.emitln("\t\topt(c)")
	g.emitln("\t}")
	// Initialize resources
	for _, res := range g.svc.Resources {
		if res == nil {
			continue
		}
		resName := toGoName(res.Name)
		g.emitln("\tc.%s = &%sResource{client: c}", resName, resName)
	}
	g.emitln("\treturn c")
	g.emitln("}")
	g.nl()

	// Option type and common options
	g.emitln("// Option configures the client.")
	g.emitln("type Option func(*Client)")
	g.nl()

	g.emitln("// WithBaseURL sets a custom base URL.")
	g.emitln("func WithBaseURL(url string) Option {")
	g.emitln("\treturn func(c *Client) { c.baseURL = strings.TrimRight(url, \"/\") }")
	g.emitln("}")
	g.nl()

	g.emitln("// WithHTTPClient sets a custom HTTP client.")
	g.emitln("func WithHTTPClient(h *http.Client) Option {")
	g.emitln("\treturn func(c *Client) { c.http = h }")
	g.emitln("}")
	g.nl()

	g.emitln("// WithHeader adds a custom header to all requests.")
	g.emitln("func WithHeader(key, value string) Option {")
	g.emitln("\treturn func(c *Client) { c.headers[key] = value }")
	g.emitln("}")
	g.nl()
}

func (g *generator) emitResources() {
	if len(g.svc.Resources) == 0 {
		return
	}

	g.emitln("// ────────────────────────────────────────────────────────────")
	g.emitln("// Resources")
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.nl()

	for _, res := range g.svc.Resources {
		if res == nil {
			continue
		}
		g.emitResource(res)
	}
}

func (g *generator) emitResource(res *contract.Resource) {
	resName := toGoName(res.Name)

	// Resource struct
	if res.Description != "" {
		g.emitln("// %sResource %s", resName, res.Description)
	} else {
		g.emitln("// %sResource handles %s operations.", resName, res.Name)
	}
	g.emitln("type %sResource struct {", resName)
	g.emitln("\tclient *Client")
	g.emitln("}")
	g.nl()

	// Methods
	for _, m := range res.Methods {
		if m == nil {
			continue
		}
		g.emitMethod(res, m)
	}
}

func (g *generator) emitMethod(res *contract.Resource, m *contract.Method) {
	resName := toGoName(res.Name)
	methodName := toGoName(m.Name)

	// Determine HTTP binding
	httpMethod := "POST"
	httpPath := "/" + res.Name
	if m.HTTP != nil {
		if m.HTTP.Method != "" {
			httpMethod = strings.ToUpper(m.HTTP.Method)
		}
		if m.HTTP.Path != "" {
			httpPath = m.HTTP.Path
		}
	}

	// Build signature
	hasInput := m.Input != ""
	hasOutput := m.Output != ""
	isStreaming := m.Stream != nil

	// Comment
	if m.Description != "" {
		g.emitln("// %s %s", methodName, m.Description)
	}

	if isStreaming {
		// Streaming method - inline the stream setup
		streamType := string(m.Stream.Item)
		if hasInput {
			g.emitln("func (r *%sResource) %s(ctx context.Context, in *%s) *EventStream[%s] {",
				resName, methodName, m.Input, streamType)
		} else {
			g.emitln("func (r *%sResource) %s(ctx context.Context) *EventStream[%s] {",
				resName, methodName, streamType)
		}
		g.emitln("\tparse := func(data []byte) (%s, error) {", streamType)
		g.emitln("\t\tvar v %s", streamType)
		g.emitln("\t\terr := json.Unmarshal(data, &v)")
		g.emitln("\t\treturn v, err")
		g.emitln("\t}")
		g.nl()
		g.emitln("\ts := &EventStream[%s]{parse: parse}", streamType)
		g.emitln("\tu := r.client.baseURL + %q", httpPath)
		g.nl()
		g.emitln("\tvar body io.Reader")
		if hasInput {
			g.emitln("\tif in != nil {")
			g.emitln("\t\tb, err := json.Marshal(in)")
			g.emitln("\t\tif err != nil {")
			g.emitln("\t\t\ts.err = err")
			g.emitln("\t\t\treturn s")
			g.emitln("\t\t}")
			g.emitln("\t\tbody = bytes.NewReader(b)")
			g.emitln("\t}")
		}
		g.nl()
		g.emitln("\treq, err := http.NewRequestWithContext(ctx, %q, u, body)", httpMethod)
		g.emitln("\tif err != nil {")
		g.emitln("\t\ts.err = err")
		g.emitln("\t\treturn s")
		g.emitln("\t}")
		g.nl()
		g.emitln("\treq.Header.Set(\"Content-Type\", \"application/json\")")
		g.emitln("\treq.Header.Set(\"Accept\", \"text/event-stream\")")
		g.emitln("\tif r.client.token != \"\" {")
		g.emitln("\t\treq.Header.Set(\"Authorization\", \"Bearer \"+r.client.token)")
		g.emitln("\t}")
		g.emitln("\tfor k, v := range r.client.headers {")
		g.emitln("\t\treq.Header.Set(k, v)")
		g.emitln("\t}")
		g.nl()
		g.emitln("\tresp, err := r.client.http.Do(req)")
		g.emitln("\tif err != nil {")
		g.emitln("\t\ts.err = err")
		g.emitln("\t\treturn s")
		g.emitln("\t}")
		g.nl()
		g.emitln("\tif resp.StatusCode >= 400 {")
		g.emitln("\t\ts.err = decodeError(resp)")
		g.emitln("\t\tresp.Body.Close()")
		g.emitln("\t\treturn s")
		g.emitln("\t}")
		g.nl()
		g.emitln("\ts.resp = resp")
		g.emitln("\ts.scanner = bufio.NewScanner(resp.Body)")
		g.emitln("\treturn s")
		g.emitln("}")
	} else {
		// Regular method
		switch {
		case !hasInput && !hasOutput:
			g.emitln("func (r *%sResource) %s(ctx context.Context) error {",
				resName, methodName)
			g.emitln("\treturn r.client.do(ctx, %q, %q, nil, nil)", httpMethod, httpPath)
			g.emitln("}")
		case !hasInput && hasOutput:
			g.emitln("func (r *%sResource) %s(ctx context.Context) (*%s, error) {",
				resName, methodName, m.Output)
			g.emitln("\tvar out %s", m.Output)
			g.emitln("\terr := r.client.do(ctx, %q, %q, nil, &out)", httpMethod, httpPath)
			g.emitln("\tif err != nil {")
			g.emitln("\t\treturn nil, err")
			g.emitln("\t}")
			g.emitln("\treturn &out, nil")
			g.emitln("}")
		case hasInput && !hasOutput:
			g.emitln("func (r *%sResource) %s(ctx context.Context, in *%s) error {",
				resName, methodName, m.Input)
			g.emitln("\treturn r.client.do(ctx, %q, %q, in, nil)", httpMethod, httpPath)
			g.emitln("}")
		case hasInput && hasOutput:
			g.emitln("func (r *%sResource) %s(ctx context.Context, in *%s) (*%s, error) {",
				resName, methodName, m.Input, m.Output)
			g.emitln("\tvar out %s", m.Output)
			g.emitln("\terr := r.client.do(ctx, %q, %q, in, &out)", httpMethod, httpPath)
			g.emitln("\tif err != nil {")
			g.emitln("\t\treturn nil, err")
			g.emitln("\t}")
			g.emitln("\treturn &out, nil")
			g.emitln("}")
		}
	}
	g.nl()
}

func (g *generator) emitStreaming() {
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.emitln("// Streaming")
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.nl()

	g.emitln("// EventStream reads server-sent events.")
	g.emitln("type EventStream[T any] struct {")
	g.emitln("\tresp    *http.Response")
	g.emitln("\tscanner *bufio.Scanner")
	g.emitln("\tparse   func([]byte) (T, error)")
	g.emitln("\tcurrent T")
	g.emitln("\terr     error")
	g.emitln("}")
	g.nl()

	g.emitln("// Next advances to the next event. Returns false when done or on error.")
	g.emitln("func (s *EventStream[T]) Next() bool {")
	g.emitln("\tif s.err != nil || s.scanner == nil {")
	g.emitln("\t\treturn false")
	g.emitln("\t}")
	g.emitln("\tfor s.scanner.Scan() {")
	g.emitln("\t\tline := s.scanner.Text()")
	g.emitln("\t\tif !strings.HasPrefix(line, \"data: \") {")
	g.emitln("\t\t\tcontinue")
	g.emitln("\t\t}")
	g.emitln("\t\tdata := strings.TrimPrefix(line, \"data: \")")
	g.emitln("\t\tif data == \"[DONE]\" {")
	g.emitln("\t\t\treturn false")
	g.emitln("\t\t}")
	g.emitln("\t\ts.current, s.err = s.parse([]byte(data))")
	g.emitln("\t\tif s.err != nil {")
	g.emitln("\t\t\treturn false")
	g.emitln("\t\t}")
	g.emitln("\t\treturn true")
	g.emitln("\t}")
	g.emitln("\ts.err = s.scanner.Err()")
	g.emitln("\treturn false")
	g.emitln("}")
	g.nl()

	g.emitln("// Event returns the current event. Call after Next returns true.")
	g.emitln("func (s *EventStream[T]) Event() T {")
	g.emitln("\treturn s.current")
	g.emitln("}")
	g.nl()

	g.emitln("// Err returns any error that occurred during streaming.")
	g.emitln("func (s *EventStream[T]) Err() error {")
	g.emitln("\treturn s.err")
	g.emitln("}")
	g.nl()

	g.emitln("// Close closes the underlying connection.")
	g.emitln("func (s *EventStream[T]) Close() error {")
	g.emitln("\tif s.resp != nil && s.resp.Body != nil {")
	g.emitln("\t\treturn s.resp.Body.Close()")
	g.emitln("\t}")
	g.emitln("\treturn nil")
	g.emitln("}")
	g.nl()
}

func (g *generator) emitHelpers() {
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.emitln("// Internal helpers")
	g.emitln("// ────────────────────────────────────────────────────────────")
	g.nl()

	// Error type
	g.emitln("// Error represents an API error response.")
	g.emitln("type Error struct {")
	g.emitln("\tStatusCode int    `json:\"-\"`")
	g.emitln("\tCode       string `json:\"code,omitempty\"`")
	g.emitln("\tMessage    string `json:\"message\"`")
	g.emitln("}")
	g.nl()

	g.emitln("func (e *Error) Error() string {")
	g.emitln("\tif e.Code != \"\" {")
	g.emitln("\t\treturn fmt.Sprintf(\"%%s: %%s\", e.Code, e.Message)")
	g.emitln("\t}")
	g.emitln("\treturn e.Message")
	g.emitln("}")
	g.nl()

	// do method
	g.emitln("func (c *Client) do(ctx context.Context, method, path string, in, out any) error {")
	g.emitln("\tu := c.baseURL + path")
	g.nl()
	g.emitln("\tvar body io.Reader")
	g.emitln("\tif method != \"GET\" && in != nil {")
	g.emitln("\t\tb, err := json.Marshal(in)")
	g.emitln("\t\tif err != nil {")
	g.emitln("\t\t\treturn err")
	g.emitln("\t\t}")
	g.emitln("\t\tbody = bytes.NewReader(b)")
	g.emitln("\t}")
	g.nl()
	g.emitln("\treq, err := http.NewRequestWithContext(ctx, method, u, body)")
	g.emitln("\tif err != nil {")
	g.emitln("\t\treturn err")
	g.emitln("\t}")
	g.nl()
	g.emitln("\treq.Header.Set(\"Content-Type\", \"application/json\")")
	g.emitln("\tif c.token != \"\" {")
	g.emitln("\t\treq.Header.Set(\"Authorization\", \"Bearer \"+c.token)")
	g.emitln("\t}")
	g.emitln("\tfor k, v := range c.headers {")
	g.emitln("\t\treq.Header.Set(k, v)")
	g.emitln("\t}")
	g.nl()
	g.emitln("\tresp, err := c.http.Do(req)")
	g.emitln("\tif err != nil {")
	g.emitln("\t\treturn err")
	g.emitln("\t}")
	g.emitln("\tdefer resp.Body.Close()")
	g.nl()
	g.emitln("\tif resp.StatusCode >= 400 {")
	g.emitln("\t\treturn decodeError(resp)")
	g.emitln("\t}")
	g.nl()
	g.emitln("\tif out == nil || resp.StatusCode == http.StatusNoContent {")
	g.emitln("\t\treturn nil")
	g.emitln("\t}")
	g.nl()
	g.emitln("\treturn json.NewDecoder(resp.Body).Decode(out)")
	g.emitln("}")
	g.nl()

	// decodeError helper
	g.emitln("func decodeError(resp *http.Response) error {")
	g.emitln("\tvar e Error")
	g.emitln("\te.StatusCode = resp.StatusCode")
	g.emitln("\tif err := json.NewDecoder(resp.Body).Decode(&e); err != nil {")
	g.emitln("\t\te.Message = fmt.Sprintf(\"HTTP %%d\", resp.StatusCode)")
	g.emitln("\t}")
	g.emitln("\tif e.Message == \"\" {")
	g.emitln("\t\te.Message = fmt.Sprintf(\"HTTP %%d\", resp.StatusCode)")
	g.emitln("\t}")
	g.emitln("\treturn &e")
	g.emitln("}")
	g.nl()

	// Suppress unused import warnings
	g.emitln("var _ = strings.TrimSpace")
}

// goType converts a contract.TypeRef to a Go type string.
func (g *generator) goType(ref contract.TypeRef, optional, nullable bool) string {
	r := strings.TrimSpace(string(ref))
	if r == "" {
		return "any"
	}

	base := g.baseGoType(r)

	// Apply pointer for optional/nullable
	if optional || nullable {
		// Don't double-pointer slices, maps, or any
		if !strings.HasPrefix(base, "[]") &&
			!strings.HasPrefix(base, "map[") &&
			base != "any" &&
			base != "json.RawMessage" {
			return "*" + base
		}
	}
	return base
}

func (g *generator) baseGoType(r string) string {
	// Check if it's a declared type
	if _, ok := g.types[r]; ok {
		return r
	}

	// Handle collection syntax
	if strings.HasPrefix(r, "[]") {
		elem := strings.TrimPrefix(r, "[]")
		return "[]" + g.baseGoType(elem)
	}
	if strings.HasPrefix(r, "map[string]") {
		elem := strings.TrimPrefix(r, "map[string]")
		return "map[string]" + g.baseGoType(elem)
	}

	// Primitives and externals
	switch r {
	case "string":
		return "string"
	case "bool", "boolean":
		return "bool"
	case "int":
		return "int"
	case "int8":
		return "int8"
	case "int16":
		return "int16"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "uint":
		return "uint"
	case "uint8":
		return "uint8"
	case "uint16":
		return "uint16"
	case "uint32":
		return "uint32"
	case "uint64":
		return "uint64"
	case "float32":
		return "float32"
	case "float64":
		return "float64"
	case "time.Time":
		return "time.Time"
	case "json.RawMessage":
		return "json.RawMessage"
	case "any":
		return "any"
	}

	// Unknown types become any
	return "any"
}

// toGoName converts snake_case or kebab-case to PascalCase.
func toGoName(s string) string {
	if s == "" {
		return ""
	}

	var result strings.Builder
	capitalizeNext := true

	for _, r := range s {
		if r == '_' || r == '-' || r == '.' {
			capitalizeNext = true
			continue
		}
		if capitalizeNext {
			result.WriteRune(unicode.ToUpper(r))
			capitalizeNext = false
		} else {
			result.WriteRune(r)
		}
	}

	// Handle common acronyms
	out := result.String()
	out = strings.ReplaceAll(out, "Id", "ID")
	out = strings.ReplaceAll(out, "Url", "URL")
	out = strings.ReplaceAll(out, "Http", "HTTP")
	out = strings.ReplaceAll(out, "Api", "API")
	out = strings.ReplaceAll(out, "Sse", "SSE")
	out = strings.ReplaceAll(out, "Json", "JSON")

	return out
}

// variantFieldName creates a Go field name for a union variant.
func variantFieldName(v contract.Variant) string {
	// Use the type name, but strip common prefixes that match the parent
	name := string(v.Type)
	// Convert to Go name
	return toGoName(name)
}

// sanitizeIdent removes non-identifier characters.
func sanitizeIdent(s string) string {
	var result strings.Builder
	for _, r := range s {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
			result.WriteRune(r)
		}
	}
	return result.String()
}
