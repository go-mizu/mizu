{{define "_resource.py.tmpl"}}
from __future__ import annotations

from typing import Any, Dict, Optional, Union

from ._types import *
{{- if .HasSSE }}
from ._streaming import Stream, AsyncStream
{{- end }}


def build_resources(client: Any) -> None:
{{- range .Resources}}
    client.{{.PyName}} = {{.ClassName}}(client)
{{- end }}


{{- range .Resources}}

class {{.ClassName}}:
    def __init__(self, client: Any):
        self._client = client

{{- $res := .}}
{{- range .Methods}}

    {{- if .Description}}
    # {{.Description}}
    {{- end}}

    def {{.PyName}}(
        self,
        {{- if .HasInput}}
        request: Union[Dict[str, Any], {{.InputType}}],
        {{- end}}
    ):
        {{- if .HasInput}}
        payload = request if isinstance(request, dict) else request.model_dump()
        {{- else}}
        payload: Any = None
        {{- end}}
        {{- if .IsStreaming}}
        {{- if .StreamIsSSE}}

        if self._client.__class__.__name__ == "AsyncOpenAI":
            return AsyncStream(
                client=self._client,
                method={{pyString .HTTPMethod}},
                path={{pyString .HTTPPath}},
                json=payload,
                item_type={{.StreamItem}},
            )
        return Stream(
            client=self._client,
            method={{pyString .HTTPMethod}},
            path={{pyString .HTTPPath}},
            json=payload,
            item_type={{.StreamItem}},
        )
        {{- else}}
        raise NotImplementedError({{pyString (printf `stream mode "%s" is not supported` .StreamMode)}})
        {{- end}}
        {{- else}}

        if self._client.__class__.__name__ == "AsyncOpenAI":
            # The async client will overwrite this method at runtime via attribute binding in Python
            # but we keep a single template for simplicity.
            raise RuntimeError("async method called on sync resource; use AsyncOpenAI")

        data = self._client._request({{pyString .HTTPMethod}}, {{pyString .HTTPPath}}, json=payload)
        {{- if .HasOutput}}
        return {{.OutputType}}.model_validate(data)
        {{- else}}
        return data
        {{- end}}
        {{- end}}

{{- end}}
{{- end}}

{{end}}
