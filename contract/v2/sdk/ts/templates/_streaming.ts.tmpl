{{define "_streaming.ts.tmpl"}}// Code generated by sdkts. DO NOT EDIT.

export interface StreamClient {
  _streamRequest(options: {
    method: string;
    path: string;
    body?: unknown;
    signal?: AbortSignal;
  }): Promise<Response>;
}

export interface StreamOptions<T> {
  response: Response;
  parse: (data: string) => T;
}

async function* streamSSE<T>(options: StreamOptions<T>): AsyncGenerator<T> {
  const reader = options.response.body?.getReader();
  if (!reader) return;

  const decoder = new TextDecoder();
  let buffer = "";

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() ?? "";

      let dataBuffer = "";
      for (const line of lines) {
        if (line === "") {
          // Empty line signals end of event
          if (dataBuffer) {
            const data = dataBuffer.trim();
            dataBuffer = "";
            if (data === "[DONE]") return;
            yield options.parse(data);
          }
          continue;
        }
        if (line.startsWith("data:")) {
          let data = line.slice(5);
          if (data.startsWith(" ")) {
            data = data.slice(1);
          }
          if (dataBuffer) {
            dataBuffer += "\n";
          }
          dataBuffer += data;
        }
      }
    }

    // Process remaining buffer
    if (buffer) {
      const lines = buffer.split("\n");
      let dataBuffer = "";
      for (const line of lines) {
        if (line === "") {
          if (dataBuffer) {
            const data = dataBuffer.trim();
            dataBuffer = "";
            if (data !== "[DONE]") {
              yield options.parse(data);
            }
          }
          continue;
        }
        if (line.startsWith("data:")) {
          let data = line.slice(5);
          if (data.startsWith(" ")) {
            data = data.slice(1);
          }
          if (dataBuffer) {
            dataBuffer += "\n";
          }
          dataBuffer += data;
        }
      }
      if (dataBuffer) {
        const data = dataBuffer.trim();
        if (data !== "[DONE]") {
          yield options.parse(data);
        }
      }
    }
  } finally {
    reader.releaseLock();
  }
}

export class Stream<T> implements AsyncIterable<T> {
  readonly controller: AbortController;
  private _iterator: AsyncGenerator<T> | null = null;

  constructor(
    private readonly _client: StreamClient,
    private readonly _options: { method: string; path: string; body?: unknown },
    private readonly _parse: (data: string) => T,
  ) {
    this.controller = new AbortController();
  }

  private async *_stream(): AsyncGenerator<T> {
    const response = await this._client._streamRequest({
      ...this._options,
      signal: this.controller.signal,
    });

    yield* streamSSE({
      response,
      parse: this._parse,
    });
  }

  [Symbol.asyncIterator](): AsyncIterator<T> {
    if (!this._iterator) {
      this._iterator = this._stream();
    }
    return this._iterator;
  }

  async toArray(): Promise<T[]> {
    const items: T[] = [];
    for await (const item of this) {
      items.push(item);
    }
    return items;
  }
}
{{end}}
