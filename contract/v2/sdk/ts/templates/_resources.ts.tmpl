{{define "_resources.ts.tmpl"}}// Code generated by sdkts. DO NOT EDIT.

{{- if .HasSSE}}
import type { Stream } from "./_streaming.ts";
{{- end}}
import type {
{{- range .Types}}
  {{.Name}},
{{- end}}
} from "./_types.ts";

// Forward declaration to avoid circular imports
interface ClientLike {
  _request<T>(options: { method: string; path: string; body?: unknown }): Promise<T>;
{{- if .HasSSE}}
  _stream<T>(options: { method: string; path: string; body?: unknown }, parse: (data: string) => T): Stream<T>;
{{- end}}
}

{{- range .Resources}}

{{- if .Description}}
/** {{.Description}} */
{{- end}}
export class {{.ClassName}} {
  constructor(private readonly _client: ClientLike) {}

{{- $res := .}}
{{- range .Methods}}

{{- if .Description}}
  /** {{.Description}} */
{{- end}}

{{- if .IsStreaming}}
{{- if .StreamIsSSE}}
  {{.TSName}}({{if .HasInput}}request: {{.InputType}}{{end}}): Stream<{{.StreamItem}}> {
    return this._client._stream<{{.StreamItem}}>(
      {
        method: {{tsString .HTTPMethod}},
        path: {{tsString .HTTPPath}},
        {{- if .HasInput}}
        body: request,
        {{- end}}
      },
      (data: string) => JSON.parse(data) as {{.StreamItem}},
    );
  }
{{- else}}
  {{.TSName}}({{if .HasInput}}request: {{.InputType}}{{end}}): never {
    throw new Error({{tsString (printf `stream mode "%s" is not supported` .StreamMode)}});
  }
{{- end}}
{{- else}}

{{- if and (not .HasInput) (not .HasOutput)}}
  async {{.TSName}}(): Promise<void> {
    await this._client._request<void>({
      method: {{tsString .HTTPMethod}},
      path: {{tsString .HTTPPath}},
    });
  }
{{- end}}

{{- if and (not .HasInput) .HasOutput}}
  async {{.TSName}}(): Promise<{{.OutputType}}> {
    return this._client._request<{{.OutputType}}>({
      method: {{tsString .HTTPMethod}},
      path: {{tsString .HTTPPath}},
    });
  }
{{- end}}

{{- if and .HasInput (not .HasOutput)}}
  async {{.TSName}}(request: {{.InputType}}): Promise<void> {
    await this._client._request<void>({
      method: {{tsString .HTTPMethod}},
      path: {{tsString .HTTPPath}},
      body: request,
    });
  }
{{- end}}

{{- if and .HasInput .HasOutput}}
  async {{.TSName}}(request: {{.InputType}}): Promise<{{.OutputType}}> {
    return this._client._request<{{.OutputType}}>({
      method: {{tsString .HTTPMethod}},
      path: {{tsString .HTTPPath}},
      body: request,
    });
  }
{{- end}}

{{- end}}

{{- end}}
}
{{- end}}
{{end}}
