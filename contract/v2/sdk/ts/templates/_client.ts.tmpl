{{define "_client.ts.tmpl"}}// Code generated by sdkts. DO NOT EDIT.

{{- if .HasSSE}}
import { Stream } from "./_streaming.ts";
{{- end}}
import {
{{- range .Resources}}
  {{.ClassName}},
{{- end}}
} from "./_resources.ts";

export class SDKError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "SDKError";
  }
}

export class APIConnectionError extends SDKError {
  constructor(message: string) {
    super(message);
    this.name = "APIConnectionError";
  }
}

export class APIStatusError extends SDKError {
  readonly status: number;
  readonly body: unknown;

  constructor(status: number, message: string, body?: unknown) {
    super(message);
    this.name = "APIStatusError";
    this.status = status;
    this.body = body;
  }
}

export interface ClientOptions {
  apiKey?: string;
  baseURL?: string;
  timeout?: number;
  maxRetries?: number;
  defaultHeaders?: Record<string, string>;
}

interface RequestOptions {
  method: string;
  path: string;
  body?: unknown;
  headers?: Record<string, string>;
  signal?: AbortSignal;
}

function applyAuth(headers: Record<string, string>, auth: string, apiKey: string | undefined): void {
  if (!apiKey) return;
  const mode = (auth || "bearer").toLowerCase();
  if (mode === "none") return;
  if (mode === "basic") {
    headers["Authorization"] = `Basic ${apiKey}`;
    return;
  }
  headers["Authorization"] = `Bearer ${apiKey}`;
}

export interface ClientConfig {
  apiKey: string | undefined;
  baseURL: string;
  timeout: number;
  maxRetries: number;
  auth: string;
  headers: Record<string, string>;
}

export class {{.Service.Sanitized}} {
{{- range .Resources}}
  readonly {{.TSName}}: {{.ClassName}};
{{- end}}

  private readonly _config: ClientConfig;

  constructor(options: ClientOptions = {}) {
    const headers: Record<string, string> = {};
{{- range .Client.Headers}}
    headers[{{tsString .K}}] = {{tsString .V}};
{{- end}}
    if (options.defaultHeaders) {
      Object.assign(headers, options.defaultHeaders);
    }

    this._config = {
      apiKey: options.apiKey,
      baseURL: (options.baseURL ?? {{tsString .Client.BaseURL}}).replace(/\/$/, ""),
      timeout: options.timeout ?? 60000,
      maxRetries: options.maxRetries ?? 2,
      auth: {{tsString .Client.Auth}},
      headers,
    };

{{- range .Resources}}
    this.{{.TSName}} = new {{.ClassName}}(this);
{{- end}}
  }

  get config(): ClientConfig {
    return this._config;
  }

  async _request<T>(options: RequestOptions): Promise<T> {
    const url = this._config.baseURL + options.path;
    const headers: Record<string, string> = { ...this._config.headers };
    headers["Content-Type"] = "application/json";
    applyAuth(headers, this._config.auth, this._config.apiKey);
    if (options.headers) {
      Object.assign(headers, options.headers);
    }

    let lastError: Error | undefined;
    for (let attempt = 0; attempt <= this._config.maxRetries; attempt++) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this._config.timeout);

      try {
        const response = await fetch(url, {
          method: options.method,
          headers,
          body: options.body ? JSON.stringify(options.body) : undefined,
          signal: options.signal ?? controller.signal,
        });

        clearTimeout(timeoutId);

        if (response.status >= 400) {
          let body: unknown;
          let message = `HTTP ${response.status}`;
          try {
            body = await response.json();
            if (typeof body === "object" && body !== null && "message" in body) {
              message = String((body as { message: unknown }).message);
            }
          } catch {
            body = await response.text();
          }
          throw new APIStatusError(response.status, message, body);
        }

        if (response.status === 204) {
          return undefined as T;
        }

        const contentType = response.headers.get("content-type") ?? "";
        if (contentType.includes("application/json")) {
          return (await response.json()) as T;
        }

        return (await response.text()) as unknown as T;
      } catch (err) {
        clearTimeout(timeoutId);
        if (err instanceof APIStatusError) {
          throw err;
        }
        lastError = err instanceof Error ? err : new Error(String(err));
      }
    }

    throw new APIConnectionError(lastError?.message ?? "request failed");
  }

{{- if .HasSSE}}

  _stream<T>(
    options: RequestOptions,
    parse: (data: string) => T,
  ): Stream<T> {
    return new Stream<T>(this, options, parse);
  }

  async _streamRequest(options: RequestOptions & { signal?: AbortSignal }): Promise<Response> {
    const url = this._config.baseURL + options.path;
    const headers: Record<string, string> = { ...this._config.headers };
    headers["Content-Type"] = "application/json";
    headers["Accept"] = "text/event-stream";
    applyAuth(headers, this._config.auth, this._config.apiKey);
    if (options.headers) {
      Object.assign(headers, options.headers);
    }

    const response = await fetch(url, {
      method: options.method,
      headers,
      body: options.body ? JSON.stringify(options.body) : undefined,
      signal: options.signal,
    });

    if (response.status >= 400) {
      let body: unknown;
      let message = `HTTP ${response.status}`;
      try {
        body = await response.json();
        if (typeof body === "object" && body !== null && "message" in body) {
          message = String((body as { message: unknown }).message);
        }
      } catch {
        body = await response.text();
      }
      throw new APIStatusError(response.status, message, body);
    }

    return response;
  }
{{- end}}
}

{{end}}
