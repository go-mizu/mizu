package server

import (
	"net/http"

	contract "github.com/go-mizu/mizu/contract/v2"
	"github.com/go-mizu/mizu/contract/v2/transport/jsonrpc"
	"github.com/go-mizu/mizu/contract/v2/transport/rest"
	"{{.Module}}/service/todo"
)

// Server wraps the HTTP server with all transports.
type Server struct {
	cfg      Config
	server   *http.Server
	contract *contract.Service
}

// New creates a server with REST, JSON-RPC, and OpenAPI transports.
func New(cfg Config, todoSvc *todo.Service, svc *contract.Service) (*Server, error) {
	// Create invoker that dispatches to the service
	invoker := todo.NewInvoker(todoSvc, svc)

	mux := http.NewServeMux()

	// Mount REST endpoints using contract bindings
	restServer, err := rest.NewServer(invoker)
	if err != nil {
		return nil, err
	}
	mux.Handle("/", restServer.Handler())

	// Mount JSON-RPC 2.0 endpoint
	rpcServer, err := jsonrpc.NewServer(invoker)
	if err != nil {
		return nil, err
	}
	mux.Handle("/rpc", rpcServer.Handler())

	// Serve OpenAPI 3.0 spec
	mux.HandleFunc("GET /openapi.json", func(w http.ResponseWriter, r *http.Request) {
		spec, err := rest.OpenAPIDocument(svc)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.Write(spec)
	})

	return &Server{
		cfg: cfg,
		server: &http.Server{
			Addr:    cfg.Addr,
			Handler: mux,
		},
		contract: svc,
	}, nil
}

// ListenAndServe starts the HTTP server.
func (s *Server) ListenAndServe() error {
	return s.server.ListenAndServe()
}

// Close shuts down the server.
func (s *Server) Close() error {
	return s.server.Close()
}

// Contract returns the loaded contract service.
func (s *Server) Contract() *contract.Service {
	return s.contract
}
