import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'transport.dart';
import 'token_store.dart';
import 'live.dart';
import 'device_info.dart';
import 'exceptions.dart';

/// MizuRuntime is the core client for communicating with a Mizu backend.
class MizuRuntime extends ChangeNotifier {
  /// Shared singleton instance
  static final MizuRuntime shared = MizuRuntime._internal();

  /// Base URL for all API requests
  String baseURL;

  /// HTTP transport layer
  final Transport transport;

  /// Secure token storage
  final TokenStore tokenStore;

  /// Live connection manager
  late final LiveConnection live;

  /// Request timeout duration
  Duration timeout;

  /// Default headers added to all requests
  final Map<String, String> defaultHeaders = {};

  /// Current authentication state
  bool _isAuthenticated = false;
  bool get isAuthenticated => _isAuthenticated;

  /// Private constructor for singleton
  MizuRuntime._internal({
    this.baseURL = 'http://localhost:3000',
    Transport? transport,
    TokenStore? tokenStore,
    this.timeout = const Duration(seconds: 30),
  })  : transport = transport ?? HttpTransport(),
        tokenStore = tokenStore ?? SecureTokenStore() {
    live = LiveConnection(this);
    _initAuthState();
  }

  /// Factory constructor
  factory MizuRuntime({
    String baseURL = 'http://localhost:3000',
    Transport? transport,
    TokenStore? tokenStore,
    Duration timeout = const Duration(seconds: 30),
  }) {
    shared.baseURL = baseURL;
    shared.timeout = timeout;
    return shared;
  }

  /// Initialize with configuration
  static Future<MizuRuntime> initialize({
    required String baseURL,
    Duration timeout = const Duration(seconds: 30),
  }) async {
    shared.baseURL = baseURL;
    shared.timeout = timeout;
    await shared._initAuthState();
    return shared;
  }

  Future<void> _initAuthState() async {
    final token = await tokenStore.getToken();
    _isAuthenticated = token != null;
    notifyListeners();

    tokenStore.onTokenChange((token) {
      _isAuthenticated = token != null;
      notifyListeners();
    });
  }

  // MARK: - HTTP Methods

  /// Performs a GET request
  Future<T> get<T>(
    String path, {
    Map<String, String>? query,
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
  }) async {
    return _request<T, void>(
      method: 'GET',
      path: path,
      query: query,
      headers: headers,
      fromJson: fromJson,
    );
  }

  /// Performs a POST request
  Future<T> post<T, B>(
    String path, {
    B? body,
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
    Map<String, dynamic> Function(B)? toJson,
  }) async {
    return _request<T, B>(
      method: 'POST',
      path: path,
      body: body,
      headers: headers,
      fromJson: fromJson,
      toJson: toJson,
    );
  }

  /// Performs a PUT request
  Future<T> put<T, B>(
    String path, {
    B? body,
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
    Map<String, dynamic> Function(B)? toJson,
  }) async {
    return _request<T, B>(
      method: 'PUT',
      path: path,
      body: body,
      headers: headers,
      fromJson: fromJson,
      toJson: toJson,
    );
  }

  /// Performs a DELETE request
  Future<T> delete<T>(
    String path, {
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
  }) async {
    return _request<T, void>(
      method: 'DELETE',
      path: path,
      headers: headers,
      fromJson: fromJson,
    );
  }

  /// Performs a PATCH request
  Future<T> patch<T, B>(
    String path, {
    B? body,
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
    Map<String, dynamic> Function(B)? toJson,
  }) async {
    return _request<T, B>(
      method: 'PATCH',
      path: path,
      body: body,
      headers: headers,
      fromJson: fromJson,
      toJson: toJson,
    );
  }

  // MARK: - Streaming

  /// Opens a streaming connection for SSE
  Stream<ServerEvent> stream(
    String path, {
    Map<String, String>? headers,
  }) {
    return live.connect(path: path, headers: headers);
  }

  // MARK: - Private

  Future<T> _request<T, B>({
    required String method,
    required String path,
    Map<String, String>? query,
    B? body,
    Map<String, String>? headers,
    T Function(Map<String, dynamic>)? fromJson,
    Map<String, dynamic> Function(B)? toJson,
  }) async {
    // Build URL
    final url = _buildUrl(path, query);

    // Build headers
    final allHeaders = await _buildHeaders(headers);

    // Encode body
    String? bodyJson;
    if (body != null && toJson != null) {
      bodyJson = jsonEncode(toJson(body));
      allHeaders['Content-Type'] = 'application/json';
    } else if (body != null && body is Map) {
      bodyJson = jsonEncode(body);
      allHeaders['Content-Type'] = 'application/json';
    }

    // Execute request
    final response = await transport.execute(
      TransportRequest(
        url: url,
        method: method,
        headers: allHeaders,
        body: bodyJson,
        timeout: timeout,
      ),
    );

    // Handle errors
    if (response.statusCode >= 400) {
      throw _parseError(response);
    }

    // Handle empty response
    if (T == void || response.body.isEmpty) {
      return null as T;
    }

    // Decode response
    final json = jsonDecode(response.body);
    if (fromJson != null) {
      return fromJson(json as Map<String, dynamic>);
    }
    return json as T;
  }

  String _buildUrl(String path, Map<String, String>? query) {
    final base = baseURL.endsWith('/') ? baseURL.substring(0, baseURL.length - 1) : baseURL;
    final cleanPath = path.startsWith('/') ? path : '/$path';
    var url = '$base$cleanPath';

    if (query != null && query.isNotEmpty) {
      final queryString = query.entries
          .map((e) => '${Uri.encodeComponent(e.key)}=${Uri.encodeComponent(e.value)}')
          .join('&');
      url = '$url?$queryString';
    }

    return url;
  }

  Future<Map<String, String>> _buildHeaders(Map<String, String>? custom) async {
    final headers = <String, String>{};
    headers.addAll(defaultHeaders);
    headers.addAll(await _mobileHeaders());
    if (custom != null) {
      headers.addAll(custom);
    }

    // Add auth token
    final token = await tokenStore.getToken();
    if (token != null) {
      headers['Authorization'] = 'Bearer ${token.accessToken}';
    }

    return headers;
  }

  Future<Map<String, String>> _mobileHeaders() async {
    final info = await DeviceInfo.collect();
    return {
      'X-Device-ID': info.deviceId,
      'X-App-Version': info.appVersion,
      'X-App-Build': info.appBuild,
      'X-Device-Model': info.model,
      'X-Platform': info.platform,
      'X-OS-Version': info.osVersion,
      'X-Timezone': info.timezone,
      'X-Locale': info.locale,
    };
  }

  MizuError _parseError(TransportResponse response) {
    try {
      final json = jsonDecode(response.body) as Map<String, dynamic>;
      return MizuError.api(APIError.fromJson(json));
    } catch (_) {
      return MizuError.http(response.statusCode, response.body);
    }
  }
}
