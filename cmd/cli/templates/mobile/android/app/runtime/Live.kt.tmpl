package {{.Package}}.runtime

import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import okhttp3.*
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener
import okhttp3.sse.EventSources
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit

/** Server-sent event */
data class ServerEvent(
    val id: String? = null,
    val event: String? = null,
    val data: String,
    val retry: Int? = null
) {
    /** Decodes the event data as JSON */
    inline fun <reified T> decode(json: kotlinx.serialization.json.Json): T =
        json.decodeFromString(data)
}

/** Live connection manager for SSE */
class LiveConnection(private val runtime: MizuRuntime) {
    private val client = OkHttpClient.Builder()
        .connectTimeout(0, TimeUnit.MILLISECONDS)
        .readTimeout(0, TimeUnit.MILLISECONDS)
        .writeTimeout(0, TimeUnit.MILLISECONDS)
        .build()

    private val activeConnections = ConcurrentHashMap<String, EventSource>()

    /** Connects to an SSE endpoint and returns a Flow of events */
    fun connect(
        path: String,
        headers: Map<String, String>? = null
    ): Flow<ServerEvent> = callbackFlow {
        val url = buildUrl(path)
        val request = buildRequest(url, headers)

        val listener = object : EventSourceListener() {
            override fun onEvent(
                eventSource: EventSource,
                id: String?,
                type: String?,
                data: String
            ) {
                val event = ServerEvent(
                    id = id,
                    event = type,
                    data = data
                )
                trySend(event)
            }

            override fun onFailure(
                eventSource: EventSource,
                t: Throwable?,
                response: Response?
            ) {
                t?.let { close(MizuError.Network(it)) }
                    ?: close()
            }

            override fun onClosed(eventSource: EventSource) {
                close()
            }
        }

        val eventSource = EventSources.createFactory(client)
            .newEventSource(request, listener)

        activeConnections[path] = eventSource

        awaitClose {
            eventSource.cancel()
            activeConnections.remove(path)
        }
    }

    /** Disconnects from a specific path */
    fun disconnect(path: String) {
        activeConnections.remove(path)?.cancel()
    }

    /** Disconnects all active connections */
    fun disconnectAll() {
        activeConnections.values.forEach { it.cancel() }
        activeConnections.clear()
    }

    private fun buildUrl(path: String): String {
        val base = runtime.baseURL.trimEnd('/')
        val cleanPath = if (path.startsWith("/")) path else "/$path"
        return "$base$cleanPath"
    }

    private fun buildRequest(url: String, headers: Map<String, String>?): Request {
        val builder = Request.Builder()
            .url(url)
            .header("Accept", "text/event-stream")
            .header("Cache-Control", "no-cache")

        runtime.defaultHeaders.forEach { (key, value) ->
            builder.header(key, value)
        }

        headers?.forEach { (key, value) ->
            builder.header(key, value)
        }

        runtime.tokenStore.getToken()?.let { token ->
            builder.header("Authorization", "Bearer ${token.accessToken}")
        }

        return builder.build()
    }
}
