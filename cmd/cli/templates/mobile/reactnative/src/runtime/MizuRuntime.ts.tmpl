import { Transport, HttpTransport, TransportResponse } from './transport';
import { TokenStore, SecureTokenStore, AuthToken } from './tokenStore';
import { LiveConnection, ServerEvent } from './live';
import { DeviceInfo } from './deviceInfo';
import { MizuError, APIError } from './errors';

export interface MizuRuntimeConfig {
  baseURL?: string;
  transport?: Transport;
  tokenStore?: TokenStore;
  timeout?: number;
}

/**
 * MizuRuntime is the core client for communicating with a Mizu backend.
 */
export class MizuRuntime {
  private static _instance: MizuRuntime | null = null;

  /** Base URL for all API requests */
  baseURL: string;

  /** HTTP transport layer */
  readonly transport: Transport;

  /** Secure token storage */
  readonly tokenStore: TokenStore;

  /** Live connection manager */
  readonly live: LiveConnection;

  /** Request timeout in milliseconds */
  timeout: number;

  /** Default headers added to all requests */
  readonly defaultHeaders: Record<string, string> = {};

  /** Current authentication state */
  private _isAuthenticated: boolean = false;
  private _authListeners: Set<(isAuthenticated: boolean) => void> = new Set();

  get isAuthenticated(): boolean {
    return this._isAuthenticated;
  }

  /** Shared singleton instance */
  static get shared(): MizuRuntime {
    if (!MizuRuntime._instance) {
      MizuRuntime._instance = new MizuRuntime();
    }
    return MizuRuntime._instance;
  }

  constructor(config: MizuRuntimeConfig = {}) {
    this.baseURL = config.baseURL ?? 'http://localhost:3000';
    this.transport = config.transport ?? new HttpTransport();
    this.tokenStore = config.tokenStore ?? new SecureTokenStore();
    this.timeout = config.timeout ?? 30000;
    this.live = new LiveConnection(this);

    this._initAuthState();
  }

  /** Initialize with configuration */
  static async initialize(config: {
    baseURL: string;
    timeout?: number;
  }): Promise<MizuRuntime> {
    const runtime = MizuRuntime.shared;
    runtime.baseURL = config.baseURL;
    if (config.timeout) {
      runtime.timeout = config.timeout;
    }
    await runtime._initAuthState();
    return runtime;
  }

  private async _initAuthState(): Promise<void> {
    const token = await this.tokenStore.getToken();
    this._isAuthenticated = token !== null;
    this._notifyAuthListeners();

    this.tokenStore.onTokenChange((token) => {
      this._isAuthenticated = token !== null;
      this._notifyAuthListeners();
    });
  }

  /** Subscribe to authentication state changes */
  onAuthStateChange(listener: (isAuthenticated: boolean) => void): () => void {
    this._authListeners.add(listener);
    return () => this._authListeners.delete(listener);
  }

  private _notifyAuthListeners(): void {
    this._authListeners.forEach((listener) => listener(this._isAuthenticated));
  }

  // MARK: - HTTP Methods

  /** Performs a GET request */
  async get<T>(
    path: string,
    options: {
      query?: Record<string, string>;
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    return this._request<T>({
      method: 'GET',
      path,
      ...options,
    });
  }

  /** Performs a POST request */
  async post<T, B = unknown>(
    path: string,
    body?: B,
    options: {
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    return this._request<T>({
      method: 'POST',
      path,
      body,
      ...options,
    });
  }

  /** Performs a PUT request */
  async put<T, B = unknown>(
    path: string,
    body?: B,
    options: {
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    return this._request<T>({
      method: 'PUT',
      path,
      body,
      ...options,
    });
  }

  /** Performs a DELETE request */
  async delete<T>(
    path: string,
    options: {
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    return this._request<T>({
      method: 'DELETE',
      path,
      ...options,
    });
  }

  /** Performs a PATCH request */
  async patch<T, B = unknown>(
    path: string,
    body?: B,
    options: {
      headers?: Record<string, string>;
    } = {}
  ): Promise<T> {
    return this._request<T>({
      method: 'PATCH',
      path,
      body,
      ...options,
    });
  }

  // MARK: - Streaming

  /** Opens a streaming connection for SSE */
  stream(
    path: string,
    options: {
      headers?: Record<string, string>;
    } = {}
  ): {
    subscribe: (
      onEvent: (event: ServerEvent) => void,
      onError?: (error: Error) => void
    ) => () => void;
  } {
    return this.live.connect(path, options.headers);
  }

  // MARK: - Private

  private async _request<T>(options: {
    method: string;
    path: string;
    query?: Record<string, string>;
    body?: unknown;
    headers?: Record<string, string>;
  }): Promise<T> {
    const { method, path, query, body, headers } = options;

    // Build URL
    const url = this._buildUrl(path, query);

    // Build headers
    const allHeaders = await this._buildHeaders(headers);

    // Encode body
    let bodyJson: string | undefined;
    if (body !== undefined) {
      bodyJson = JSON.stringify(body);
      allHeaders['Content-Type'] = 'application/json';
    }

    // Execute request
    const response = await this.transport.execute({
      url,
      method,
      headers: allHeaders,
      body: bodyJson,
      timeout: this.timeout,
    });

    // Handle errors
    if (response.statusCode >= 400) {
      throw this._parseError(response);
    }

    // Handle empty response
    if (!response.body || response.body.length === 0) {
      return undefined as T;
    }

    // Decode response
    return JSON.parse(response.body) as T;
  }

  private _buildUrl(path: string, query?: Record<string, string>): string {
    const base = this.baseURL.endsWith('/') ? this.baseURL.slice(0, -1) : this.baseURL;
    const cleanPath = path.startsWith('/') ? path : `/${path}`;
    let url = `${base}${cleanPath}`;

    if (query && Object.keys(query).length > 0) {
      const queryString = Object.entries(query)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
      url = `${url}?${queryString}`;
    }

    return url;
  }

  private async _buildHeaders(custom?: Record<string, string>): Promise<Record<string, string>> {
    const headers: Record<string, string> = {};

    // Add default headers
    Object.assign(headers, this.defaultHeaders);

    // Add mobile headers
    const mobileHeaders = await this._mobileHeaders();
    Object.assign(headers, mobileHeaders);

    // Add custom headers
    if (custom) {
      Object.assign(headers, custom);
    }

    // Add auth token
    const token = await this.tokenStore.getToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token.accessToken}`;
    }

    return headers;
  }

  private async _mobileHeaders(): Promise<Record<string, string>> {
    const info = await DeviceInfo.collect();
    return {
      'X-Device-ID': info.deviceId,
      'X-App-Version': info.appVersion,
      'X-App-Build': info.appBuild,
      'X-Device-Model': info.model,
      'X-Platform': info.platform,
      'X-OS-Version': info.osVersion,
      'X-Timezone': info.timezone,
      'X-Locale': info.locale,
    };
  }

  private _parseError(response: TransportResponse): MizuError {
    try {
      const json = JSON.parse(response.body);
      return MizuError.api(APIError.fromJson(json));
    } catch {
      return MizuError.http(response.statusCode, response.body);
    }
  }
}
