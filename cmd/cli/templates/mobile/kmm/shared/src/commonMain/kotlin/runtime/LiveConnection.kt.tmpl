package {{.Package}}.runtime

import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.http.*
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Server-sent event
 */
@Serializable
data class ServerEvent(
    val id: String? = null,
    val event: String? = null,
    val data: String,
    val retry: Int? = null
)

/**
 * Decodes event data as JSON
 */
inline fun <reified T> ServerEvent.decode(json: Json = Json): T {
    return json.decodeFromString(data)
}

/**
 * Live connection manager for SSE
 */
class LiveConnection(
    private val runtime: MizuRuntime
) {
    private val activeConnections = mutableMapOf<String, Job>()

    /**
     * Connects to an SSE endpoint and returns a flow of events
     */
    fun connect(
        path: String,
        headers: Map<String, String>? = null
    ): Flow<ServerEvent> = flow {
        val url = runtime.buildUrl(path, null)

        try {
            val response = runtime.client.request(url) {
                method = HttpMethod.Get
                header(HttpHeaders.Accept, "text/event-stream")
                header(HttpHeaders.CacheControl, "no-cache")

                // Add default headers
                runtime.defaultHeaders.forEach { (key, value) ->
                    header(key, value)
                }

                // Add custom headers
                headers?.forEach { (key, value) ->
                    header(key, value)
                }

                // Add auth token
                runtime.tokenStore.getToken()?.let { token ->
                    header("Authorization", "Bearer ${token.accessToken}")
                }
            }

            if (response.status.value >= 400) {
                throw MizuError.Http(response.status.value, "SSE connection failed")
            }

            val text = response.bodyAsText()
            val events = parseSSE(text)
            events.forEach { emit(it) }
        } catch (e: CancellationException) {
            throw e
        } catch (e: MizuError) {
            throw e
        } catch (e: Exception) {
            throw MizuError.Network("SSE connection failed: ${e.message}", e)
        }
    }

    private fun parseSSE(text: String): List<ServerEvent> {
        val events = mutableListOf<ServerEvent>()
        val lines = text.split("\n")

        var id: String? = null
        var event: String? = null
        val data = mutableListOf<String>()
        var retry: Int? = null

        for (line in lines) {
            when {
                line.isEmpty() -> {
                    if (data.isNotEmpty()) {
                        events.add(ServerEvent(
                            id = id,
                            event = event,
                            data = data.joinToString("\n"),
                            retry = retry
                        ))
                        event = null
                        data.clear()
                        retry = null
                    }
                }
                line.startsWith(":") -> {
                    // Comment, ignore
                }
                line.startsWith("id:") -> {
                    id = line.removePrefix("id:").trim()
                }
                line.startsWith("event:") -> {
                    event = line.removePrefix("event:").trim()
                }
                line.startsWith("data:") -> {
                    data.add(line.removePrefix("data:").trim())
                }
                line.startsWith("retry:") -> {
                    retry = line.removePrefix("retry:").trim().toIntOrNull()
                }
            }
        }

        // Handle last event if present
        if (data.isNotEmpty()) {
            events.add(ServerEvent(
                id = id,
                event = event,
                data = data.joinToString("\n"),
                retry = retry
            ))
        }

        return events
    }

    /** Disconnects from a specific path */
    fun disconnect(path: String) {
        activeConnections[path]?.cancel()
        activeConnections.remove(path)
    }

    /** Disconnects all active connections */
    fun disconnectAll() {
        activeConnections.values.forEach { it.cancel() }
        activeConnections.clear()
    }
}
