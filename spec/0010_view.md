# View Package Specification

**Package**: `view`
**Status**: Draft
**Version**: 1.0

## Overview

The `view` package provides a standardized view/template system for Mizu with predictable structure, composition patterns, and production-ready features. It builds on Go's `html/template` package and adds:

- Clear conceptual model (Page, Layout, Component, Partial)
- Convention-based directory structure
- Layout templates with named slots
- Slot and stack mechanisms for composition
- Reusable components with structured input
- Deterministic template name resolution
- Unified asset referencing
- Development-time reload and error display
- Production-safe rendering with embed and caching

## Concepts

### Page

A **Page** is the top-level template rendered for a request. Each page:
- Has a unique name derived from its file path
- May specify a layout (default: `default`)
- Defines content for layout slots
- Can include components and partials

```
views/pages/home.html         → page name: "home"
views/pages/users/list.html   → page name: "users/list"
views/pages/users/show.html   → page name: "users/show"
```

### Layout

A **Layout** is a wrapper template that provides common structure (HTML skeleton, navigation, footer). Layouts:
- Define named slots where page content is inserted
- Can define default content for slots
- Are stored in `views/layouts/`

```html
<!-- views/layouts/default.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{slot "title" "Default Title"}}</title>
    {{slot "head"}}
</head>
<body>
    {{slot "content"}}
</body>
</html>
```

### Component

A **Component** is a reusable template unit with:
- Isolated scope (receives explicit data, no implicit access to page data)
- Optional structured input via Go struct
- Composable with other components

```html
<!-- views/components/button.html -->
<button class="btn btn-{{.Variant}}">{{.Label}}</button>
```

```html
<!-- Usage in page -->
{{component "button" (dict "Variant" "primary" "Label" "Submit")}}
```

### Partial

A **Partial** is a simple template fragment that:
- Shares the current template's data scope
- Used for breaking up large templates
- No special data isolation

```html
<!-- views/partials/sidebar.html -->
<aside class="sidebar">
    <nav>{{.NavItems}}</nav>
</aside>
```

```html
<!-- Usage in page -->
{{partial "sidebar"}}
```

## Directory Structure

```
views/
├── layouts/
│   ├── default.html      # Default layout
│   ├── admin.html        # Admin panel layout
│   └── bare.html         # No-chrome layout
├── pages/
│   ├── home.html
│   ├── about.html
│   └── users/
│       ├── list.html
│       └── show.html
├── components/
│   ├── button.html
│   ├── card.html
│   └── forms/
│       ├── input.html
│       └── select.html
├── partials/
│   ├── header.html
│   ├── footer.html
│   └── sidebar.html
└── assets/               # Optional: static assets
    ├── css/
    ├── js/
    └── images/
```

## Template Name Resolution

Names are resolved deterministically based on type and path:

| Type | Directory | Name Format | Example |
|------|-----------|-------------|---------|
| Page | `pages/` | path without extension | `"users/list"` |
| Layout | `layouts/` | filename without extension | `"default"` |
| Component | `components/` | path without extension | `"forms/input"` |
| Partial | `partials/` | path without extension | `"sidebar"` |

Resolution order for ambiguous names:
1. Exact match in specified directory
2. Error if not found (no fallbacks)

## Slot System

Slots provide content injection points in layouts.

### Defining Slots (in layouts)

```html
<!-- Simple slot with no default -->
{{slot "content"}}

<!-- Slot with default content -->
{{slot "title" "Default Title"}}

<!-- Slot with block default -->
{{slot "sidebar"}}
    <p>Default sidebar content</p>
{{end}}
```

### Filling Slots (in pages)

```html
{{define "title"}}User Profile{{end}}

{{define "content"}}
    <h1>Welcome, {{.User.Name}}</h1>
{{end}}

{{define "sidebar"}}
    {{component "user-nav" .User}}
{{end}}
```

### Stack System

Stacks allow multiple templates to append content to the same slot. Useful for CSS/JS that components need.

```html
<!-- In layout -->
<head>
    {{stack "styles"}}
</head>
<body>
    {{slot "content"}}
    {{stack "scripts"}}
</body>

<!-- In page or component -->
{{push "styles"}}
    <link rel="stylesheet" href="/css/datepicker.css">
{{end}}

{{push "scripts"}}
    <script src="/js/datepicker.js"></script>
{{end}}
```

Stack content is:
- Collected from all templates (page, components, partials)
- Rendered in order of first occurrence
- Deduplicated by exact content match (optional)

## Component System

### Component Definition

```html
<!-- views/components/alert.html -->
{{/*
    Props:
    - Type: string (success|warning|error|info)
    - Message: string
    - Dismissible: bool
*/}}
<div class="alert alert-{{.Type}}" role="alert">
    {{.Message}}
    {{if .Dismissible}}
        <button type="button" class="close">&times;</button>
    {{end}}
</div>
```

### Component Usage

```html
<!-- Pass struct or map -->
{{component "alert" .Alert}}

<!-- Inline props with dict helper -->
{{component "alert" (dict "Type" "success" "Message" "Saved!" "Dismissible" true)}}

<!-- Component with children (nested content) -->
{{component "card"}}
    <p>Card body content here</p>
{{end}}
```

### Children Content

Components can receive nested content via `{{children}}`:

```html
<!-- views/components/card.html -->
<div class="card">
    <div class="card-header">{{.Title}}</div>
    <div class="card-body">
        {{children}}
    </div>
</div>

<!-- Usage -->
{{component "card" (dict "Title" "My Card")}}
    <p>This is the card body.</p>
    <button>Click me</button>
{{end}}
```

## Template Functions

### Built-in Functions

```go
// Standard html/template functions plus:

// Slot/Stack
slot(name string, defaultContent ...any) template.HTML
stack(name string) template.HTML
push(name string) // Used with {{end}}

// Components/Partials
component(name string, data ...any) template.HTML
partial(name string) template.HTML
children() template.HTML

// Data Helpers
dict(pairs ...any) map[string]any
list(items ...any) []any
default(defaultVal, val any) any
empty(val any) bool

// Asset Helpers
asset(path string) string        // Returns versioned asset URL
assetInline(path string) string  // Returns asset content inline

// Safe Content
safeHTML(s string) template.HTML
safeCSS(s string) template.CSS
safeJS(s string) template.JS
safeURL(s string) template.URL

// String Helpers
upper(s string) string
lower(s string) string
title(s string) string
trim(s string) string
contains(s, substr string) bool
replace(s, old, new string) string
split(s, sep string) []string
join(sep string, items []string) string

// Conditionals
ternary(cond bool, trueVal, falseVal any) any
coalesce(vals ...any) any
```

### Custom Functions

```go
engine := view.New(view.Options{
    Funcs: template.FuncMap{
        "formatDate": func(t time.Time) string {
            return t.Format("Jan 02, 2006")
        },
        "currency": func(cents int) string {
            return fmt.Sprintf("$%.2f", float64(cents)/100)
        },
    },
})
```

## Page Data Structure

Each page receives structured data:

```go
type PageData struct {
    // Page metadata
    Page PageMeta

    // Request context (from Ctx)
    Request RequestData

    // User-provided data
    Data any

    // Flash messages
    Flash FlashData

    // CSRF token (if middleware enabled)
    CSRF string
}

type PageMeta struct {
    Name   string // Page name (e.g., "users/show")
    Title  string // Page title
    Layout string // Layout name
}

type RequestData struct {
    Path   string
    Method string
    Query  url.Values
    Params map[string]string
}

type FlashData struct {
    Success []string
    Error   []string
    Warning []string
    Info    []string
}
```

Template usage:
```html
<title>{{.Page.Title}}</title>
<h1>Welcome to {{.Page.Name}}</h1>

{{range .Flash.Success}}
    {{component "alert" (dict "Type" "success" "Message" .)}}
{{end}}

<form method="POST">
    <input type="hidden" name="_csrf" value="{{.CSRF}}">
    {{/* User data */}}
    <input name="email" value="{{.Data.User.Email}}">
</form>
```

## Engine Configuration

```go
type Options struct {
    // Dir is the views directory path.
    // Default: "views"
    Dir string

    // FS is an optional filesystem (for embed.FS in production).
    // If nil, uses os filesystem with Dir.
    FS fs.FS

    // Extension is the template file extension.
    // Default: ".html"
    Extension string

    // DefaultLayout is the layout used when page doesn't specify one.
    // Default: "default"
    DefaultLayout string

    // Funcs adds custom template functions.
    Funcs template.FuncMap

    // Delims sets custom template delimiters.
    // Default: "{{", "}}"
    Delims [2]string

    // Development enables dev mode features:
    // - Template reload on every request
    // - Detailed error pages with source context
    // - No caching
    // Default: false
    Development bool

    // ErrorTemplate is the template for rendering errors.
    // If empty, uses default error template.
    ErrorTemplate string

    // StrictMode fails on missing slots/components instead of empty output.
    // Default: false (production-friendly)
    StrictMode bool

    // DedupeStacks removes duplicate stack entries.
    // Default: true
    DedupeStacks bool

    // AssetManifest is path to asset manifest for versioned URLs.
    // Default: "" (no versioning)
    AssetManifest string
}
```

## Integration with Mizu

### Engine Creation

```go
// Development
engine := view.New(view.Options{
    Dir:         "views",
    Development: true,
})

// Production with embedded templates
//go:embed views
var viewsFS embed.FS

engine := view.New(view.Options{
    FS: viewsFS,
})
```

### Middleware Setup

```go
app := mizu.New()

// Add view engine to app
app.Use(view.Middleware(engine))
```

### Rendering in Handlers

```go
func homeHandler(c *mizu.Ctx) error {
    return view.Render(c, "home", view.Data{
        "Title": "Welcome",
        "User":  currentUser,
    })
}

// With explicit status code
func notFoundHandler(c *mizu.Ctx) error {
    return view.Render(c, "errors/404", nil, view.Status(404))
}

// With layout override
func printHandler(c *mizu.Ctx) error {
    return view.Render(c, "invoice", data, view.Layout("print"))
}

// Render component directly (for HTMX/AJAX)
func userCardHandler(c *mizu.Ctx) error {
    return view.RenderComponent(c, "user-card", user)
}
```

### Convenience via Ctx Extension

```go
// If using the middleware, Ctx gets extended:
func handler(c *mizu.Ctx) error {
    return c.Render("home", data)
}
```

## Error Handling

### Development Mode

In development, render errors show:
- Error message and type
- Template name and line number
- Source code context with highlighted error line
- Stack trace

```html
<!-- Auto-generated error page -->
<h1>Template Error</h1>
<pre>
Error: undefined variable "User" in template "users/show.html" at line 15

    13 |     <div class="profile">
    14 |         <h1>User Profile</h1>
 >> 15 |         <p>Name: {{.User.Name}}</p>
    16 |         <p>Email: {{.User.Email}}</p>
    17 |     </div>
</pre>
```

### Production Mode

In production:
- Errors return `error` to handler (logged, not displayed)
- Missing templates return specific error type
- Template panics are recovered

```go
func handler(c *mizu.Ctx) error {
    err := view.Render(c, "page", data)
    if err != nil {
        if errors.Is(err, view.ErrTemplateNotFound) {
            return c.Status(404).Text("Page not found")
        }
        // Log error, show generic error page
        return view.Render(c, "errors/500", nil)
    }
    return nil
}
```

## Caching Strategy

### Development Mode
- No caching
- Templates parsed on every request
- Immediate reflection of file changes

### Production Mode
- All templates parsed once at startup
- Compiled templates cached in memory
- Zero disk access after initialization
- Thread-safe concurrent rendering

```go
// Force cache rebuild (useful for tests)
engine.ClearCache()

// Warm cache explicitly
if err := engine.Preload(); err != nil {
    log.Fatal("template error:", err)
}
```

## Asset Handling

### Asset Manifest

For cache-busting in production, use an asset manifest:

```json
// assets/manifest.json
{
    "css/app.css": "css/app.abc123.css",
    "js/app.js": "js/app.def456.js"
}
```

```html
<link rel="stylesheet" href="{{asset "css/app.css"}}">
<!-- Output: /assets/css/app.abc123.css -->
```

### Inline Assets

For critical CSS/JS:

```html
<style>{{assetInline "css/critical.css"}}</style>
```

## Complete Example

### Directory Structure
```
views/
├── layouts/
│   └── default.html
├── pages/
│   └── users/
│       └── show.html
├── components/
│   ├── avatar.html
│   └── button.html
└── partials/
    └── nav.html
```

### Layout
```html
<!-- views/layouts/default.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{slot "title" "My App"}}</title>
    {{stack "styles"}}
</head>
<body>
    {{partial "nav"}}
    <main>
        {{slot "content"}}
    </main>
    {{stack "scripts"}}
</body>
</html>
```

### Page
```html
<!-- views/pages/users/show.html -->
{{define "layout"}}default{{end}}

{{define "title"}}{{.Data.User.Name}} - Profile{{end}}

{{define "content"}}
<div class="profile">
    {{component "avatar" .Data.User}}
    <h1>{{.Data.User.Name}}</h1>
    <p>{{.Data.User.Bio}}</p>

    {{component "button" (dict "Label" "Edit Profile" "Variant" "primary")}}
</div>
{{end}}

{{push "styles"}}
<link rel="stylesheet" href="{{asset "css/profile.css"}}">
{{end}}
```

### Component
```html
<!-- views/components/avatar.html -->
<div class="avatar avatar-{{default "md" .Size}}">
    {{if .URL}}
        <img src="{{.URL}}" alt="{{.Name}}">
    {{else}}
        <span class="initials">{{slice .Name 0 1}}</span>
    {{end}}
</div>
```

### Handler
```go
func ShowUser(c *mizu.Ctx) error {
    user, err := users.Find(c.Param("id"))
    if err != nil {
        return err
    }

    return view.Render(c, "users/show", view.Data{
        "User": user,
    })
}
```

## API Summary

### Types

```go
type Engine struct { ... }
type Options struct { ... }
type Data map[string]any
type RenderOption func(*renderConfig)

// Errors
var ErrTemplateNotFound = errors.New("template not found")
var ErrLayoutNotFound = errors.New("layout not found")
var ErrComponentNotFound = errors.New("component not found")
var ErrSlotNotDefined = errors.New("slot not defined")
```

### Functions

```go
// Engine
func New(opts Options) *Engine
func (e *Engine) Render(w io.Writer, name string, data any, opts ...RenderOption) error
func (e *Engine) RenderComponent(w io.Writer, name string, data any) error
func (e *Engine) Preload() error
func (e *Engine) ClearCache()

// Middleware
func Middleware(e *Engine) mizu.Middleware

// Handler helpers
func Render(c *mizu.Ctx, name string, data any, opts ...RenderOption) error
func RenderComponent(c *mizu.Ctx, name string, data any) error

// Render options
func Status(code int) RenderOption
func Layout(name string) RenderOption
func NoLayout() RenderOption
```

## Implementation Notes

1. **Template Parsing**: Use `template.New().Parse()` with cloning for inheritance
2. **Slot Implementation**: Use `template.Execute` with nested data context
3. **Stack Collection**: Accumulate during render pass, output at stack call
4. **Caching**: Use `sync.Map` or RWMutex-protected map for compiled templates
5. **Dev Reload**: Check file mtime, reparse if changed
6. **Error Context**: Wrap template errors with file/line info using regex on error messages
