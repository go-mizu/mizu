# Live Package Specification

**Package**: `view/live`
**Status**: Draft
**Version**: 1.0

## Overview

The `view/live` package provides real-time, stateful, server-rendered pages for Mizu applications. Inspired by Phoenix LiveView, it enables rich interactive experiences without writing client-side JavaScript, while maintaining Go's type safety and simplicity.

Key principles:
- **Server-authoritative state**: All state lives on the server; clients receive rendered HTML patches
- **Sequential event processing**: Events are processed one at a time per session, eliminating data races
- **Progressive enhancement**: Pages work without JavaScript, upgrading to WebSocket when available
- **Type-safe sessions**: Generic `Session[T]` keeps state strongly typed
- **Minimal client runtime**: Small JavaScript library (~5KB) handles events and DOM patching

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         HTTP Request                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Initial Page Render                        │
│                    (Full HTML via view.Engine)                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Client Runtime Loads                         │
│                   (live.js connects WebSocket)                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Session Established                         │
│              (Server creates Session[T], calls Mount)           │
└─────────────────────────────────────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
┌──────────────────────────┐    ┌──────────────────────────┐
│     Client Events        │    │    Server Messages       │
│  (click, submit, change) │    │   (pubsub, timers)       │
└──────────────────────────┘    └──────────────────────────┘
              │                               │
              └───────────────┬───────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Event Processing                            │
│           (Handle/Info mutates state, marks dirty)              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Patch Generation                           │
│              (Re-render dirty regions, diff, send)              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       DOM Patching                              │
│                (Client applies morphdom patches)                │
└─────────────────────────────────────────────────────────────────┘
```

## Package Structure

```
view/live/
├── live.go          # Public API: New, Options, Live struct
├── page.go          # Page[T] interface definition
├── session.go       # Session[T], session store, lifecycle
├── ctx.go           # Live context (wraps mizu.Ctx)
├── event.go         # Event decoding and types
├── patch.go         # Patch encoding and generation
├── render.go        # Region rendering and diffing
├── ws.go            # WebSocket transport
├── pubsub.go        # PubSub interface and in-memory implementation
├── runtime.go       # Embedded client runtime
├── runtime.js       # Client-side JavaScript runtime
└── runtime.min.js   # Minified runtime for production
```

## Core Types

### Page Interface

The `Page[T]` interface defines a live page. Developers implement this interface with their state type.

```go
// Page defines a live page with typed state.
type Page[T any] interface {
    // Mount initializes the session state when the live connection is established.
    // Called once per session after WebSocket connects.
    Mount(ctx *Ctx, s *Session[T]) error

    // Render returns the view configuration for rendering.
    // Called after Mount and after each state change.
    Render(ctx *Ctx, s *Session[T]) (View, error)

    // Handle processes client-originated events (clicks, form submits, etc.).
    // Must be idempotent - may be retried on connection issues.
    Handle(ctx *Ctx, s *Session[T], e Event) error

    // Info processes server-originated messages (pubsub, timers).
    Info(ctx *Ctx, s *Session[T], msg any) error
}
```

### View Configuration

```go
// View specifies what to render.
type View struct {
    // Page is the main page template name (e.g., "counter/index").
    Page string

    // Regions maps region IDs to partial template names.
    // Only dirty regions are re-rendered on updates.
    Regions map[string]string

    // Layout overrides the default layout.
    // Empty string uses page's layout or engine default.
    Layout string
}
```

### Session

```go
// Session holds the state for a live connection.
type Session[T any] struct {
    // ID is the unique session identifier.
    ID string

    // State is the user-defined typed state.
    State T

    // Flash provides flash message support.
    Flash Flash

    // UserID is set from auth middleware (optional).
    UserID string

    // Internal fields
    dirty    DirtySet
    regions  map[string]string // region ID -> last rendered HTML
    created  time.Time
    lastSeen time.Time
}

// Mark marks regions as dirty, triggering re-render.
func (s *Session[T]) Mark(ids ...string)

// MarkAll marks all regions as dirty.
func (s *Session[T]) MarkAll()

// ReplaceState replaces the entire state and marks all regions dirty.
func (s *Session[T]) ReplaceState(next T)

// IsDirty checks if any regions are marked dirty.
func (s *Session[T]) IsDirty() bool

// Push sends a client-side command (e.g., focus, scroll, redirect).
func (s *Session[T]) Push(cmd Command)
```

### DirtySet

```go
// DirtySet tracks which regions need re-rendering.
type DirtySet struct {
    all     bool
    regions map[string]struct{}
}

func (d *DirtySet) Add(id string)
func (d *DirtySet) AddAll()
func (d *DirtySet) Has(id string) bool
func (d *DirtySet) Clear()
func (d *DirtySet) IsEmpty() bool
func (d *DirtySet) List() []string
```

### Event

```go
// Event represents a client-originated event.
type Event struct {
    // Name is the event name (e.g., "click", "submit", "inc").
    Name string

    // Target is the optional component ID (from data-lv-target).
    Target string

    // Values contains data-lv-value-* attributes.
    Values map[string]string

    // Form contains form field values (for submit events).
    Form url.Values

    // Key is the keyboard key (for keydown/keyup events).
    Key string

    // Meta contains event metadata (shiftKey, ctrlKey, etc.).
    Meta EventMeta
}

// EventMeta contains keyboard/mouse modifier state.
type EventMeta struct {
    ShiftKey bool
    CtrlKey  bool
    AltKey   bool
    MetaKey  bool
}

// Get retrieves a value from Values, then Form.
func (e Event) Get(key string) string

// GetInt retrieves an integer value.
func (e Event) GetInt(key string) int

// GetBool retrieves a boolean value.
func (e Event) GetBool(key string) bool
```

### Context

```go
// Ctx is the live page context.
type Ctx struct {
    // Embeds mizu.Ctx for request access
    *mizu.Ctx

    // Session ID
    SessionID string
}

// Subscribe subscribes the session to a pubsub topic.
func (c *Ctx) Subscribe(topics ...string) error

// Unsubscribe removes subscriptions.
func (c *Ctx) Unsubscribe(topics ...string) error

// SendInfo sends a message to this session's Info handler.
func (c *Ctx) SendInfo(msg any) error

// SendAfter sends a message after a delay.
func (c *Ctx) SendAfter(msg any, delay time.Duration) *Timer

// Connected returns true if the WebSocket is connected.
func (c *Ctx) Connected() bool
```

### Commands

```go
// Command is a client-side action.
type Command interface {
    commandType() string
}

// Redirect navigates the browser to a new URL.
type Redirect struct {
    To      string
    Replace bool // Replace history entry instead of push
}

// Focus sets focus to an element.
type Focus struct {
    Selector string
}

// Scroll scrolls to an element or position.
type Scroll struct {
    Selector string // If empty, scrolls to top
    Block    string // "start", "center", "end", "nearest"
}

// Download triggers a file download.
type Download struct {
    URL      string
    Filename string
}

// JS executes arbitrary JavaScript.
type JS struct {
    Code string
    Args map[string]any
}
```

## Live Engine

### Options

```go
// Options configures the live engine.
type Options struct {
    // View is the view engine for template rendering.
    View *view.Engine

    // PubSub is the message broker for server-push.
    // Default: NewInmemPubSub()
    PubSub PubSub

    // SessionStore persists sessions across restarts.
    // Default: in-memory store
    SessionStore SessionStore

    // Dev enables development mode features.
    Dev bool

    // SessionTimeout is how long idle sessions are kept.
    // Default: 30 minutes
    SessionTimeout time.Duration

    // HeartbeatInterval is the WebSocket ping interval.
    // Default: 30 seconds
    HeartbeatInterval time.Duration

    // MaxMessageSize is the maximum WebSocket message size.
    // Default: 64KB
    MaxMessageSize int64

    // CSRF configures CSRF protection.
    CSRF CSRFConfig

    // OnError is called when an error occurs.
    OnError func(ctx *Ctx, err error)

    // OnSessionStart is called when a new session starts.
    OnSessionStart func(ctx *Ctx, sessionID string)

    // OnSessionEnd is called when a session ends.
    OnSessionEnd func(sessionID string)
}

// CSRFConfig configures CSRF protection.
type CSRFConfig struct {
    // Enabled turns on CSRF validation.
    // Default: true
    Enabled bool

    // TokenFunc extracts the CSRF token from a request.
    // Default: reads from _csrf form field or X-CSRF-Token header
    TokenFunc func(c *mizu.Ctx) string
}
```

### Live Engine API

```go
// Live is the live view engine.
type Live struct {
    opts   Options
    pubsub PubSub
    store  SessionStore
}

// New creates a new live engine.
func New(opts Options) *Live

// Mount registers live routes on the Mizu app.
// Registers:
//   - GET /_live/runtime.js - Client runtime
//   - WS  /_live/websocket  - WebSocket endpoint
func (l *Live) Mount(app *mizu.App)

// Page creates a handler for a live page.
// The page handler serves the initial HTML and handles the live session.
func (l *Live) Page[T any](path string, page Page[T]) mizu.Handler

// PubSub returns the pubsub instance for publishing messages.
func (l *Live) PubSub() PubSub
```

## PubSub System

### Interface

```go
// PubSub enables server-to-client messaging.
type PubSub interface {
    // Subscribe adds a session to topics.
    Subscribe(sessionID string, topics ...string) error

    // Unsubscribe removes a session from topics.
    Unsubscribe(sessionID string, topics ...string) error

    // Publish sends a message to all subscribers of a topic.
    Publish(topic string, msg any) error

    // Broadcast sends a message to all sessions.
    Broadcast(msg any) error
}

// InmemPubSub is an in-memory pubsub implementation.
type InmemPubSub struct {
    // ...
}

func NewInmemPubSub() *InmemPubSub
```

### Usage Pattern

```go
// In Mount: subscribe to topics
func (p *ChatPage) Mount(ctx *live.Ctx, s *live.Session[ChatState]) error {
    s.State.Room = ctx.Param("room")
    ctx.Subscribe("room:" + s.State.Room)
    return nil
}

// In Info: handle published messages
func (p *ChatPage) Info(ctx *live.Ctx, s *live.Session[ChatState], msg any) error {
    switch m := msg.(type) {
    case NewMessage:
        s.State.Messages = append(s.State.Messages, m)
        s.Mark("messages")
    case UserJoined:
        s.State.Users = append(s.State.Users, m.User)
        s.Mark("users")
    }
    return nil
}

// From anywhere in your app: publish
lv.PubSub().Publish("room:general", NewMessage{
    From: "alice",
    Text: "Hello!",
})
```

## Session Store

```go
// SessionStore persists session data.
type SessionStore interface {
    // Get retrieves a session by ID.
    Get(id string) ([]byte, error)

    // Set stores a session.
    Set(id string, data []byte, ttl time.Duration) error

    // Delete removes a session.
    Delete(id string) error

    // Touch updates the session's last-seen time.
    Touch(id string, ttl time.Duration) error
}

// MemoryStore is the default in-memory session store.
type MemoryStore struct {
    // ...
}

func NewMemoryStore() *MemoryStore
```

## Lifecycle

### Initial Request

1. HTTP GET request arrives at live page route
2. `Page[T]` is instantiated (zero value or provided instance)
3. Static render with empty/initial state produces full HTML
4. HTML includes `<script src="/_live/runtime.js">` and session token
5. Response sent to client

### WebSocket Connection

1. Client runtime loads, connects to `/_live/websocket`
2. Server validates CSRF token and creates `Session[T]`
3. `Mount()` is called to initialize state
4. `Render()` is called to get view configuration
5. Server sends initial rendered regions
6. Session enters event loop

### Event Loop

```
for {
    select {
    case event := <-clientEvents:
        Handle(ctx, session, event)
        if session.IsDirty() {
            patches := renderDirtyRegions(session)
            send(patches)
            session.dirty.Clear()
        }

    case msg := <-serverMessages:
        Info(ctx, session, msg)
        if session.IsDirty() {
            patches := renderDirtyRegions(session)
            send(patches)
            session.dirty.Clear()
        }

    case <-heartbeat:
        send(ping)

    case <-timeout:
        cleanup(session)
        return
    }
}
```

### Cleanup

1. WebSocket disconnects (client navigates away, network error, etc.)
2. Session marked for cleanup after grace period
3. `OnSessionEnd` callback fired
4. Session removed from store
5. Subscriptions removed from pubsub

## Error Handling

```go
// Recoverable errors
type RecoverableError struct {
    Err     error
    Message string // Shown to user
}

// In Handle:
func (p *MyPage) Handle(ctx *live.Ctx, s *live.Session[State], e live.Event) error {
    if err := validate(e); err != nil {
        s.State.Error = err.Error()
        s.Mark("error")
        return nil // Not an error, just state update
    }

    if err := save(e); err != nil {
        // Return error to trigger OnError callback
        return fmt.Errorf("save failed: %w", err)
    }

    return nil
}
```

Error behaviors:
- `nil` return: Success, patches sent if dirty
- `RecoverableError`: Flash error to user, session continues
- Other errors: `OnError` callback, connection may close
- Panics: Recovered, logged, connection closed

## Security

### CSRF Protection

- Initial page render includes CSRF token
- WebSocket connection must include valid token
- Token validated before session creation
- Token rotation on authentication changes

### Session Security

- Session IDs are cryptographically random (128 bits)
- Session data never sent to client (only rendered HTML)
- Session timeout prevents abandoned sessions
- Rate limiting on event processing

### Input Validation

- All event values are strings (never trust types)
- Form data uses standard Go url.Values
- Size limits on message payloads
- Sanitize user input in templates (Go templates auto-escape)

## Integration with Mizu

### Full Example

```go
package main

import (
    "github.com/mizu-framework/mizu"
    "github.com/mizu-framework/mizu/view"
    "github.com/mizu-framework/mizu/view/live"
)

//go:embed views
var viewsFS embed.FS

func main() {
    // Create view engine
    eng := view.Must(view.New(view.Options{
        FS: viewsFS,
    }))

    // Create live engine
    lv := live.New(live.Options{
        View:   eng,
        PubSub: live.NewInmemPubSub(),
        Dev:    os.Getenv("DEV") == "true",
    })

    // Create app
    app := mizu.New()

    // Mount live infrastructure
    lv.Mount(app)

    // Mount live pages
    app.GET("/counter", lv.Page("/counter", &CounterPage{}))
    app.GET("/chat/{room}", lv.Page("/chat/{room}", &ChatPage{}))

    // Run server
    app.Run(":3000")
}
```

### With Auth Middleware

```go
// Auth middleware sets user on context
app.Use(auth.Middleware(auth.Options{
    // ...
}))

// Live pages can access user
func (p *DashboardPage) Mount(ctx *live.Ctx, s *live.Session[State]) error {
    user := auth.User(ctx.Ctx) // From auth middleware
    if user == nil {
        return live.Redirect{To: "/login"}
    }
    s.UserID = user.ID
    s.State.User = user
    return nil
}
```

## Flash Messages

```go
// Flash provides flash message support.
type Flash struct {
    Success []string
    Error   []string
    Warning []string
    Info    []string
}

func (f *Flash) AddSuccess(msg string)
func (f *Flash) AddError(msg string)
func (f *Flash) AddWarning(msg string)
func (f *Flash) AddInfo(msg string)
func (f *Flash) Clear()

// In Handle:
func (p *MyPage) Handle(ctx *live.Ctx, s *live.Session[State], e live.Event) error {
    if err := save(e); err != nil {
        s.Flash.AddError("Failed to save")
    } else {
        s.Flash.AddSuccess("Saved successfully!")
    }
    s.Mark("flash")
    return nil
}
```

## Timers

```go
// Timer represents a scheduled message.
type Timer struct {
    id     string
    cancel func()
}

func (t *Timer) Cancel()

// Schedule a message
timer := ctx.SendAfter(RefreshData{}, 5*time.Second)

// Cancel if needed
timer.Cancel()

// Recurring timer pattern in Mount:
func (p *DashboardPage) Mount(ctx *live.Ctx, s *live.Session[State]) error {
    ctx.SendAfter(Tick{}, time.Second) // Start ticker
    return nil
}

func (p *DashboardPage) Info(ctx *live.Ctx, s *live.Session[State], msg any) error {
    if _, ok := msg.(Tick); ok {
        s.State.Time = time.Now()
        s.Mark("clock")
        ctx.SendAfter(Tick{}, time.Second) // Schedule next tick
    }
    return nil
}
```

## API Summary

### Types

```go
// Core types
type Live struct { ... }
type Options struct { ... }
type Page[T any] interface { ... }
type Session[T any] struct { ... }
type Ctx struct { ... }
type View struct { ... }
type Event struct { ... }
type Flash struct { ... }
type DirtySet struct { ... }

// Commands
type Redirect struct { ... }
type Focus struct { ... }
type Scroll struct { ... }
type Download struct { ... }
type JS struct { ... }

// PubSub
type PubSub interface { ... }
type InmemPubSub struct { ... }

// Session storage
type SessionStore interface { ... }
type MemoryStore struct { ... }

// Errors
var ErrSessionNotFound = errors.New("session not found")
var ErrSessionExpired = errors.New("session expired")
var ErrInvalidCSRF = errors.New("invalid CSRF token")
```

### Functions

```go
// Engine
func New(opts Options) *Live
func (l *Live) Mount(app *mizu.App)
func (l *Live) Page[T any](path string, page Page[T]) mizu.Handler
func (l *Live) PubSub() PubSub

// PubSub
func NewInmemPubSub() *InmemPubSub

// Session store
func NewMemoryStore() *MemoryStore
```

## Implementation Notes

1. **WebSocket Library**: Use `nhooyr.io/websocket` for WebSocket support (better than gorilla/websocket for modern Go)

2. **DOM Diffing**: Use morphdom-style diffing on the client. Server sends HTML strings, client morphs DOM.

3. **Serialization**: Use msgpack for wire protocol (smaller than JSON, faster to parse)

4. **Session Storage**: Store session as gob-encoded bytes. Support external stores (Redis, etc.) via interface.

5. **Connection Recovery**: Client automatically reconnects on disconnect. Server can restore session from store.

6. **Memory Management**: Use sync.Pool for buffers during rendering. Limit concurrent sessions per server.

7. **Testing**: Provide `live.TestClient` for testing live pages without WebSocket connection.

8. **Metrics**: Expose session count, event rate, render time via standard Go metrics.
