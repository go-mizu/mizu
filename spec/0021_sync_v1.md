Below is a **clean re-write of the `sync` package proposal**, aligned with **Go core library naming conventions** and Go idioms.
The intent is clarity, minimalism, and long-term stability, not framework flavor.

---

# Sync Package Proposal

## Purpose

Package `sync` provides **authoritative, offline-first state synchronization** for Mizu.

It defines a durable mutation pipeline, an ordered change log, and cursor-based replication so clients can converge to correct state across retries, disconnects, offline operation, and server restarts.

The package is **transport-agnostic**. HTTP is the default transport, but correctness does not depend on realtime delivery. Realtime systems such as `live` may accelerate convergence but are optional.

---

## Design principles

1. **Authoritative**
   All durable state changes are applied on the server through the sync engine.

2. **Offline-first**
   Clients may enqueue and replay mutations safely.

3. **Idempotent**
   Replayed mutations must not apply twice.

4. **Pull-based convergence**
   Clients converge by pulling changes since a cursor.

5. **Scoped**
   All data and cursors are partitioned by scope.

6. **Minimal surface area**
   Few types, predictable behavior, explicit contracts.

---

## Package layout

```
sync/
  doc.go        // Package documentation
  engine.go     // Engine and Options
  types.go      // Mutation, Result, Change, errors
  store.go      // Store interface
  log.go        // Log interface
  mutator.go    // Mutator interface
  applied.go    // Applied (dedupe) interface
  notify.go     // Notifier interface
  http.go       // HTTP handlers (push, pull, snapshot)

  memory/
    store.go
    log.go
    applied.go
```

---

## Core types

### Mutation

A `Mutation` represents a client request to change state.
It is a **command**, not a state patch.

```go
type Mutation struct {
    // ID uniquely identifies this mutation for idempotency.
    ID string `json:"id"`

    // Name identifies the mutation type.
    Name string `json:"name"`

    // Scope identifies the data partition.
    Scope string `json:"scope,omitempty"`

    // Client identifies the originating client.
    Client string `json:"client,omitempty"`

    // Seq is a client-local sequence number.
    Seq uint64 `json:"seq,omitempty"`

    // Args contains mutation-specific arguments.
    Args map[string]any `json:"args,omitempty"`
}
```

Naming rationale:

* `ID` not `MutationID` (Go style)
* `Client` not `ClientID`
* `Seq` not `ClientSeq`
* Short, obvious field names

---

### Result

A `Result` describes the outcome of applying a mutation.

```go
type Result struct {
    OK     bool   `json:"ok"`
    Cursor uint64 `json:"cursor,omitempty"`
    Code   string `json:"code,omitempty"`
    Error  string `json:"error,omitempty"`
    Changes []Change `json:"changes,omitempty"`
}
```

Notes:

* `Code` is machine-readable
* `Error` is human-readable
* `Cursor` is the authoritative position after application

---

### Change

A `Change` is a single durable state change recorded in the log.

```go
type Change struct {
    Cursor uint64    `json:"cursor"`
    Scope  string    `json:"scope"`
    Entity string    `json:"entity"`
    ID     string    `json:"id"`
    Op     Op        `json:"op"`
    Data   []byte    `json:"data,omitempty"`
    Time   time.Time `json:"time"`
}
```

```go
type Op string

const (
    Create Op = "create"
    Update Op = "update"
    Delete Op = "delete"
)
```

Naming rationale:

* `Op` instead of `ChangeOp`
* `Time` instead of `Timestamp`
* JSON-native `[]byte` for storage neutrality

---

## Interfaces

### Store

`Store` is the authoritative state store.

```go
type Store interface {
    Get(ctx context.Context, scope, entity, id string) ([]byte, error)
    Set(ctx context.Context, scope, entity, id string, data []byte) error
    Delete(ctx context.Context, scope, entity, id string) error

    Snapshot(ctx context.Context, scope string) (map[string]map[string][]byte, error)
}
```

Notes:

* No `List`. Snapshot is the canonical full read.
* JSON bytes avoid type ambiguity.
* Scope is explicit.

---

### Log

`Log` records ordered changes and serves them by cursor.

```go
type Log interface {
    Append(ctx context.Context, scope string, changes []Change) (uint64, error)
    Since(ctx context.Context, scope string, cursor uint64, limit int) ([]Change, error)
    Cursor(ctx context.Context, scope string) (uint64, error)
    Trim(ctx context.Context, scope string, before uint64) error
}
```

Naming rationale:

* `Log` not `ChangeLog`
* Short verbs consistent with `io`, `os`, `net`

---

### Mutator

`Mutator` contains application business logic.

```go
type Mutator interface {
    Apply(ctx context.Context, store Store, m Mutation) ([]Change, error)
}
```

Helper:

```go
type MutatorFunc func(context.Context, Store, Mutation) ([]Change, error)

func (f MutatorFunc) Apply(ctx context.Context, s Store, m Mutation) ([]Change, error) {
    return f(ctx, s, m)
}
```

---

### Applied

`Applied` tracks mutations already processed.

```go
type Applied interface {
    Get(ctx context.Context, scope, key string) (Result, bool, error)
    Put(ctx context.Context, scope, key string, res Result) error
}
```

Notes:

* `key` is typically `mutation.ID`
* Enables strict idempotency

---

### Notifier

`Notifier` is an optional integration hook.

```go
type Notifier interface {
    Notify(scope string, cursor uint64)
}
```

Notes:

* No dependency on `live`
* Can be nil

---

## Engine

The `Engine` coordinates mutation application and replication.

```go
type Engine struct {
    store   Store
    log     Log
    apply   Applied
    mutator Mutator
    notify  Notifier
}
```

```go
type Options struct {
    Store   Store
    Log     Log
    Applied Applied
    Mutator Mutator
    Notify  Notifier
}
```

```go
func New(opts Options) *Engine
```

---

## Engine behavior

### Push

1. Authenticate request and derive scope
2. For each mutation:

   * Compute dedupe key
   * If already applied, return stored result
   * Call `Mutator.Apply`
   * Append changes to `Log`
   * Store `Result` in `Applied`
3. Call `Notify` with latest cursor
4. Return results

### Pull

1. Read changes since cursor
2. Return up to limit
3. Indicate whether more data exists
4. If cursor expired, return error code `cursor_too_old`

### Snapshot

1. Read current cursor
2. Read store snapshot
3. Return `{data, cursor}`
4. Client replaces local state for that scope

---

## HTTP transport (default)

Endpoints:

* `POST /_sync/push`
* `POST /_sync/pull`
* `POST /_sync/snapshot`

Transport is optional. The engine itself is transport-independent.

---

## What this proposal deliberately avoids

* Realtime fanout or WebSocket semantics
* View rendering or UI diffing
* CRDT semantics by default
* Distributed replication protocols
* Global state or unscoped cursors

---

## Why this matches Go core library style

* Short names (`Log`, `Op`, `Seq`)
* Interfaces describe behavior, not structure
* No builder patterns or WithX options
* Explicit error handling
* Small, composable pieces
* Clear ownership of correctness

---

## Summary

* `sync` is the **durable correctness layer**
* `live` is an **optional latency accelerator**
* The API is small, explicit, and driver-friendly
* SQL, memory, and future backends map naturally

If you want, next we can:

* Freeze this as a **v1 API contract**
* Produce **Postgres and SQLite schemas**
* Write `doc.go` exactly as it should appear in the repository
