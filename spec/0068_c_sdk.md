# RFC 0068: C SDK Generator

## Summary

Add C SDK code generation to the Mizu contract system, enabling production-ready, type-safe C clients for embedded systems, system programming, high-performance applications, and as a foundation for FFI bindings to other languages.

## Motivation

C remains the lingua franca of systems programming and is essential for:

1. **Embedded systems**: IoT devices, microcontrollers, and constrained environments
2. **High-performance computing**: HPC, scientific computing, and real-time systems
3. **System programming**: Operating systems, drivers, and low-level infrastructure
4. **FFI foundation**: C ABI is the universal interface for binding to other languages (Python, Ruby, Node.js, etc.)
5. **Legacy integration**: Interoperability with existing C/C++ codebases
6. **Cross-platform portability**: C compilers exist for virtually every platform

## Design Goals

### Developer Experience (DX)

- **Idiomatic C**: Follow C conventions (snake_case, explicit memory management, error codes)
- **Opaque handles**: Hide implementation details behind opaque pointers for encapsulation
- **Builder pattern**: Fluent API for constructing complex request objects
- **Clear ownership**: Explicit memory ownership with `_create`/`_destroy` naming conventions
- **Error handling**: Consistent error codes with human-readable error messages
- **Zero-copy where possible**: Minimize allocations and copies in hot paths
- **Single-header option**: Optionally generate a single amalgamated header for easy integration
- **Comprehensive documentation**: Doxygen-compatible documentation comments

### Production Readiness

- **Memory safety**: Null checks, bounds checking, and clear allocation/deallocation patterns
- **Thread safety**: Reentrant functions, thread-local storage where needed
- **Retry logic**: Configurable retry with exponential backoff
- **Timeout handling**: Per-request and global timeout configuration
- **Streaming support**: Callback-based SSE streaming with backpressure
- **Error recovery**: Graceful handling of network failures and malformed responses
- **Minimal dependencies**: Only libcurl and cJSON (both widely available)
- **Valgrind-clean**: No memory leaks or undefined behavior

## Architecture

### Package Structure

```
{package}/
├── CMakeLists.txt            # CMake build configuration
├── Makefile                  # Alternative Make build
├── include/
│   └── {package}/
│       ├── {package}.h       # Main public header (includes all)
│       ├── client.h          # Client handle and configuration
│       ├── types.h           # Generated type definitions
│       ├── resources.h       # Resource operations
│       ├── errors.h          # Error codes and handling
│       └── streaming.h       # SSE streaming support
└── src/
    ├── client.c              # Client implementation
    ├── types.c               # Type serialization/deserialization
    ├── resources.c           # Resource method implementations
    ├── errors.c              # Error handling implementation
    ├── streaming.c           # SSE parser implementation
    └── internal.h            # Internal helpers (not public)
```

### Core Components

#### 1. Error Handling (`errors.h`)

Error handling uses error codes with detailed error information:

```c
#ifndef {PACKAGE_UPPER}_ERRORS_H
#define {PACKAGE_UPPER}_ERRORS_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Error codes for SDK operations.
 */
typedef enum {
    {PACKAGE_UPPER}_OK = 0,                    /** Success */
    {PACKAGE_UPPER}_ERR_NULL_ARG,              /** Null argument provided */
    {PACKAGE_UPPER}_ERR_ALLOC,                 /** Memory allocation failed */
    {PACKAGE_UPPER}_ERR_INVALID_ARG,           /** Invalid argument value */
    {PACKAGE_UPPER}_ERR_CONNECTION,            /** Network connection failed */
    {PACKAGE_UPPER}_ERR_TIMEOUT,               /** Request timed out */
    {PACKAGE_UPPER}_ERR_CANCELLED,             /** Request was cancelled */
    {PACKAGE_UPPER}_ERR_HTTP,                  /** HTTP error (check status code) */
    {PACKAGE_UPPER}_ERR_SERIALIZE,             /** JSON serialization failed */
    {PACKAGE_UPPER}_ERR_DESERIALIZE,           /** JSON deserialization failed */
    {PACKAGE_UPPER}_ERR_STREAM,                /** Streaming error */
    {PACKAGE_UPPER}_ERR_INTERNAL,              /** Internal error */
} {package}_error_t;

/**
 * @brief Detailed error information.
 */
typedef struct {
    {package}_error_t code;       /** Error code */
    int http_status;              /** HTTP status code (if applicable) */
    char *message;                /** Human-readable error message (owned) */
    char *response_body;          /** Response body for HTTP errors (owned, may be NULL) */
} {package}_error_info_t;

/**
 * @brief Get a human-readable description for an error code.
 * @param code The error code.
 * @return Static string describing the error.
 */
const char *{package}_error_string({package}_error_t code);

/**
 * @brief Free error info resources.
 * @param info Error info to free (safe to call with NULL).
 */
void {package}_error_info_free({package}_error_info_t *info);

/**
 * @brief Check if an error is retriable.
 * @param info Error info to check.
 * @return Non-zero if the error is potentially retriable.
 */
int {package}_error_is_retriable(const {package}_error_info_t *info);

#ifdef __cplusplus
}
#endif

#endif /* {PACKAGE_UPPER}_ERRORS_H */
```

#### 2. Client (`client.h`)

The client handle and configuration:

```c
#ifndef {PACKAGE_UPPER}_CLIENT_H
#define {PACKAGE_UPPER}_CLIENT_H

#include "{package}/errors.h"
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/** Opaque client handle */
typedef struct {package}_client {package}_client_t;

/**
 * @brief Authentication mode.
 */
typedef enum {
    {PACKAGE_UPPER}_AUTH_NONE = 0,
    {PACKAGE_UPPER}_AUTH_BEARER,
    {PACKAGE_UPPER}_AUTH_BASIC,
    {PACKAGE_UPPER}_AUTH_API_KEY,
} {package}_auth_mode_t;

/**
 * @brief Client configuration options.
 */
typedef struct {
    const char *api_key;          /** API key (not copied, must outlive client) */
    const char *base_url;         /** Base URL (NULL for default) */
    {package}_auth_mode_t auth_mode; /** Authentication mode */
    uint32_t timeout_ms;          /** Request timeout in milliseconds (0 for default: 60000) */
    uint32_t max_retries;         /** Maximum retry attempts (0 for default: 2) */
    uint32_t connect_timeout_ms;  /** Connection timeout in milliseconds (0 for default: 10000) */

    /** Custom headers (NULL-terminated array of "Key: Value" strings, may be NULL) */
    const char **headers;

    /** User data pointer passed to callbacks */
    void *user_data;
} {package}_client_config_t;

/**
 * @brief Initialize default client configuration.
 * @param config Configuration to initialize.
 */
void {package}_client_config_init({package}_client_config_t *config);

/**
 * @brief Create a new client instance.
 * @param config Client configuration (NULL for defaults).
 * @param out_client Output pointer for the created client.
 * @return Error code (OK on success).
 */
{package}_error_t {package}_client_create(
    const {package}_client_config_t *config,
    {package}_client_t **out_client
);

/**
 * @brief Destroy a client instance and free all resources.
 * @param client Client to destroy (safe to call with NULL).
 */
void {package}_client_destroy({package}_client_t *client);

/**
 * @brief Get the user data pointer associated with the client.
 * @param client The client.
 * @return User data pointer, or NULL if not set.
 */
void *{package}_client_get_user_data(const {package}_client_t *client);

#ifdef __cplusplus
}
#endif

#endif /* {PACKAGE_UPPER}_CLIENT_H */
```

#### 3. Types (`types.h`)

Generated type definitions with builder pattern:

```c
#ifndef {PACKAGE_UPPER}_TYPES_H
#define {PACKAGE_UPPER}_TYPES_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Forward declarations for opaque types */
typedef struct {package}_{type_name} {package}_{type_name}_t;

/**
 * @brief Enum type with string values.
 */
typedef enum {
    {PACKAGE_UPPER}_{ENUM_NAME}_{VALUE_1},
    {PACKAGE_UPPER}_{ENUM_NAME}_{VALUE_2},
} {package}_{enum_name}_t;

/**
 * @brief Convert enum to wire string value.
 */
const char *{package}_{enum_name}_to_string({package}_{enum_name}_t value);

/**
 * @brief Parse enum from wire string value.
 * @return 0 on success, -1 if unknown value.
 */
int {package}_{enum_name}_from_string(const char *str, {package}_{enum_name}_t *out);

/* --- Struct Type Example --- */

/**
 * @brief {TypeDescription}
 *
 * Use {package}_{type_name}_builder_t for construction.
 */
typedef struct {package}_{type_name} {package}_{type_name}_t;

/** Builder for {type_name} */
typedef struct {package}_{type_name}_builder {package}_{type_name}_builder_t;

/**
 * @brief Create a new builder for {type_name}.
 * @return Builder instance, or NULL on allocation failure.
 */
{package}_{type_name}_builder_t *{package}_{type_name}_builder_create(void);

/**
 * @brief Set the {field_name} field.
 * @param builder The builder.
 * @param value The value (copied).
 * @return The builder for chaining.
 */
{package}_{type_name}_builder_t *{package}_{type_name}_builder_set_{field_name}(
    {package}_{type_name}_builder_t *builder,
    {field_c_type} value
);

/**
 * @brief Build the final object.
 * @param builder The builder (consumed).
 * @param out Output pointer for the built object.
 * @return 0 on success, -1 if required fields are missing.
 */
int {package}_{type_name}_builder_build(
    {package}_{type_name}_builder_t *builder,
    {package}_{type_name}_t **out
);

/**
 * @brief Destroy a builder without building.
 * @param builder Builder to destroy.
 */
void {package}_{type_name}_builder_destroy({package}_{type_name}_builder_t *builder);

/**
 * @brief Get the {field_name} field value.
 * @param obj The object.
 * @return Field value (borrowed, do not free).
 */
{field_c_type} {package}_{type_name}_get_{field_name}(const {package}_{type_name}_t *obj);

/**
 * @brief Destroy a {type_name} instance.
 * @param obj Object to destroy (safe to call with NULL).
 */
void {package}_{type_name}_destroy({package}_{type_name}_t *obj);

/* --- Array Type --- */

/**
 * @brief Dynamic array of {elem_type}.
 */
typedef struct {package}_{elem_type}_array {package}_{elem_type}_array_t;

/**
 * @brief Create an empty array.
 */
{package}_{elem_type}_array_t *{package}_{elem_type}_array_create(void);

/**
 * @brief Get the array length.
 */
size_t {package}_{elem_type}_array_len(const {package}_{elem_type}_array_t *arr);

/**
 * @brief Get an element by index.
 * @return Element (borrowed), or NULL if out of bounds.
 */
const {package}_{elem_type}_t *{package}_{elem_type}_array_get(
    const {package}_{elem_type}_array_t *arr,
    size_t index
);

/**
 * @brief Append an element to the array.
 * @param arr The array.
 * @param elem Element to append (ownership transferred).
 * @return 0 on success, -1 on failure.
 */
int {package}_{elem_type}_array_push(
    {package}_{elem_type}_array_t *arr,
    {package}_{elem_type}_t *elem
);

/**
 * @brief Destroy an array and all its elements.
 */
void {package}_{elem_type}_array_destroy({package}_{elem_type}_array_t *arr);

/* --- Union/Variant Type --- */

/**
 * @brief Union type discriminator.
 */
typedef enum {
    {PACKAGE_UPPER}_{UNION_NAME}_UNKNOWN = 0,
    {PACKAGE_UPPER}_{UNION_NAME}_{VARIANT_1},
    {PACKAGE_UPPER}_{UNION_NAME}_{VARIANT_2},
} {package}_{union_name}_kind_t;

/**
 * @brief Union type: {UnionDescription}
 */
typedef struct {package}_{union_name} {package}_{union_name}_t;

/**
 * @brief Get the kind/discriminator of a union value.
 */
{package}_{union_name}_kind_t {package}_{union_name}_kind(const {package}_{union_name}_t *u);

/**
 * @brief Get as variant1 (returns NULL if wrong kind).
 */
const {package}_{variant1}_t *{package}_{union_name}_as_{variant1}(const {package}_{union_name}_t *u);

/**
 * @brief Create union from variant1.
 * @param value Variant value (ownership transferred).
 */
{package}_{union_name}_t *{package}_{union_name}_from_{variant1}({package}_{variant1}_t *value);

/**
 * @brief Destroy a union value.
 */
void {package}_{union_name}_destroy({package}_{union_name}_t *u);

#ifdef __cplusplus
}
#endif

#endif /* {PACKAGE_UPPER}_TYPES_H */
```

#### 4. Resources (`resources.h`)

Resource operations with sync and callback-based async:

```c
#ifndef {PACKAGE_UPPER}_RESOURCES_H
#define {PACKAGE_UPPER}_RESOURCES_H

#include "{package}/client.h"
#include "{package}/types.h"
#include "{package}/errors.h"

#ifdef __cplusplus
extern "C" {
#endif

/* --- {Resource} Resource --- */

/**
 * @brief {MethodDescription}
 *
 * @param client The SDK client.
 * @param request The request object (borrowed, not consumed).
 * @param out_response Output pointer for the response (caller owns).
 * @param out_error Output pointer for error details (caller owns, may be NULL).
 * @return Error code (OK on success).
 */
{package}_error_t {package}_{resource}_{method}(
    {package}_client_t *client,
    const {package}_{request_type}_t *request,
    {package}_{response_type}_t **out_response,
    {package}_error_info_t *out_error
);

/* --- Streaming Method --- */

/**
 * @brief Callback for streaming events.
 *
 * @param event The event (borrowed, valid only during callback).
 * @param user_data User data from client config.
 * @return 0 to continue, non-zero to abort the stream.
 */
typedef int (*{package}_{resource}_{method}_callback_t)(
    const {package}_{event_type}_t *event,
    void *user_data
);

/**
 * @brief {StreamingMethodDescription}
 *
 * This is a blocking call that invokes the callback for each event.
 *
 * @param client The SDK client.
 * @param request The request object (borrowed).
 * @param callback Callback for each event.
 * @param out_error Output pointer for error details (may be NULL).
 * @return Error code (OK on success, or error if stream failed).
 */
{package}_error_t {package}_{resource}_{method}_stream(
    {package}_client_t *client,
    const {package}_{request_type}_t *request,
    {package}_{resource}_{method}_callback_t callback,
    {package}_error_info_t *out_error
);

/**
 * @brief Streaming context for manual iteration.
 */
typedef struct {package}_{resource}_{method}_stream_ctx {package}_{resource}_{method}_stream_ctx_t;

/**
 * @brief Start a streaming request (non-blocking setup).
 */
{package}_error_t {package}_{resource}_{method}_stream_start(
    {package}_client_t *client,
    const {package}_{request_type}_t *request,
    {package}_{resource}_{method}_stream_ctx_t **out_ctx,
    {package}_error_info_t *out_error
);

/**
 * @brief Get the next event from the stream.
 *
 * @param ctx Stream context.
 * @param out_event Output event (caller owns, NULL on end of stream).
 * @param out_error Output error details.
 * @return OK if event available, ERR_STREAM if end of stream, or error.
 */
{package}_error_t {package}_{resource}_{method}_stream_next(
    {package}_{resource}_{method}_stream_ctx_t *ctx,
    {package}_{event_type}_t **out_event,
    {package}_error_info_t *out_error
);

/**
 * @brief Close and destroy a stream context.
 */
void {package}_{resource}_{method}_stream_close({package}_{resource}_{method}_stream_ctx_t *ctx);

#ifdef __cplusplus
}
#endif

#endif /* {PACKAGE_UPPER}_RESOURCES_H */
```

#### 5. Streaming (`streaming.h`)

SSE parsing utilities:

```c
#ifndef {PACKAGE_UPPER}_STREAMING_H
#define {PACKAGE_UPPER}_STREAMING_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief SSE event structure.
 */
typedef struct {
    char *event;    /** Event type (owned, may be NULL) */
    char *data;     /** Event data (owned, may be NULL) */
    char *id;       /** Event ID (owned, may be NULL) */
    int retry;      /** Retry interval in ms (-1 if not set) */
} {package}_sse_event_t;

/**
 * @brief Free SSE event resources.
 */
void {package}_sse_event_free({package}_sse_event_t *event);

/**
 * @brief Opaque SSE parser.
 */
typedef struct {package}_sse_parser {package}_sse_parser_t;

/**
 * @brief Create a new SSE parser.
 */
{package}_sse_parser_t *{package}_sse_parser_create(void);

/**
 * @brief Feed data to the SSE parser.
 *
 * @param parser The parser.
 * @param data Data buffer.
 * @param len Data length.
 * @return Number of complete events now available.
 */
size_t {package}_sse_parser_feed(
    {package}_sse_parser_t *parser,
    const char *data,
    size_t len
);

/**
 * @brief Pop the next complete event from the parser.
 *
 * @param parser The parser.
 * @param out_event Output event (caller owns).
 * @return 1 if event available, 0 if no complete events.
 */
int {package}_sse_parser_pop(
    {package}_sse_parser_t *parser,
    {package}_sse_event_t *out_event
);

/**
 * @brief Destroy the SSE parser.
 */
void {package}_sse_parser_destroy({package}_sse_parser_t *parser);

#ifdef __cplusplus
}
#endif

#endif /* {PACKAGE_UPPER}_STREAMING_H */
```

## Type Mapping

### Primitive Types

| Contract Type     | C Type               | Notes                    |
|-------------------|----------------------|--------------------------|
| `string`          | `const char *`       | NULL-terminated, borrowed in getters |
| `bool`, `boolean` | `bool` / `int`       | Uses stdbool.h if available |
| `int`             | `int32_t`            | stdint.h                 |
| `int8`            | `int8_t`             |                          |
| `int16`           | `int16_t`            |                          |
| `int32`           | `int32_t`            |                          |
| `int64`           | `int64_t`            |                          |
| `uint`            | `uint32_t`           |                          |
| `uint8`           | `uint8_t`            |                          |
| `uint16`          | `uint16_t`           |                          |
| `uint32`          | `uint32_t`           |                          |
| `uint64`          | `uint64_t`           |                          |
| `float32`         | `float`              |                          |
| `float64`         | `double`             |                          |
| `time.Time`       | `int64_t`            | Unix timestamp (seconds) |
| `json.RawMessage` | `char *`             | Raw JSON string          |
| `any`             | `char *`             | Raw JSON string          |

### Collection Types

| Contract Type      | C Type                           |
|--------------------|----------------------------------|
| `[]T`              | `{package}_{T}_array_t *`        |
| `map[string]T`     | `{package}_string_{T}_map_t *`   |

### Optional/Nullable

Optional fields use pointer types or special "has" flags:

```c
/* For primitive types - use a "has" flag */
typedef struct {
    int32_t value;
    int has_value;  /* 0 if not set */
} {package}_optional_int32_t;

/* For pointer types - NULL means not set */
const char *field;  /* NULL if not set */
```

### Struct Fields

Required fields must be set via builder; optional fields have `_set` prefix methods:

```c
/* Builder pattern */
{package}_request_builder_t *b = {package}_request_builder_create();
{package}_request_builder_set_model(b, "claude-3");           /* Required */
{package}_request_builder_set_max_tokens(b, 1024);            /* Required */
{package}_request_builder_set_temperature(b, 0.7);            /* Optional */

{package}_request_t *req;
if ({package}_request_builder_build(b, &req) != 0) {
    /* Missing required fields */
}
```

### Enum/Const Values

Enums use integer constants with string conversion functions:

```c
typedef enum {
    ANTHROPIC_ROLE_USER = 0,
    ANTHROPIC_ROLE_ASSISTANT = 1,
    ANTHROPIC_ROLE_SYSTEM = 2,
} anthropic_role_t;

const char *anthropic_role_to_string(anthropic_role_t role);
int anthropic_role_from_string(const char *str, anthropic_role_t *out);
```

### Discriminated Unions

Unions use tagged union pattern:

```c
typedef enum {
    ANTHROPIC_CONTENT_BLOCK_UNKNOWN = 0,
    ANTHROPIC_CONTENT_BLOCK_TEXT,
    ANTHROPIC_CONTENT_BLOCK_IMAGE,
    ANTHROPIC_CONTENT_BLOCK_TOOL_USE,
} anthropic_content_block_kind_t;

typedef struct anthropic_content_block anthropic_content_block_t;

anthropic_content_block_kind_t anthropic_content_block_kind(
    const anthropic_content_block_t *block
);

const anthropic_text_block_t *anthropic_content_block_as_text(
    const anthropic_content_block_t *block
);

const anthropic_image_block_t *anthropic_content_block_as_image(
    const anthropic_content_block_t *block
);

/* Create from variant */
anthropic_content_block_t *anthropic_content_block_from_text(
    anthropic_text_block_t *text  /* ownership transferred */
);
```

## HTTP Client Implementation

### Request Flow

```c
/* Internal implementation (src/internal.h) */
typedef struct {
    CURL *curl;
    struct curl_slist *headers;
    char *response_body;
    size_t response_len;
    size_t response_cap;
    long http_status;
} {package}_http_ctx_t;

static size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) {
    {package}_http_ctx_t *ctx = userdata;
    size_t total = size * nmemb;

    /* Grow buffer if needed */
    while (ctx->response_len + total >= ctx->response_cap) {
        size_t new_cap = ctx->response_cap * 2;
        char *new_buf = realloc(ctx->response_body, new_cap);
        if (!new_buf) return 0;  /* Signal error */
        ctx->response_body = new_buf;
        ctx->response_cap = new_cap;
    }

    memcpy(ctx->response_body + ctx->response_len, ptr, total);
    ctx->response_len += total;
    ctx->response_body[ctx->response_len] = '\0';

    return total;
}

{package}_error_t {package}_http_request(
    {package}_client_t *client,
    const char *method,
    const char *path,
    const char *body,
    char **out_response,
    {package}_error_info_t *out_error
) {
    {package}_http_ctx_t ctx = {0};
    CURLcode res;
    int attempt;

    ctx.response_cap = 4096;
    ctx.response_body = malloc(ctx.response_cap);
    if (!ctx.response_body) {
        return {PACKAGE_UPPER}_ERR_ALLOC;
    }

    for (attempt = 0; attempt <= client->config.max_retries; attempt++) {
        ctx.response_len = 0;
        ctx.response_body[0] = '\0';

        ctx.curl = curl_easy_init();
        if (!ctx.curl) {
            free(ctx.response_body);
            return {PACKAGE_UPPER}_ERR_INTERNAL;
        }

        /* Build URL */
        char url[2048];
        snprintf(url, sizeof(url), "%s%s", client->config.base_url, path);

        curl_easy_setopt(ctx.curl, CURLOPT_URL, url);
        curl_easy_setopt(ctx.curl, CURLOPT_WRITEFUNCTION, write_callback);
        curl_easy_setopt(ctx.curl, CURLOPT_WRITEDATA, &ctx);
        curl_easy_setopt(ctx.curl, CURLOPT_TIMEOUT_MS, client->config.timeout_ms);
        curl_easy_setopt(ctx.curl, CURLOPT_CONNECTTIMEOUT_MS, client->config.connect_timeout_ms);

        /* Set method */
        if (strcmp(method, "POST") == 0) {
            curl_easy_setopt(ctx.curl, CURLOPT_POST, 1L);
            if (body) {
                curl_easy_setopt(ctx.curl, CURLOPT_POSTFIELDS, body);
            }
        } else if (strcmp(method, "PUT") == 0) {
            curl_easy_setopt(ctx.curl, CURLOPT_CUSTOMREQUEST, "PUT");
            if (body) {
                curl_easy_setopt(ctx.curl, CURLOPT_POSTFIELDS, body);
            }
        } else if (strcmp(method, "DELETE") == 0) {
            curl_easy_setopt(ctx.curl, CURLOPT_CUSTOMREQUEST, "DELETE");
        }

        /* Set headers */
        ctx.headers = NULL;
        ctx.headers = curl_slist_append(ctx.headers, "Content-Type: application/json");
        ctx.headers = curl_slist_append(ctx.headers, "Accept: application/json");

        /* Apply auth */
        if (client->config.api_key) {
            char auth_header[512];
            switch (client->config.auth_mode) {
            case {PACKAGE_UPPER}_AUTH_BEARER:
                snprintf(auth_header, sizeof(auth_header),
                    "Authorization: Bearer %s", client->config.api_key);
                break;
            case {PACKAGE_UPPER}_AUTH_BASIC:
                snprintf(auth_header, sizeof(auth_header),
                    "Authorization: Basic %s", client->config.api_key);
                break;
            case {PACKAGE_UPPER}_AUTH_API_KEY:
                snprintf(auth_header, sizeof(auth_header),
                    "X-API-Key: %s", client->config.api_key);
                break;
            default:
                break;
            }
            ctx.headers = curl_slist_append(ctx.headers, auth_header);
        }

        /* Apply custom headers */
        if (client->config.headers) {
            for (const char **h = client->config.headers; *h; h++) {
                ctx.headers = curl_slist_append(ctx.headers, *h);
            }
        }

        curl_easy_setopt(ctx.curl, CURLOPT_HTTPHEADER, ctx.headers);

        /* Perform request */
        res = curl_easy_perform(ctx.curl);
        curl_easy_getinfo(ctx.curl, CURLINFO_RESPONSE_CODE, &ctx.http_status);

        curl_slist_free_all(ctx.headers);
        curl_easy_cleanup(ctx.curl);

        if (res == CURLE_OK) {
            if (ctx.http_status >= 200 && ctx.http_status < 300) {
                *out_response = ctx.response_body;
                return {PACKAGE_UPPER}_OK;
            }

            /* HTTP error - check if retriable */
            if (ctx.http_status >= 500 || ctx.http_status == 429) {
                if (attempt < client->config.max_retries) {
                    /* Exponential backoff with jitter */
                    uint32_t delay_ms = (500 << attempt) + (rand() % 100);
                    usleep(delay_ms * 1000);
                    continue;
                }
            }

            /* Non-retriable or exhausted retries */
            if (out_error) {
                out_error->code = {PACKAGE_UPPER}_ERR_HTTP;
                out_error->http_status = (int)ctx.http_status;
                out_error->message = strdup("HTTP error");
                out_error->response_body = strdup(ctx.response_body);
            }
            free(ctx.response_body);
            return {PACKAGE_UPPER}_ERR_HTTP;
        }

        /* Network error - retry */
        if (attempt < client->config.max_retries) {
            uint32_t delay_ms = (500 << attempt) + (rand() % 100);
            usleep(delay_ms * 1000);
            continue;
        }
    }

    if (out_error) {
        out_error->code = {PACKAGE_UPPER}_ERR_CONNECTION;
        out_error->message = strdup(curl_easy_strerror(res));
    }
    free(ctx.response_body);
    return {PACKAGE_UPPER}_ERR_CONNECTION;
}
```

### SSE Streaming Implementation

```c
/* Streaming with callback */
typedef struct {
    {package}_sse_parser_t *parser;
    {package}_{resource}_{method}_callback_t callback;
    void *user_data;
    {package}_error_t error;
    int should_abort;
} stream_ctx_t;

static size_t stream_write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) {
    stream_ctx_t *ctx = userdata;
    size_t total = size * nmemb;

    size_t events = {package}_sse_parser_feed(ctx->parser, ptr, total);

    {package}_sse_event_t event;
    while ({package}_sse_parser_pop(ctx->parser, &event)) {
        if (event.data && strcmp(event.data, "[DONE]") != 0) {
            /* Parse JSON and invoke callback */
            {package}_{event_type}_t *parsed = NULL;
            if ({package}_{event_type}_from_json(event.data, &parsed) == 0) {
                if (ctx->callback(parsed, ctx->user_data) != 0) {
                    ctx->should_abort = 1;
                    {package}_{event_type}_destroy(parsed);
                    {package}_sse_event_free(&event);
                    return 0;  /* Abort */
                }
                {package}_{event_type}_destroy(parsed);
            }
        }
        {package}_sse_event_free(&event);
    }

    return total;
}
```

## Configuration

### Default Values

From contract `Defaults`:

```c
void {package}_client_config_init({package}_client_config_t *config) {
    memset(config, 0, sizeof(*config));
    config->base_url = "{defaults.baseURL}";
    config->auth_mode = {PACKAGE_UPPER}_AUTH_BEARER;  /* or from defaults.auth */
    config->timeout_ms = 60000;
    config->max_retries = 2;
    config->connect_timeout_ms = 10000;
}
```

### Environment Variables

The SDK does NOT automatically read environment variables. Users should handle this explicitly:

```c
anthropic_client_config_t config;
anthropic_client_config_init(&config);
config.api_key = getenv("ANTHROPIC_API_KEY");

anthropic_client_t *client;
anthropic_client_create(&config, &client);
```

## Naming Conventions

### C Naming

| Contract       | C                          |
|----------------|----------------------------|
| `user-id`      | `user_id`                  |
| `user_name`    | `user_name`                |
| `UserData`     | `user_data`                |
| `create`       | `create`                   |
| `get-user`     | `get_user`                 |
| `getMessage`   | `get_message`              |

Functions:
- `to_c_name(s)`: Converts to snake_case
- `to_c_type_name(s)`: Converts to snake_case with package prefix
- `to_c_constant(s)`: Converts to UPPER_SNAKE_CASE
- `sanitize_ident(s)`: Removes invalid characters

Special handling:
- Reserved words: Prefixed with underscore (`_class`, `_register`)
- C keywords: `auto`, `break`, `case`, `char`, `const`, `continue`, `default`, `do`, `double`, `else`, `enum`, `extern`, `float`, `for`, `goto`, `if`, `int`, `long`, `register`, `return`, `short`, `signed`, `sizeof`, `static`, `struct`, `switch`, `typedef`, `union`, `unsigned`, `void`, `volatile`, `while`, `inline`, `restrict`, `_Bool`, `_Complex`, `_Imaginary`

## Code Generation

### Generator Structure

```go
package sdkc

type Config struct {
    // Package is the C package/library name (used as prefix).
    // Default: sanitized snake_case service name.
    Package string

    // Version is the library version.
    // Default: "0.0.0".
    Version string

    // HeaderGuardPrefix is the prefix for header guards.
    // Default: UPPER_SNAKE_CASE of package.
    HeaderGuardPrefix string

    // UseCJSON uses cJSON library (default true).
    // If false, uses json-c.
    UseCJSON bool

    // SingleHeader generates a single amalgamated header.
    // Default: false.
    SingleHeader bool
}

func Generate(svc *contract.Service, cfg *Config) ([]*sdk.File, error)
```

### Template Files

```
templates/
├── CMakeLists.txt.tmpl        # CMake build configuration
├── Makefile.tmpl              # Make build configuration
├── client.h.tmpl              # Client header
├── client.c.tmpl              # Client implementation
├── types.h.tmpl               # Type definitions header
├── types.c.tmpl               # Type serialization
├── resources.h.tmpl           # Resource operations header
├── resources.c.tmpl           # Resource implementations
├── errors.h.tmpl              # Error definitions
├── errors.c.tmpl              # Error implementation
├── streaming.h.tmpl           # SSE streaming header
├── streaming.c.tmpl           # SSE implementation
└── internal.h.tmpl            # Internal helpers
```

### Generated Files

| File                     | Purpose                           |
|--------------------------|-----------------------------------|
| `CMakeLists.txt`         | CMake build configuration         |
| `Makefile`               | Make build configuration          |
| `include/{pkg}/{pkg}.h`  | Main public header                |
| `include/{pkg}/client.h` | Client handle and config          |
| `include/{pkg}/types.h`  | Type definitions                  |
| `include/{pkg}/resources.h` | Resource operations            |
| `include/{pkg}/errors.h` | Error codes and handling          |
| `include/{pkg}/streaming.h` | SSE streaming                  |
| `src/client.c`           | Client implementation             |
| `src/types.c`            | Type serialization                |
| `src/resources.c`        | Resource implementations          |
| `src/errors.c`           | Error implementation              |
| `src/streaming.c`        | SSE parser                        |
| `src/internal.h`         | Internal helpers                  |

## Usage Examples

### Basic Usage

```c
#include <anthropic/anthropic.h>
#include <stdio.h>

int main(void) {
    anthropic_client_t *client = NULL;
    anthropic_client_config_t config;
    anthropic_error_info_t error = {0};

    /* Initialize configuration */
    anthropic_client_config_init(&config);
    config.api_key = getenv("ANTHROPIC_API_KEY");

    /* Create client */
    if (anthropic_client_create(&config, &client) != ANTHROPIC_OK) {
        fprintf(stderr, "Failed to create client\n");
        return 1;
    }

    /* Build request */
    anthropic_create_message_request_builder_t *builder =
        anthropic_create_message_request_builder_create();

    anthropic_create_message_request_builder_set_model(builder, "claude-3-sonnet-20240229");
    anthropic_create_message_request_builder_set_max_tokens(builder, 1024);

    /* Build messages array */
    anthropic_message_array_t *messages = anthropic_message_array_create();

    anthropic_message_builder_t *msg_builder = anthropic_message_builder_create();
    anthropic_message_builder_set_role(msg_builder, ANTHROPIC_ROLE_USER);
    anthropic_message_builder_set_content(msg_builder, "Hello, Claude!");

    anthropic_message_t *msg;
    anthropic_message_builder_build(msg_builder, &msg);
    anthropic_message_array_push(messages, msg);

    anthropic_create_message_request_builder_set_messages(builder, messages);

    anthropic_create_message_request_t *request;
    if (anthropic_create_message_request_builder_build(builder, &request) != 0) {
        fprintf(stderr, "Failed to build request\n");
        anthropic_client_destroy(client);
        return 1;
    }

    /* Make request */
    anthropic_message_t *response = NULL;
    anthropic_error_t err = anthropic_messages_create(client, request, &response, &error);

    if (err != ANTHROPIC_OK) {
        fprintf(stderr, "API error: %s\n", error.message);
        anthropic_error_info_free(&error);
        anthropic_create_message_request_destroy(request);
        anthropic_client_destroy(client);
        return 1;
    }

    /* Print response */
    const anthropic_content_block_array_t *content = anthropic_message_get_content(response);
    for (size_t i = 0; i < anthropic_content_block_array_len(content); i++) {
        const anthropic_content_block_t *block = anthropic_content_block_array_get(content, i);
        if (anthropic_content_block_kind(block) == ANTHROPIC_CONTENT_BLOCK_TEXT) {
            const anthropic_text_block_t *text = anthropic_content_block_as_text(block);
            printf("%s\n", anthropic_text_block_get_text(text));
        }
    }

    /* Cleanup */
    anthropic_message_destroy(response);
    anthropic_create_message_request_destroy(request);
    anthropic_client_destroy(client);

    return 0;
}
```

### Streaming

```c
#include <anthropic/anthropic.h>
#include <stdio.h>

static int on_stream_event(const anthropic_message_stream_event_t *event, void *user_data) {
    (void)user_data;

    if (anthropic_message_stream_event_get_type(event) == ANTHROPIC_STREAM_EVENT_CONTENT_BLOCK_DELTA) {
        const anthropic_delta_t *delta = anthropic_message_stream_event_get_delta(event);
        if (delta) {
            const char *text = anthropic_delta_get_text(delta);
            if (text) {
                printf("%s", text);
                fflush(stdout);
            }
        }
    }

    return 0;  /* Continue streaming */
}

int main(void) {
    anthropic_client_t *client = NULL;
    anthropic_client_config_t config;
    anthropic_error_info_t error = {0};

    anthropic_client_config_init(&config);
    config.api_key = getenv("ANTHROPIC_API_KEY");

    if (anthropic_client_create(&config, &client) != ANTHROPIC_OK) {
        return 1;
    }

    /* Build streaming request */
    anthropic_create_message_request_builder_t *builder =
        anthropic_create_message_request_builder_create();

    anthropic_create_message_request_builder_set_model(builder, "claude-3-sonnet-20240229");
    anthropic_create_message_request_builder_set_max_tokens(builder, 1024);
    anthropic_create_message_request_builder_set_stream(builder, 1);

    /* ... add messages ... */

    anthropic_create_message_request_t *request;
    anthropic_create_message_request_builder_build(builder, &request);

    /* Stream with callback */
    anthropic_error_t err = anthropic_messages_create_stream(
        client, request, on_stream_event, &error
    );

    if (err != ANTHROPIC_OK) {
        fprintf(stderr, "\nStream error: %s\n", error.message);
        anthropic_error_info_free(&error);
    }

    printf("\n");

    anthropic_create_message_request_destroy(request);
    anthropic_client_destroy(client);

    return err == ANTHROPIC_OK ? 0 : 1;
}
```

### Error Handling

```c
anthropic_error_info_t error = {0};
anthropic_error_t err = anthropic_messages_create(client, request, &response, &error);

switch (err) {
case ANTHROPIC_OK:
    /* Success */
    break;

case ANTHROPIC_ERR_HTTP:
    if (error.http_status == 429) {
        fprintf(stderr, "Rate limited, please retry later\n");
    } else if (error.http_status >= 400 && error.http_status < 500) {
        fprintf(stderr, "Client error %d: %s\n", error.http_status, error.message);
        if (error.response_body) {
            fprintf(stderr, "Response: %s\n", error.response_body);
        }
    } else {
        fprintf(stderr, "Server error %d\n", error.http_status);
    }
    break;

case ANTHROPIC_ERR_TIMEOUT:
    fprintf(stderr, "Request timed out\n");
    break;

case ANTHROPIC_ERR_CONNECTION:
    fprintf(stderr, "Connection failed: %s\n", error.message);
    break;

case ANTHROPIC_ERR_SERIALIZE:
    fprintf(stderr, "Failed to serialize request\n");
    break;

case ANTHROPIC_ERR_DESERIALIZE:
    fprintf(stderr, "Failed to parse response\n");
    break;

default:
    fprintf(stderr, "Error: %s\n", anthropic_error_string(err));
    break;
}

anthropic_error_info_free(&error);
```

### Pattern Matching on Unions

```c
const anthropic_content_block_t *block = ...;

switch (anthropic_content_block_kind(block)) {
case ANTHROPIC_CONTENT_BLOCK_TEXT: {
    const anthropic_text_block_t *text = anthropic_content_block_as_text(block);
    printf("Text: %s\n", anthropic_text_block_get_text(text));
    break;
}
case ANTHROPIC_CONTENT_BLOCK_IMAGE: {
    const anthropic_image_block_t *image = anthropic_content_block_as_image(block);
    printf("Image URL: %s\n", anthropic_image_block_get_url(image));
    break;
}
case ANTHROPIC_CONTENT_BLOCK_TOOL_USE: {
    const anthropic_tool_use_block_t *tool = anthropic_content_block_as_tool_use(block);
    printf("Tool: %s\n", anthropic_tool_use_block_get_name(tool));
    break;
}
default:
    printf("Unknown content block type\n");
    break;
}
```

### Custom Configuration

```c
anthropic_client_config_t config;
anthropic_client_config_init(&config);

config.api_key = "your-api-key";
config.base_url = "https://custom.api.com";
config.timeout_ms = 120000;       /* 2 minutes */
config.max_retries = 3;
config.connect_timeout_ms = 5000; /* 5 seconds */

const char *custom_headers[] = {
    "X-Custom-Header: value",
    "X-Another-Header: another-value",
    NULL  /* NULL-terminated */
};
config.headers = custom_headers;

anthropic_client_t *client;
anthropic_client_create(&config, &client);
```

### Memory Management Best Practices

```c
/* Always check return values */
anthropic_client_t *client = NULL;
if (anthropic_client_create(&config, &client) != ANTHROPIC_OK) {
    /* Handle error */
}

/* Use RAII-style cleanup pattern */
#define CLEANUP_CLIENT __attribute__((cleanup(cleanup_client)))
static void cleanup_client(anthropic_client_t **client) {
    if (*client) anthropic_client_destroy(*client);
}

void example(void) {
    CLEANUP_CLIENT anthropic_client_t *client = NULL;
    anthropic_client_create(&config, &client);

    /* client is automatically destroyed when function returns */
}

/* Or use explicit cleanup with goto */
void example2(void) {
    anthropic_client_t *client = NULL;
    anthropic_request_t *request = NULL;
    anthropic_response_t *response = NULL;
    int result = -1;

    if (anthropic_client_create(&config, &client) != ANTHROPIC_OK)
        goto cleanup;

    if (build_request(&request) != 0)
        goto cleanup;

    if (anthropic_messages_create(client, request, &response, NULL) != ANTHROPIC_OK)
        goto cleanup;

    /* Use response */
    result = 0;

cleanup:
    anthropic_response_destroy(response);
    anthropic_request_destroy(request);
    anthropic_client_destroy(client);
    return result;
}
```

## Testing

### Generator Tests

```go
func TestGenerate_NilService(t *testing.T)
func TestGenerate_ValidC_Compiles(t *testing.T)
func TestGenerate_ProducesExpectedFiles(t *testing.T)
func TestGenerate_TypeMapping(t *testing.T)
func TestGenerate_StreamingMethods(t *testing.T)
func TestGenerate_UnionTypes(t *testing.T)
func TestGenerate_MemorySafety(t *testing.T)
```

### Generated SDK Tests

The generated SDK includes a test structure:

```
tests/
├── test_client.c       # Client creation/destruction tests
├── test_types.c        # Type builder and serialization tests
├── test_resources.c    # Resource method tests (mocked)
├── test_streaming.c    # SSE parser tests
└── test_memory.c       # Valgrind-compatible memory tests
```

## Platform Support

### Dependencies

**Required:**
- `libcurl` (>= 7.60.0) - HTTP client
- `cJSON` (>= 1.7.0) - JSON parsing (header-only available)

**Optional:**
- `pthread` - Thread safety for shared resources

### Build Requirements

| Platform      | Minimum Version | Notes                           |
|---------------|-----------------|--------------------------------|
| GCC           | 7.0             | C11 support                    |
| Clang         | 6.0             | C11 support                    |
| MSVC          | 2019            | C11 support (partial)          |
| CMake         | 3.14            | Modern CMake patterns          |

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.14)
project({package} VERSION {version} LANGUAGES C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

# Find dependencies
find_package(CURL REQUIRED)
find_package(cJSON REQUIRED)

# Library sources
set(SOURCES
    src/client.c
    src/types.c
    src/resources.c
    src/errors.c
    src/streaming.c
)

# Create library
add_library(${PROJECT_NAME} ${SOURCES})
target_include_directories(${PROJECT_NAME} PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)
target_link_libraries(${PROJECT_NAME}
    PRIVATE CURL::libcurl
    PRIVATE cJSON::cJSON
)

# Install rules
install(TARGETS ${PROJECT_NAME}
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
)
install(DIRECTORY include/ DESTINATION include)
```

## Thread Safety

The SDK provides the following thread safety guarantees:

1. **Client handle**: A single client handle can be used concurrently from multiple threads for making requests.
2. **Request/response objects**: Not thread-safe; do not share between threads without synchronization.
3. **Global state**: `curl_global_init()` must be called once before using the SDK (not thread-safe).

```c
/* Global initialization (call once at program start) */
curl_global_init(CURL_GLOBAL_DEFAULT);

/* Now safe to create clients and make concurrent requests */
pthread_t threads[10];
for (int i = 0; i < 10; i++) {
    pthread_create(&threads[i], NULL, worker_func, client);
}

/* Cleanup at program end */
curl_global_cleanup();
```

## Future Enhancements

1. **Async I/O**: Integration with libuv or libev for non-blocking I/O
2. **Connection pooling**: Reuse connections for multiple requests
3. **Request pipelining**: HTTP/2 multiplexing support
4. **Response caching**: Built-in caching with configurable TTL
5. **Metrics**: Request timing and success rate tracking
6. **TLS certificate pinning**: Enhanced security for mobile/embedded
7. **WebSocket support**: For bidirectional streaming
8. **Arena allocator**: Optional arena allocation for reduced malloc overhead

## References

- [C11 Standard](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)
- [libcurl Documentation](https://curl.se/libcurl/c/)
- [cJSON Documentation](https://github.com/DaveGamble/cJSON)
- [GNU C Coding Standards](https://www.gnu.org/prep/standards/standards.html)
- [SEI CERT C Coding Standard](https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard)
- [Effective C (Robert C. Seacord)](https://nostarch.com/Effective_C)
