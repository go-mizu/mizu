Below is a **clean, independent rewrite of the `live` package proposal**, aligned with **Go core library naming conventions**, minimalism, and long-term reuse.
This is intentionally symmetric with the new `sync` proposal but clearly non-authoritative.

---

# Live Package Proposal

## Purpose

Package `live` provides **low-latency realtime message delivery** over WebSocket with topic-based publish and subscribe.

It is designed as a **transport and fanout layer**, not a correctness layer. Messages are best-effort. If a client disconnects or misses messages, recovery must happen through another mechanism such as `sync`, polling, or reload.

`live` is reusable infrastructure. It supports view runtimes, sync acceleration, multiplayer lobbies, dashboards, streaming logs, and presence without embedding any domain semantics.

---

## Design principles

1. **Transport-only**
   `live` moves messages. It does not interpret or validate state.

2. **Best-effort delivery**
   No durability or replay guarantees.

3. **Topic-based fanout**
   Scalable, simple routing model.

4. **Opaque payloads**
   Higher layers define schemas.

5. **Minimal surface area**
   Few types, predictable behavior.

6. **Independent**
   No dependency on `sync`, `view`, or application logic.

---

## Package layout

```
live/
  doc.go        // Package documentation
  server.go     // Server
  session.go    // Session
  pubsub.go     // Topic routing
  message.go    // Message envelope
  codec.go      // Encoding interface
  ws.go         // WebSocket transport
  errors.go     // Error values
```

---

## Core concepts

### Server

`Server` owns sessions, pubsub state, and the WebSocket handler.

```go
type Server struct {
    // unexported fields
}
```

```go
type Options struct {
    Codec     Codec
    QueueSize int

    OnAuth    func(context.Context, *http.Request) (Meta, error)
    OnMessage func(context.Context, *Session, Message)
    OnClose   func(*Session, error)
}
```

```go
func New(opts Options) *Server
func (s *Server) Handler() http.Handler
```

Naming rationale:

* `Server` matches `http.Server`
* `Handler()` matches `http.Handler` conventions
* Callbacks are optional and explicit

---

### Session

A `Session` represents a single connected client.

```go
type Session struct {
    // unexported
}
```

```go
func (s *Session) ID() string
func (s *Session) Meta() Meta
func (s *Session) Send(msg Message) error
func (s *Session) Close() error
```

Notes:

* Each session has an outbound queue
* Backpressure is enforced per session
* `Send` is non-blocking

---

### Meta

`Meta` holds authenticated connection metadata.

```go
type Meta map[string]any
```

Notes:

* Populated by `OnAuth`
* Treated as read-only by `live`

---

### Message

`Message` is the transport envelope.

```go
type Message struct {
    Type  string
    Topic string
    Ref   string
    Body  []byte
}
```

Naming rationale:

* Short, unambiguous fields
* `Body` is opaque bytes
* No embedded semantics

---

### Codec

`Codec` defines message encoding.

```go
type Codec interface {
    Encode(Message) ([]byte, error)
    Decode([]byte) (Message, error)
}
```

Default codecs:

* JSON (human-friendly)
* MessagePack (efficient)

Notes:

* Payload remains opaque to `live`
* Encoding is pluggable, not hardcoded

---

### PubSub

`PubSub` routes messages by topic.

```go
type PubSub interface {
    Subscribe(*Session, string)
    Unsubscribe(*Session, string)
    Publish(string, Message)
}
```

Notes:

* Topics are plain strings
* No wildcard or hierarchy by default
* Higher layers define conventions

---

## Behavior

### Connection lifecycle

1. HTTP request upgraded to WebSocket
2. `OnAuth` called (optional)
3. Session created
4. Read loop decodes messages
5. `OnMessage` invoked
6. Session closed on error or disconnect
7. `OnClose` invoked

---

### Backpressure policy

Each session has a bounded send queue.

Default behavior:

* If queue is full, close the session

Rationale:

* Predictable
* Protects server health
* Avoids silent memory growth

---

### Topic subscription

Subscriptions are explicit messages interpreted by higher layers.

Example conventions:

* `JOIN <topic>`
* `LEAVE <topic>`

`live` itself does not define these semantics.
It only exposes `Subscribe` and `Unsubscribe`.

---

## Optional features

### Presence

Presence can be layered using pubsub state.

Possible helpers:

* `Who(topic) []SessionID`
* Join/leave notifications

Presence is intentionally minimal and optional.

---

### Coalescing and rate limiting

Hooks may be added at publish time to:

* Drop redundant messages
* Keep only the latest value per topic
* Throttle inbound message rates

These are transport optimizations, not correctness features.

---

## What `live` does not do

Deliberately out of scope:

* Durable state
* Cursor tracking
* Replay or recovery
* HTML diffing or UI logic
* Mutation validation
* Distributed replication

If a client must recover state, it must use another system.

---

## Relationship to `sync`

* `sync` may call `live` through a tiny adapter
* Example: notify clients that a scope advanced
* `live` never calls into `sync`

This keeps correctness and transport cleanly separated.

---

## Supported use cases

1. Sync acceleration
   Notify clients to pull updates immediately.

2. View runtimes
   Deliver UI patches and events.

3. Multiplayer lobbies
   Fanout room events and presence.

4. Streaming
   Logs, progress, metrics.

5. Agents and CLIs
   Simple realtime notifications.

---

## Why this matches Go core style

* Short names (`Server`, `Session`, `Log`-like responsibilities)
* Interfaces describe behavior
* No builders or fluent APIs
* Explicit ownership of state
* Transport separate from semantics

---

## Summary

* `live` is a **realtime transport and fanout layer**
* It is intentionally non-authoritative
* It composes naturally with `sync`
* The API is small, stable, and reusable
* Correctness lives elsewhere

If you want, next we can:

* Freeze this as `live` v1 API
* Map it directly to your current `view/live` files
* Define exact wire message shapes for JSON and MessagePack
