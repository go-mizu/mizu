package page

import (
	"fmt"
	"time"

	"github.com/go-mizu/mizu/view/live"
)

// Message represents a chat message.
type Message struct {
	From string
	Text string
	Time time.Time
}

// ChatMessage is sent via PubSub when a user sends a message.
type ChatMessage struct {
	From string
	Text string
	Room string
}

// UserJoined is sent via PubSub when a user joins.
type UserJoined struct {
	Room     string
	Username string
}

// UserLeft is sent via PubSub when a user leaves.
type UserLeft struct {
	Room     string
	Username string
}

// ChatState holds the chat page state.
type ChatState struct {
	Room     string
	Username string
	Messages []Message
	Users    []string
	Error    string
}

// ChatPage implements a real-time chat room.
type ChatPage struct {
	PubSub live.PubSub
}

// Mount initializes the chat state and subscribes to the room.
func (p *ChatPage) Mount(ctx *live.Ctx, s *live.Session[ChatState]) error {
	// Generate a random username for demo
	s.State.Room = "general"
	s.State.Username = fmt.Sprintf("User%d", time.Now().UnixNano()%10000)
	s.State.Messages = []Message{}
	s.State.Users = []string{}

	// Subscribe to room messages
	if err := ctx.Subscribe("room:" + s.State.Room); err != nil {
		return err
	}

	// Announce join
	if p.PubSub != nil {
		p.PubSub.Publish("room:"+s.State.Room, UserJoined{
			Room:     s.State.Room,
			Username: s.State.Username,
		})
	}

	s.MarkAll()
	return nil
}

// Render returns the view configuration.
func (p *ChatPage) Render(ctx *live.Ctx, s *live.Session[ChatState]) (live.View, error) {
	return live.View{
		Page: "chat/index",
		Regions: map[string]string{
			"messages": "chat/messages",
			"users":    "chat/users",
			"error":    "chat/error",
		},
	}, nil
}

// Handle processes user events.
func (p *ChatPage) Handle(ctx *live.Ctx, s *live.Session[ChatState], e live.Event) error {
	switch e.Name {
	case "send":
		text := e.Form.Get("message")
		if text == "" {
			return nil
		}

		// Publish message to all subscribers
		if p.PubSub != nil {
			p.PubSub.Publish("room:"+s.State.Room, ChatMessage{
				From: s.State.Username,
				Text: text,
				Room: s.State.Room,
			})
		}

	case "change-name":
		newName := e.Form.Get("username")
		if newName != "" && newName != s.State.Username {
			oldName := s.State.Username
			s.State.Username = newName

			// Announce name change
			if p.PubSub != nil {
				p.PubSub.Publish("room:"+s.State.Room, UserLeft{
					Room:     s.State.Room,
					Username: oldName,
				})
				p.PubSub.Publish("room:"+s.State.Room, UserJoined{
					Room:     s.State.Room,
					Username: newName,
				})
			}
		}
	}
	return nil
}

// Info handles server-side messages (PubSub events).
func (p *ChatPage) Info(ctx *live.Ctx, s *live.Session[ChatState], msg any) error {
	switch m := msg.(type) {
	case ChatMessage:
		s.State.Messages = append(s.State.Messages, Message{
			From: m.From,
			Text: m.Text,
			Time: time.Now(),
		})
		// Keep only last 100 messages
		if len(s.State.Messages) > 100 {
			s.State.Messages = s.State.Messages[len(s.State.Messages)-100:]
		}
		s.Mark("messages")
		// Scroll to bottom
		s.Push(live.Scroll{Selector: "#messages", Block: "end"})

	case UserJoined:
		// Add user if not already present
		found := false
		for _, u := range s.State.Users {
			if u == m.Username {
				found = true
				break
			}
		}
		if !found {
			s.State.Users = append(s.State.Users, m.Username)
			s.Mark("users")
		}

	case UserLeft:
		// Remove user
		for i, u := range s.State.Users {
			if u == m.Username {
				s.State.Users = append(s.State.Users[:i], s.State.Users[i+1:]...)
				s.Mark("users")
				break
			}
		}
	}
	return nil
}
